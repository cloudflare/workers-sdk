/**
 * Runtime code template for Pages Functions.
 *
 * This module contains the runtime code that gets inlined into the generated
 * worker entrypoint. It handles route matching and middleware execution.
 */

/**
 * Generate the runtime code that handles request routing and middleware execution.
 *
 * This code is inlined into the generated worker entrypoint to avoid requiring
 * an additional runtime dependency.
 */
export function generateRuntimeCode(): string {
	// Using an array join to avoid template literal parsing issues with regex
	const lines = [
		"// Pages Functions Runtime",
		"// This code is generated by @cloudflare/pages-functions",
		"",
		"const escapeRegex = /[.+?^${}()|[\\]\\\\]/g;",
		"",
		"function* executeRequest(request, routes) {",
		"  const requestPath = new URL(request.url).pathname;",
		"",
		'  // First, iterate through the routes (backwards) and execute "middlewares" on partial route matches',
		"  for (const route of [...routes].reverse()) {",
		"    if (route.method && route.method !== request.method) {",
		"      continue;",
		"    }",
		"",
		'    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\\\$&"), {',
		"      end: false,",
		"    });",
		'    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\\\$&"), {',
		"      end: false,",
		"    });",
		"    const matchResult = routeMatcher(requestPath);",
		"    const mountMatchResult = mountMatcher(requestPath);",
		"    if (matchResult && mountMatchResult) {",
		"      for (const handler of route.middlewares.flat()) {",
		"        yield {",
		"          handler,",
		"          params: matchResult.params,",
		"          path: mountMatchResult.path,",
		"        };",
		"      }",
		"    }",
		"  }",
		"",
		'  // Then look for the first exact route match and execute its "modules"',
		"  for (const route of routes) {",
		"    if (route.method && route.method !== request.method) {",
		"      continue;",
		"    }",
		'    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\\\$&"), {',
		"      end: true,",
		"    });",
		'    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\\\$&"), {',
		"      end: false,",
		"    });",
		"    const matchResult = routeMatcher(requestPath);",
		"    const mountMatchResult = mountMatcher(requestPath);",
		"    if (matchResult && mountMatchResult && route.modules.length) {",
		"      for (const handler of route.modules.flat()) {",
		"        yield {",
		"          handler,",
		"          params: matchResult.params,",
		"          path: matchResult.path,",
		"        };",
		"      }",
		"      break;",
		"    }",
		"  }",
		"}",
		"",
		"function createPagesHandler(routes, fallbackService) {",
		"  return {",
		"    async fetch(originalRequest, env, workerContext) {",
		"      let request = originalRequest;",
		"      const handlerIterator = executeRequest(request, routes);",
		"      let data = {};",
		"      let isFailOpen = false;",
		"",
		"      const next = async (input, init) => {",
		"        if (input !== undefined) {",
		"          let url = input;",
		'          if (typeof input === "string") {',
		"            url = new URL(input, request.url).toString();",
		"          }",
		"          request = new Request(url, init);",
		"        }",
		"",
		"        const result = handlerIterator.next();",
		"        if (result.done === false) {",
		"          const { handler, params, path } = result.value;",
		"          const context = {",
		"            request: new Request(request.clone()),",
		"            functionPath: path,",
		"            next,",
		"            params,",
		"            get data() {",
		"              return data;",
		"            },",
		"            set data(value) {",
		'              if (typeof value !== "object" || value === null) {',
		'                throw new Error("context.data must be an object");',
		"              }",
		"              data = value;",
		"            },",
		"            env,",
		"            waitUntil: workerContext.waitUntil.bind(workerContext),",
		"            passThroughOnException: () => {",
		"              isFailOpen = true;",
		"            },",
		"          };",
		"",
		"          const response = await handler(context);",
		"",
		"          if (!(response instanceof Response)) {",
		'            throw new Error("Your Pages function should return a Response");',
		"          }",
		"",
		"          return cloneResponse(response);",
		"        } else if (fallbackService && env[fallbackService]) {",
		"          const response = await env[fallbackService].fetch(request);",
		"          return cloneResponse(response);",
		"        } else {",
		'          return new Response("Not Found", { status: 404 });',
		"        }",
		"      };",
		"",
		"      try {",
		"        return await next();",
		"      } catch (error) {",
		"        if (isFailOpen && fallbackService && env[fallbackService]) {",
		"          const response = await env[fallbackService].fetch(request);",
		"          return cloneResponse(response);",
		"        }",
		"        throw error;",
		"      }",
		"    },",
		"  };",
		"}",
		"",
		"const cloneResponse = (response) =>",
		"  new Response(",
		"    [101, 204, 205, 304].includes(response.status) ? null : response.body,",
		"    response",
		"  );",
	];

	return lines.join("\n");
}
