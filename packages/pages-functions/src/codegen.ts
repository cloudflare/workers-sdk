/**
 * Code generation for Pages Functions.
 *
 * Generates a worker entrypoint from route configuration.
 */

import * as path from "node:path";
import { isValidIdentifier, normalizeIdentifier } from "./identifiers.js";
import { generateRuntimeCode } from "./runtime.js";
import type { RouteConfig } from "./types.js";

/**
 * Internal representation of routes with resolved identifiers.
 */
interface ResolvedRoute {
	routePath: string;
	mountPath: string;
	method: string;
	middlewares: string[];
	modules: string[];
}

/**
 * Import map entry.
 */
interface ImportEntry {
	filepath: string;
	name: string;
	identifier: string;
}

/**
 * Options for generating the worker entrypoint.
 */
export interface GenerateOptions {
	/** Base directory containing the functions */
	functionsDirectory: string;
	/** Fallback service binding name (default: "ASSETS") */
	fallbackService?: string;
}

/**
 * Generate a worker entrypoint from route configuration.
 *
 * @param routes Route configuration from filepath-routing
 * @param options Generation options
 * @returns Generated JavaScript code
 */
export function generateWorkerEntrypoint(
	routes: RouteConfig[],
	options: GenerateOptions
): string {
	const { functionsDirectory, fallbackService = "ASSETS" } = options;

	const { importMap, resolvedRoutes } = resolveRoutes(
		routes,
		functionsDirectory
	);
	const imports = generateImports(importMap);
	const routesArray = generateRoutesArray(resolvedRoutes);
	const runtime = generateRuntimeCode();

	return [
		"// Generated by @cloudflare/pages-functions",
		"",
		'import { match } from "path-to-regexp";',
		"",
		"// User function imports",
		imports,
		"",
		"// Route configuration",
		routesArray,
		"",
		`const __FALLBACK_SERVICE__ = ${JSON.stringify(fallbackService)};`,
		"",
		"// Runtime",
		runtime,
		"",
		"// Export the handler",
		"export default createPagesHandler(routes, __FALLBACK_SERVICE__);",
	].join("\n");
}

/**
 * Resolve route module references to import identifiers.
 */
function resolveRoutes(
	routes: RouteConfig[],
	baseDir: string
): { importMap: Map<string, ImportEntry>; resolvedRoutes: ResolvedRoute[] } {
	const importMap = new Map<string, ImportEntry>();
	const identifierCount = new Map<string, number>();

	function resolveModuleReferences(
		paths: string | string[] | undefined
	): string[] {
		if (typeof paths === "undefined") {
			return [];
		}

		if (typeof paths === "string") {
			paths = [paths];
		}

		return paths.map((modulePath) => {
			const [filepath, name = "default"] = modulePath.split(":");
			let entry = importMap.get(modulePath);

			if (!entry) {
				const resolvedPath = path.resolve(baseDir, filepath);

				// Validate module name to guard against injection attacks
				if (name !== "default" && !isValidIdentifier(name)) {
					throw new Error(`Invalid module identifier "${name}"`);
				}

				let identifier = normalizeIdentifier(`__${filepath}_${name}`);

				let count = identifierCount.get(identifier) ?? 0;
				identifierCount.set(identifier, ++count);

				if (count > 1) {
					identifier += `_${count}`;
				}

				entry = { filepath: resolvedPath, name, identifier };
				importMap.set(modulePath, entry);
			}

			return entry.identifier;
		});
	}

	const resolvedRoutes: ResolvedRoute[] = routes.map(
		({ routePath, mountPath, method, middleware, module }) => ({
			routePath,
			mountPath,
			method: method ?? "",
			middlewares: resolveModuleReferences(middleware),
			modules: resolveModuleReferences(module),
		})
	);

	return { importMap, resolvedRoutes };
}

/**
 * Generate import statements from the import map.
 */
function generateImports(importMap: Map<string, ImportEntry>): string {
	return [...importMap.values()]
		.map(
			({ filepath, name, identifier }) =>
				`import { ${name} as ${identifier} } from ${JSON.stringify(filepath)};`
		)
		.join("\n");
}

/**
 * Generate the routes array declaration.
 */
function generateRoutesArray(routes: ResolvedRoute[]): string {
	const routeStrings = routes.map((route) => {
		const middlewares = `[${route.middlewares.join(", ")}]`;
		const modules = `[${route.modules.join(", ")}]`;

		return [
			"  {",
			`    routePath: ${JSON.stringify(route.routePath)},`,
			`    mountPath: ${JSON.stringify(route.mountPath)},`,
			`    method: ${JSON.stringify(route.method)},`,
			`    middlewares: ${middlewares},`,
			`    modules: ${modules},`,
			"  }",
		].join("\n");
	});

	return `const routes = [\n${routeStrings.join(",\n")}\n];`;
}
