import path from "node:path";
import { build } from "esbuild";

export type ExportMap = Map<
	string,
	"WorkerEntrypoint" | "DurableObject" | "WorkflowEntrypoint" | null
>;

/**
 * Guesses the exports of the main Worker.
 *
 * We do this by running a lightweight esbuild of the main script, and looking at the meta-file generated by esbuild.
 *
 * - This doesn't support Python Workers, but then neither does Vitest.
 * - Workers that need to be built with Vite plugins (e.g. containing wildcard re-exported virtual imports)
 *   may not work with esbuild and so we won't be able to find the exports. But in these cases, the user can
 *   always manually specify the exports in the Wrangler config via Service bindings, Workflows, or Durable Object migrations.
 *
 * @param entryFile The entry file of the Worker.
 * @param additionalExports Additional exports to include in the export map.
 *
 * @returns A map of export names to their types (WorkerEntrypoint, DurableObject, WorkflowEntrypoint), or null if unknown.
 */
export async function guessWorkerExports(
	entryFile: string | undefined,
	additionalExports: {
		[exportName: string]:
			| "WorkerEntrypoint"
			| "DurableObject"
			| "WorkflowEntrypoint";
	} = {}
): Promise<ExportMap> {
	const exportMap: ExportMap = new Map(Object.entries(additionalExports));
	if (entryFile === undefined) {
		return exportMap;
	}

	if (path.extname(entryFile) == ".py") {
		// We don't support Python Workers here.
		return exportMap;
	}

	const result = await build({
		target: "es2024",
		loader: { ".js": "jsx", ".mjs": "jsx", ".cjs": "jsx" },
		entryPoints: [path.resolve(entryFile)],
		metafile: true,
		bundle: false,
		write: false,
		logLevel: "silent",
	});

	const entryPoints = Object.values(result.metafile.outputs).filter(
		(output) => output.entryPoint !== undefined
	);
	if (entryPoints.length === 0) {
		throw new Error(
			`Cannot find entry-point "${entryFile}" in generated bundle.`
		);
	}
	if (entryPoints.length > 1) {
		throw new Error(
			"More than one entry-point found for generated bundle.\n" +
				entryPoints.map((output) => ` - ${output.entryPoint}`).join("\n")
		);
	}

	for (const exportName of entryPoints[0].exports) {
		// For now we have no way to guess the type..
		if (!exportMap.has(exportName)) {
			exportMap.set(exportName, null);
		}
	}

	return exportMap;
}
