{"version":3,"file":"TickingFlameChartHelpers.js","sourceRoot":"","sources":["../../../../../../front_end/panels/media/TickingFlameChartHelpers.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,MAAM,UAAU,2BAA2B,CAAC,EAAU,EAAE,aAAqB;IAC3E,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,aAAa,CAAC,CAAC;IACnD,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC;IAClE,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,UAAU,CAAC,GAAG,gBAAgB,IAAI,CAAC;AAC/D,CAAC;AAED;;;GAGG;AACH,MAAM,OAAO,MAAM;IACT,WAAW,CAAS;IACpB,WAAW,CAAS;IACpB,WAAW,CAAS;IACpB,YAAY,CAAS;IACZ,QAAQ,CAAS;IACjB,QAAQ,CAAS;IAClC,YAAY,UAAkB,EAAE,WAAmB,EAAE,QAAgB,EAAE,QAAgB;QACrF,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAC9B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QACpC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAED,IAAI,GAAG;QACL,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,IAAI,IAAI;QACN,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED,IAAI,GAAG;QACL,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,IAAI,GAAG;QACL,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;IAC9C,CAAC;IAEO,cAAc;QACpB,IAAI,eAAe,GAAG,IAAI,CAAC;QAC3B,OAAO,eAAe,EAAE;YACtB,eAAe,GAAG,KAAK,CAAC;YACxB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE;gBAC9B,eAAe,GAAG,IAAI,CAAC;gBACvB,MAAM,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBAC/C,IAAI,CAAC,YAAY,IAAI,KAAK,CAAC;gBAC3B,IAAI,CAAC,WAAW,IAAI,KAAK,CAAC;aAC3B;YAED,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,EAAE;gBACvC,eAAe,GAAG,IAAI,CAAC;gBACvB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;aACrC;YAED,IAAI,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,EAAE;gBACxC,eAAe,GAAG,IAAI,CAAC;gBACvB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;aACtC;SACF;IACH,CAAC;IAED;;OAEG;IACH,OAAO,CAAC,MAAc,EAAE,QAAgB;QACtC,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;QACnD,MAAM,QAAQ,GAAG,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,KAAK,CAAC;QACvD,MAAM,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;QACnC,MAAM,OAAO,GAAG,QAAQ,GAAG,MAAM,CAAC;QAClC,IAAI,CAAC,WAAW,IAAI,MAAM,CAAC;QAC3B,IAAI,CAAC,YAAY,IAAI,OAAO,CAAC;QAC7B,IAAI,CAAC,cAAc,EAAE,CAAC;IACxB,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,MAAc,EAAE,QAAgB;QACrC,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;QACnD,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YAC/B,OAAO;SACR;QAED,MAAM,UAAU,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QACzD,MAAM,MAAM,GAAG,UAAU,GAAG,QAAQ,CAAC;QACrC,MAAM,OAAO,GAAG,UAAU,GAAG,MAAM,CAAC;QACpC,IAAI,CAAC,WAAW,IAAI,MAAM,CAAC;QAC3B,IAAI,CAAC,YAAY,IAAI,OAAO,CAAC;QAC7B,IAAI,CAAC,cAAc,EAAE,CAAC;IACxB,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,MAAc;QACnB,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;QACnD,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,KAAK,IAAI,CAAC,WAAW,CAAC;QAC3D,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,KAAK,IAAI,CAAC,WAAW,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC;QAEpF,IAAI,CAAC,WAAW,IAAI,MAAM,CAAC;QAC3B,IAAI,WAAW,IAAI,WAAW,EAAE;YAC9B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC;SACtC;QACD,IAAI,CAAC,cAAc,EAAE,CAAC;IACxB,CAAC;IAED;;OAEG;IACH,gBAAgB,CAAC,IAAY;QAC3B,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,EAAE;YAC3B,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;YACrC,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport function formatMillisecondsToSeconds(ms: number, decimalPlaces: number): string {\n  const roundPower = Math.pow(10, 3 - decimalPlaces);\n  const denominatorPower = Math.pow(10, Math.max(0, decimalPlaces));\n  return `${Math.round(ms / roundPower) / denominatorPower} s`;\n}\n\n/**\n * Manage the bounding box properties for the ticking flame chart.\n * kept in a separate file for unit testing.\n */\nexport class Bounds {\n  private minInternal: number;\n  private maxInternal: number;\n  private lowInternal: number;\n  private highInternal: number;\n  private readonly maxRange: number;\n  private readonly minRange: number;\n  constructor(initialLow: number, initialHigh: number, maxRange: number, minRange: number) {\n    this.minInternal = initialLow;\n    this.maxInternal = initialHigh;\n    this.lowInternal = this.minInternal;\n    this.highInternal = this.maxInternal;\n    this.maxRange = maxRange;\n    this.minRange = minRange;\n  }\n\n  get low(): number {\n    return this.lowInternal;\n  }\n\n  get high(): number {\n    return this.highInternal;\n  }\n\n  get min(): number {\n    return this.minInternal;\n  }\n\n  get max(): number {\n    return this.maxInternal;\n  }\n\n  get range(): number {\n    return this.highInternal - this.lowInternal;\n  }\n\n  private reassertBounds(): void {\n    let needsAdjustment = true;\n    while (needsAdjustment) {\n      needsAdjustment = false;\n      if (this.range < this.minRange) {\n        needsAdjustment = true;\n        const delta = (this.minRange - this.range) / 2;\n        this.highInternal += delta;\n        this.lowInternal -= delta;\n      }\n\n      if (this.lowInternal < this.minInternal) {\n        needsAdjustment = true;\n        this.lowInternal = this.minInternal;\n      }\n\n      if (this.highInternal > this.maxInternal) {\n        needsAdjustment = true;\n        this.highInternal = this.maxInternal;\n      }\n    }\n  }\n\n  /**\n   * zoom out |amount| ticks at position [0, 1] along the current range of the timeline.\n   */\n  zoomOut(amount: number, position: number): void {\n    const range = this.highInternal - this.lowInternal;\n    const growSize = range * Math.pow(1.1, amount) - range;\n    const lowEnd = growSize * position;\n    const highEnd = growSize - lowEnd;\n    this.lowInternal -= lowEnd;\n    this.highInternal += highEnd;\n    this.reassertBounds();\n  }\n\n  /**\n   * zoom in |amount| ticks at position [0, 1] along the current range of the timeline.\n   */\n  zoomIn(amount: number, position: number): void {\n    const range = this.highInternal - this.lowInternal;\n    if (this.range <= this.minRange) {\n      return;\n    }\n\n    const shrinkSize = range - range / Math.pow(1.1, amount);\n    const lowEnd = shrinkSize * position;\n    const highEnd = shrinkSize - lowEnd;\n    this.lowInternal += lowEnd;\n    this.highInternal -= highEnd;\n    this.reassertBounds();\n  }\n\n  /**\n   * Add Xms to the max value, and scroll the timeline forward if the end is in sight.\n   */\n  addMax(amount: number): void {\n    const range = this.highInternal - this.lowInternal;\n    const isAtHighEnd = this.highInternal === this.maxInternal;\n    const isZoomedOut = this.lowInternal === this.minInternal || range >= this.maxRange;\n\n    this.maxInternal += amount;\n    if (isAtHighEnd && isZoomedOut) {\n      this.highInternal = this.maxInternal;\n    }\n    this.reassertBounds();\n  }\n\n  /**\n   * Attempt to push the maximum time up to |time| ms.\n   */\n  pushMaxAtLeastTo(time: number): boolean {\n    if (this.maxInternal < time) {\n      this.addMax(time - this.maxInternal);\n      return true;\n    }\n    return false;\n  }\n}\n"]}