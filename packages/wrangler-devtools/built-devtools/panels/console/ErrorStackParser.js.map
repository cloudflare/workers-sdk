{"version":3,"file":"ErrorStackParser.js","sourceRoot":"","sources":["../../../../../../front_end/panels/console/ErrorStackParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport interface ParsedErrorFrame {\n  line: string;\n  link?: {\n    url: Platform.DevToolsPath.UrlString,\n    prefix: string,\n    suffix: string,\n    lineNumber?: number,\n    columnNumber?: number, enclosedInBraces: boolean,\n    scriptId?: Protocol.Runtime.ScriptId,\n  };\n}\n\n/**\n * Takes a V8 Error#stack string and extracts source position information.\n *\n * The result includes the url, line and column number, as well as where\n * the url is found in the raw line.\n *\n * @returns Null if the provided string has an unexpected format. A\n *          populated `ParsedErrorFrame[]` otherwise.\n */\nexport function parseSourcePositionsFromErrorStack(\n    runtimeModel: SDK.RuntimeModel.RuntimeModel, stack: string): ParsedErrorFrame[]|null {\n  if (!/^[\\w.]*Error\\b/.test(stack)) {\n    return null;\n  }\n  const debuggerModel = runtimeModel.debuggerModel();\n  const baseURL = runtimeModel.target().inspectedURL();\n\n  const lines = stack.split('\\n');\n  const linkInfos = [];\n  for (const line of lines) {\n    const isCallFrameLine = /^\\s*at\\s/.test(line);\n    if (!isCallFrameLine && linkInfos.length && linkInfos[linkInfos.length - 1].link) {\n      return null;\n    }\n\n    if (!isCallFrameLine) {\n      linkInfos.push({line});\n      continue;\n    }\n\n    let openBracketIndex = -1;\n    let closeBracketIndex = -1;\n    const inBracketsWithLineAndColumn = /\\([^\\)\\(]+:\\d+:\\d+\\)/g;\n    const inBrackets = /\\([^\\)\\(]+\\)/g;\n    let lastMatch: RegExpExecArray|null = null;\n    let currentMatch;\n    while ((currentMatch = inBracketsWithLineAndColumn.exec(line))) {\n      lastMatch = currentMatch;\n    }\n    if (!lastMatch) {\n      while ((currentMatch = inBrackets.exec(line))) {\n        lastMatch = currentMatch;\n      }\n    }\n    if (lastMatch) {\n      openBracketIndex = lastMatch.index;\n      closeBracketIndex = lastMatch.index + lastMatch[0].length - 1;\n    }\n    const hasOpenBracket = openBracketIndex !== -1;\n    let left = hasOpenBracket ? openBracketIndex + 1 : line.indexOf('at') + 3;\n    if (!hasOpenBracket && line.indexOf('async ') === left) {\n      left += 6;\n    }\n    const right = hasOpenBracket ? closeBracketIndex : line.length;\n    const linkCandidate = line.substring(left, right);\n    const splitResult = Common.ParsedURL.ParsedURL.splitLineAndColumn(linkCandidate);\n    if (splitResult.url === '<anonymous>') {\n      linkInfos.push({line});\n      continue;\n    }\n    let url = parseOrScriptMatch(debuggerModel, splitResult.url);\n    if (!url && Common.ParsedURL.ParsedURL.isRelativeURL(splitResult.url)) {\n      url = parseOrScriptMatch(debuggerModel, Common.ParsedURL.ParsedURL.completeURL(baseURL, splitResult.url));\n    }\n    if (!url) {\n      return null;\n    }\n\n    linkInfos.push({\n      line,\n      link: {\n        url,\n        prefix: line.substring(0, left),\n        suffix: line.substring(right),\n        enclosedInBraces: hasOpenBracket,\n        lineNumber: splitResult.lineNumber,\n        columnNumber: splitResult.columnNumber,\n      },\n    });\n  }\n  return linkInfos;\n}\n\nfunction parseOrScriptMatch(debuggerModel: SDK.DebuggerModel.DebuggerModel, url: Platform.DevToolsPath.UrlString|null):\n    Platform.DevToolsPath.UrlString|null {\n  if (!url) {\n    return null;\n  }\n  if (Common.ParsedURL.ParsedURL.isValidUrlString(url)) {\n    return url;\n  }\n  if (debuggerModel.scriptsForSourceURL(url).length) {\n    return url;\n  }\n  // nodejs stack traces contain (absolute) file paths, but v8 reports them as file: urls.\n  const fileUrl = new URL(url, 'file://');\n  if (debuggerModel.scriptsForSourceURL(fileUrl.href).length) {\n    return fileUrl.href as Platform.DevToolsPath.UrlString;\n  }\n  return null;\n}\n\n/**\n * Error#stack output only contains script URLs. In some cases we are able to\n * retrieve additional exception details from V8 that we can use to augment\n * the parsed Error#stack with script IDs.\n * This function sets the `scriptId` field in `ParsedErrorFrame` when it finds\n * the corresponding info in `Protocol.Runtime.StackTrace`.\n */\nexport function augmentErrorStackWithScriptIds(\n    parsedFrames: ParsedErrorFrame[], protocolStackTrace: Protocol.Runtime.StackTrace): void {\n  // Note that the number of frames between the two stack traces can differ. The\n  // parsed Error#stack can contain Builtin frames which are not present in the protocol\n  // stack. This means its easier to always search the whole protocol stack for a matching\n  // frame rather then trying to detect the Builtin frames and skipping them.\n  for (const parsedFrame of parsedFrames) {\n    const protocolFrame = protocolStackTrace.callFrames.find(frame => framesMatch(parsedFrame, frame));\n    if (protocolFrame && parsedFrame.link) {\n      parsedFrame.link.scriptId = protocolFrame.scriptId;\n    }\n  }\n}\n\n/** Returns true iff both stack frames have the same url and line/column numbers. The function name is ignored */\nfunction framesMatch(parsedFrame: ParsedErrorFrame, protocolFrame: Protocol.Runtime.CallFrame): boolean {\n  if (!parsedFrame.link) {\n    return false;\n  }\n\n  const {url, lineNumber, columnNumber} = parsedFrame.link;\n  return url === protocolFrame.url && lineNumber === protocolFrame.lineNumber &&\n      columnNumber === protocolFrame.columnNumber;\n}\n"]}