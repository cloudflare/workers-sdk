{"version":3,"file":"LighthouseProtocolService.js","sourceRoot":"","sources":["../../../../../../front_end/panels/lighthouse/LighthouseProtocolService.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2018 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as ProtocolClient from '../../core/protocol_client/protocol_client.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\n\nimport type * as ReportRenderer from './LighthouseReporterTypes.js';\n\n/**\n * @overview\n                                                   ┌────────────┐\n                                                   │CDP Backend │\n                                                   └────────────┘\n                                                        │ ▲\n                                                        │ │ parallelConnection\n                          ┌┐                            ▼ │                     ┌┐\n                          ││   dispatchProtocolMessage     sendProtocolMessage  ││\n                          ││                     │          ▲                   ││\n          ProtocolService ││                     |          │                   ││\n                          ││    sendWithResponse ▼          │                   ││\n                          ││              │    send          onWorkerMessage    ││\n                          └┘              │    │                 ▲              └┘\n          worker boundary - - - - - - - - ┼ - -│- - - - - - - - -│- - - - - - - - - - - -\n                          ┌┐              ▼    ▼                 │                    ┌┐\n                          ││   onFrontendMessage      notifyFrontendViaWorkerMessage  ││\n                          ││                   │       ▲                              ││\n                          ││                   ▼       │                              ││\nLighthouseWorkerService   ││          Either ConnectionProxy or LegacyPort            ││\n                          ││                           │ ▲                            ││\n                          ││     ┌─────────────────────┼─┼───────────────────────┐    ││\n                          ││     │  Lighthouse    ┌────▼──────┐                  │    ││\n                          ││     │                │connection │                  │    ││\n                          ││     │                └───────────┘                  │    ││\n                          └┘     └───────────────────────────────────────────────┘    └┘\n\n * All messages traversing the worker boundary are action-wrapped.\n * All messages over the parallelConnection speak pure CDP.\n * All messages within ConnectionProxy/LegacyPort speak pure CDP.\n * The foundational CDP connection is `parallelConnection`.\n * All connections within the worker are not actual ParallelConnection's.\n*/\n\nlet lastId = 1;\n\nexport interface LighthouseRun {\n  inspectedURL: Platform.DevToolsPath.UrlString;\n  categoryIDs: string[];\n  flags: Record<string, Object|undefined>;\n}\n\n/**\n * ProtocolService manages a connection between the frontend (Lighthouse panel) and the Lighthouse worker.\n */\nexport class ProtocolService {\n  private targetInfo?: {\n    mainSessionId: string,\n    mainTargetId: string,\n    mainFrameId: string,\n  };\n  private parallelConnection?: ProtocolClient.InspectorBackend.Connection;\n  private lighthouseWorkerPromise?: Promise<Worker>;\n  private lighthouseMessageUpdateCallback?: ((arg0: string) => void);\n\n  async attach(): Promise<void> {\n    await SDK.TargetManager.TargetManager.instance().suspendAllTargets();\n    const mainTarget = SDK.TargetManager.TargetManager.instance().mainTarget();\n    if (!mainTarget) {\n      throw new Error('Unable to find main target required for Lighthouse');\n    }\n    const childTargetManager = mainTarget.model(SDK.ChildTargetManager.ChildTargetManager);\n    if (!childTargetManager) {\n      throw new Error('Unable to find child target manager required for Lighthouse');\n    }\n    const resourceTreeModel = mainTarget.model(SDK.ResourceTreeModel.ResourceTreeModel);\n    if (!resourceTreeModel) {\n      throw new Error('Unable to find resource tree model required for Lighthouse');\n    }\n    const mainFrame = resourceTreeModel.mainFrame;\n    if (!mainFrame) {\n      throw new Error('Unable to find main frame required for Lighthouse');\n    }\n\n    const {connection, sessionId} = await childTargetManager.createParallelConnection(message => {\n      if (typeof message === 'string') {\n        message = JSON.parse(message);\n      }\n      this.dispatchProtocolMessage(message);\n    });\n\n    this.parallelConnection = connection;\n    this.targetInfo = {\n      mainTargetId: await childTargetManager.getParentTargetId(),\n      mainFrameId: mainFrame.id,\n      mainSessionId: sessionId,\n    };\n  }\n\n  getLocales(): readonly string[] {\n    return [i18n.DevToolsLocale.DevToolsLocale.instance().locale];\n  }\n\n  async startTimespan(currentLighthouseRun: LighthouseRun): Promise<void> {\n    const {inspectedURL, categoryIDs, flags} = currentLighthouseRun;\n\n    if (!this.targetInfo) {\n      throw new Error('Unable to get target info required for Lighthouse');\n    }\n\n    await this.sendWithResponse('startTimespan', {\n      url: inspectedURL,\n      categoryIDs,\n      flags,\n      locales: this.getLocales(),\n      target: this.targetInfo,\n    });\n  }\n\n  async collectLighthouseResults(currentLighthouseRun: LighthouseRun): Promise<ReportRenderer.RunnerResult> {\n    const {inspectedURL, categoryIDs, flags} = currentLighthouseRun;\n\n    if (!this.targetInfo) {\n      throw new Error('Unable to get target info required for Lighthouse');\n    }\n\n    let mode = flags.mode as string;\n    if (mode === 'timespan') {\n      mode = 'endTimespan';\n    }\n\n    return this.sendWithResponse(mode, {\n      url: inspectedURL,\n      categoryIDs,\n      flags,\n      locales: this.getLocales(),\n      target: this.targetInfo,\n    });\n  }\n\n  async detach(): Promise<void> {\n    const oldLighthouseWorker = this.lighthouseWorkerPromise;\n    const oldParallelConnection = this.parallelConnection;\n\n    // When detaching, make sure that we remove the old promises, before we\n    // perform any async cleanups. That way, if there is a message coming from\n    // lighthouse while we are in the process of cleaning up, we shouldn't deliver\n    // them to the backend.\n    this.lighthouseWorkerPromise = undefined;\n    this.parallelConnection = undefined;\n\n    if (oldLighthouseWorker) {\n      (await oldLighthouseWorker).terminate();\n    }\n    if (oldParallelConnection) {\n      await oldParallelConnection.disconnect();\n    }\n    await SDK.TargetManager.TargetManager.instance().resumeAllTargets();\n  }\n\n  registerStatusCallback(callback: (arg0: string) => void): void {\n    this.lighthouseMessageUpdateCallback = callback;\n  }\n\n  private dispatchProtocolMessage(message: Object): void {\n    // A message without a sessionId is the main session of the main target (call it \"Main session\").\n    // A parallel connection and session was made that connects to the same main target (call it \"Lighthouse session\").\n    // Messages from the \"Lighthouse session\" have a sessionId.\n    // Without some care, there is a risk of sending the same events for the same main frame to Lighthouse–the backend\n    // will create events for the \"Main session\" and the \"Lighthouse session\".\n    // The workaround–only send message to Lighthouse if:\n    //   * the message has a sessionId (is not for the \"Main session\")\n    //   * the message does not have a sessionId (is for the \"Main session\"), but only for the Target domain\n    //     (to kickstart autoAttach in LH).\n    const protocolMessage = message as {\n      sessionId?: string,\n      method?: string,\n    };\n    if (protocolMessage.sessionId || (protocolMessage.method && protocolMessage.method.startsWith('Target'))) {\n      void this.send('dispatchProtocolMessage', {message: JSON.stringify(message)});\n    }\n  }\n\n  private initWorker(): Promise<Worker> {\n    this.lighthouseWorkerPromise = new Promise<Worker>(resolve => {\n      const workerUrl = new URL('../../entrypoints/lighthouse_worker/lighthouse_worker.js', import.meta.url);\n      const remoteBaseSearchParam = new URL(self.location.href).searchParams.get('remoteBase');\n      if (remoteBaseSearchParam) {\n        // Allows Lighthouse worker to fetch remote locale files.\n        workerUrl.searchParams.set('remoteBase', remoteBaseSearchParam);\n      }\n      const worker = new Worker(workerUrl, {type: 'module'});\n\n      worker.addEventListener('message', event => {\n        if (event.data === 'workerReady') {\n          resolve(worker);\n          return;\n        }\n\n        this.onWorkerMessage(event);\n      });\n    });\n    return this.lighthouseWorkerPromise;\n  }\n\n  private async ensureWorkerExists(): Promise<Worker> {\n    let worker: Worker;\n    if (!this.lighthouseWorkerPromise) {\n      worker = await this.initWorker();\n    } else {\n      worker = await this.lighthouseWorkerPromise;\n    }\n    return worker;\n  }\n\n  private onWorkerMessage(event: MessageEvent): void {\n    const lighthouseMessage = JSON.parse(event.data);\n\n    if (lighthouseMessage.action === 'statusUpdate') {\n      if (this.lighthouseMessageUpdateCallback && lighthouseMessage.args && 'message' in lighthouseMessage.args) {\n        this.lighthouseMessageUpdateCallback(lighthouseMessage.args.message as string);\n      }\n    } else if (lighthouseMessage.action === 'sendProtocolMessage') {\n      if (lighthouseMessage.args && 'message' in lighthouseMessage.args) {\n        this.sendProtocolMessage(lighthouseMessage.args.message as string);\n      }\n    }\n  }\n\n  private sendProtocolMessage(message: string): void {\n    if (this.parallelConnection) {\n      this.parallelConnection.sendRawMessage(message);\n    }\n  }\n\n  private async send(action: string, args: {[x: string]: string|string[]|Object} = {}): Promise<void> {\n    const worker = await this.ensureWorkerExists();\n    const messageId = lastId++;\n    worker.postMessage(JSON.stringify({id: messageId, action, args: {...args, id: messageId}}));\n  }\n\n  /** sendWithResponse currently only handles the original startLighthouse request and LHR-filled response. */\n  private async sendWithResponse(action: string, args: {[x: string]: string|string[]|Object} = {}):\n      Promise<ReportRenderer.RunnerResult> {\n    const worker = await this.ensureWorkerExists();\n    const messageId = lastId++;\n    const messageResult = new Promise<ReportRenderer.RunnerResult>(resolve => {\n      const workerListener = (event: MessageEvent): void => {\n        const lighthouseMessage = JSON.parse(event.data);\n\n        if (lighthouseMessage.id === messageId) {\n          worker.removeEventListener('message', workerListener);\n          resolve(lighthouseMessage.result);\n        }\n      };\n      worker.addEventListener('message', workerListener);\n    });\n    worker.postMessage(JSON.stringify({id: messageId, action, args: {...args, id: messageId}}));\n\n    return messageResult;\n  }\n}\n"]}