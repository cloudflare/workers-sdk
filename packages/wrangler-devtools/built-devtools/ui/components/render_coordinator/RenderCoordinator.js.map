{"version":3,"file":"RenderCoordinator.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/render_coordinator/RenderCoordinator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Components don't orchestrate their DOM updates in a wider context\n * (i.e. the host frame's document), which leads to interleaved reading\n * and writing of layout-centric values, e.g. clientHeight, scrollTop etc.\n *\n * This helper to ensure that we do reads, writes, and scrolls at the\n * correct point in the frame lifecycle. It groups reads to the start of a\n * frame, where we can assume layout-centric values are available on the\n * basis of the last completed frame, and then it runs all writes\n * afterwards. In the event that a read / write / scroll callback contains\n * calls for more read / write / scroll calls, such calls will be scheduled\n * for the next available frame.\n */\n\ninterface CoordinatorCallback {\n  (): unknown;\n}\n\ninterface CoordinatorFrame {\n  readers: CoordinatorCallback[];\n  writers: CoordinatorCallback[];\n}\n\ninterface CoordinatorLogEntry {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  static readonly eventName = 'renderqueueempty';\n  constructor() {\n    super(RenderCoordinatorQueueEmptyEvent.eventName);\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  static readonly eventName = 'newframe';\n  constructor() {\n    super(RenderCoordinatorNewFrameEvent.eventName);\n  }\n}\n\ntype RenderCoordinatorResolverCallback = (value: unknown) => void;\ntype RenderCoordinatorRejectorCallback = (error: Error) => void;\n\nlet renderCoordinatorInstance: RenderCoordinator;\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__getRenderCoordinatorPendingFrames = function(): number {\n  return RenderCoordinator.pendingFramesCount();\n};\n\nexport class RenderCoordinator extends EventTarget {\n  static instance({forceNew = false} = {}): RenderCoordinator {\n    if (!renderCoordinatorInstance || forceNew) {\n      renderCoordinatorInstance = new RenderCoordinator();\n    }\n\n    return renderCoordinatorInstance;\n  }\n\n  static pendingFramesCount(): number {\n    if (!renderCoordinatorInstance) {\n      throw new Error('No render coordinator instance found.');\n    }\n\n    return renderCoordinatorInstance.pendingFramesCount();\n  }\n\n  // Toggle on to start tracking. You must call takeRecords() to\n  // obtain the records. Please note: records are limited by maxRecordSize below.\n  observe = false;\n  recordStorageLimit = 100;\n\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  observeOnlyNamed = true;\n\n  readonly #logInternal: CoordinatorLogEntry[] = [];\n\n  readonly #pendingWorkFrames: CoordinatorFrame[] = [];\n  readonly #resolvers = new WeakMap<CoordinatorCallback, RenderCoordinatorResolverCallback>();\n  readonly #rejectors = new WeakMap<CoordinatorCallback, RenderCoordinatorRejectorCallback>();\n  readonly #labels = new WeakMap<CoordinatorCallback, string>();\n  #scheduledWorkId = 0;\n\n  pendingFramesCount(): number {\n    return this.#pendingWorkFrames.length;\n  }\n\n  done(): Promise<void> {\n    if (this.#pendingWorkFrames.length === 0) {\n      this.#logIfEnabled('[Queue empty]');\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this.addEventListener('renderqueueempty', () => resolve(), {once: true}));\n  }\n\n  async read<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Read called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_READ);\n  }\n\n  async write<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Write called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.WRITE, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.WRITE, UNNAMED_WRITE);\n  }\n\n  takeRecords(): CoordinatorLogEntry[] {\n    const logs = [...this.#logInternal];\n    this.#logInternal.length = 0;\n    return logs;\n  }\n\n  /**\n   * We offer a convenience function for scroll-based activity, but often triggering a scroll\n   * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n   * the layout-triggering work has been completed then it should be possible to scroll without\n   * first forcing layout.\n   */\n  async scroll<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Scroll called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_SCROLL);\n  }\n\n  #enqueueHandler<T = unknown>(callback: CoordinatorCallback, action: ACTION, label = ''): Promise<T> {\n    this.#labels.set(callback, `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`);\n\n    if (this.#pendingWorkFrames.length === 0) {\n      this.#pendingWorkFrames.push({\n        readers: [],\n        writers: [],\n      });\n    }\n\n    const frame = this.#pendingWorkFrames[0];\n    if (!frame) {\n      throw new Error('No frame available');\n    }\n\n    switch (action) {\n      case ACTION.READ:\n        frame.readers.push(callback);\n        break;\n\n      case ACTION.WRITE:\n        frame.writers.push(callback);\n        break;\n\n      default:\n        throw new Error(`Unknown action: ${action}`);\n    }\n\n    const resolverPromise = new Promise((resolve, reject) => {\n      this.#resolvers.set(callback, resolve);\n      this.#rejectors.set(callback, reject);\n    });\n\n    this.#scheduleWork();\n    return resolverPromise as Promise<T>;\n  }\n\n  async #handleWork(handler: CoordinatorCallback): Promise<void> {\n    const resolver = this.#resolvers.get(handler);\n    this.#resolvers.delete(handler);\n    this.#rejectors.delete(handler);\n    const data = await handler.call(undefined);\n    if (!resolver) {\n      throw new Error('Unable to locate resolver');\n    }\n\n    resolver.call(undefined, data);\n  }\n\n  #scheduleWork(): void {\n    const hasScheduledWork = this.#scheduledWorkId !== 0;\n    if (hasScheduledWork) {\n      return;\n    }\n\n    this.#scheduledWorkId = requestAnimationFrame(async () => {\n      const hasPendingFrames = this.#pendingWorkFrames.length > 0;\n      if (!hasPendingFrames) {\n        // No pending frames means all pending work has completed.\n        // The events dispatched below are mostly for testing contexts.\n        // The first is for cases where we have a direct reference to\n        // the render coordinator. The second is for other test contexts\n        // where we don't, and instead we listen for an event on the window.\n        this.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n        window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n        this.#logIfEnabled('[Queue empty]');\n        this.#scheduledWorkId = 0;\n        return;\n      }\n\n      this.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n      this.#logIfEnabled('[New frame]');\n\n      const frame = this.#pendingWorkFrames.shift();\n      if (!frame) {\n        return;\n      }\n\n      // Start with all the readers and allow them\n      // to proceed together.\n      const readers: Promise<unknown>[] = [];\n      for (const reader of frame.readers) {\n        this.#logIfEnabled(this.#labels.get(reader));\n        readers.push(this.#handleWork(reader));\n      }\n\n      // Wait for them all to be done.\n      try {\n        await Promise.race([\n          Promise.all(readers),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(frame.readers, err);\n      }\n\n      // Next do all the writers as a block.\n      const writers: Promise<unknown>[] = [];\n      for (const writer of frame.writers) {\n        this.#logIfEnabled(this.#labels.get(writer));\n        writers.push(this.#handleWork(writer));\n      }\n\n      // And wait for them to be done, too.\n      try {\n        await Promise.race([\n          Promise.all(writers),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(frame.writers, err);\n      }\n\n      // Since there may have been more work requested in\n      // the callback of a reader / writer, we attempt to schedule\n      // it at this point.\n      this.#scheduledWorkId = 0;\n      this.#scheduleWork();\n    });\n  }\n\n  #rejectAll(handlers: CoordinatorCallback[], error: Error): void {\n    for (const handler of handlers) {\n      const rejector = this.#rejectors.get(handler);\n      if (!rejector) {\n        continue;\n      }\n\n      rejector.call(undefined, error);\n      this.#resolvers.delete(handler);\n      this.#rejectors.delete(handler);\n    }\n  }\n\n  #logIfEnabled(value: string|undefined): void {\n    if (!this.observe || !value) {\n      return;\n    }\n    const hasNoName = value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL);\n    if (hasNoName && this.observeOnlyNamed) {\n      return;\n    }\n\n    this.#logInternal.push({time: performance.now(), value});\n\n    // Keep the log at the log size.\n    while (this.#logInternal.length > this.recordStorageLimit) {\n      this.#logInternal.shift();\n    }\n  }\n}\n"]}