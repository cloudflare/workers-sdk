{"version":3,"file":"DataGrid.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/data_grid/DataGrid.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Host from '../../../core/host/host.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as UI from '../../legacy/legacy.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nimport dataGridStyles from './dataGrid.css.js';\nimport {BodyCellFocusedEvent, ColumnHeaderClickEvent, ContextMenuHeaderResetClickEvent} from './DataGridEvents.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nimport {addColumnVisibilityCheckboxes, addSortableColumnItems} from './DataGridContextMenuUtils.js';\nimport type {CellPosition, Column, Row, SortState} from './DataGridUtils.js';\nimport {\n  calculateColumnWidthPercentageFromWeighting,\n  calculateFirstFocusableCell,\n  getCellTitleFromCellContent,\n  getRowEntryForColumnId,\n  handleArrowKeyNavigation,\n  renderCellValue,\n  SortDirection,\n} from './DataGridUtils.js';\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nconst UIStrings = {\n  /**\n  *@description A context menu item in the Data Grid of a data grid\n  */\n  sortBy: 'Sort By',\n  /**\n  *@description A context menu item in data grids to reset the columns to their default weight\n  */\n  resetColumns: 'Reset Columns',\n  /**\n  *@description A context menu item in data grids to list header options.\n  */\n  headerOptions: 'Header Options',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/data_grid/DataGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport interface DataGridContextMenusConfiguration {\n  headerRow?: (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[]) => void;\n  bodyRow?: (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[], row: Readonly<Row>) => void;\n}\n\nexport interface DataGridData {\n  columns: Column[];\n  rows: Row[];\n  activeSort: SortState|null;\n  contextMenus?: DataGridContextMenusConfiguration;\n  label?: string;\n}\n\nconst enum UserScrollState {\n  NOT_SCROLLED = 'NOT_SCROLLED',\n  MANUAL_SCROLL_NOT_BOTTOM = 'MANUAL_SCROLL_NOT_BOTTOM',\n  SCROLLED_TO_BOTTOM = 'SCROLLED_TO_BOTTOM',\n}\n\nconst KEYS_TREATED_AS_CLICKS = new Set([' ', 'Enter']);\n\nconst ROW_HEIGHT_PIXELS = 18;\nconst PADDING_ROWS_COUNT = 10;\n\nexport class DataGrid extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-data-grid`;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #columns: readonly Column[] = [];\n  #rows: readonly Row[] = [];\n  #sortState: Readonly<SortState>|null = null;\n  #isRendering = false;\n  #userScrollState: UserScrollState = UserScrollState.NOT_SCROLLED;\n  #contextMenus?: DataGridContextMenusConfiguration = undefined;\n  #label?: string = undefined;\n  #currentResize: {\n    rightCellCol: HTMLTableColElement,\n    leftCellCol: HTMLTableColElement,\n    leftCellColInitialPercentageWidth: number,\n    rightCellColInitialPercentageWidth: number,\n    initialLeftCellWidth: number,\n    initialRightCellWidth: number,\n    initialMouseX: number,\n    documentForCursorChange: Document,\n    cursorToRestore: string,\n  }|null = null;\n  // Because we only render a subset of rows, we need a way to look up the\n  // actual row index from the original dataset. We could use this.rows[index]\n  // but that's O(n) and will slow as the dataset grows. A weakmap makes the\n  // lookup constant.\n  readonly #rowIndexMap = new WeakMap<Row, number>();\n  readonly #resizeObserver = new ResizeObserver(() => {\n    void this.#alignScrollHandlers();\n  });\n\n  // Thie have to be bound as they are put onto the global document, not onto\n  // this element, so LitHtml does not bind them for us.\n  #boundOnResizePointerMove = this.#onResizePointerMove.bind(this);\n\n  /**\n   * Following guidance from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html, we\n   * allow a single cell inside the table to be focusable, such that when a user\n   * tabs in they select that cell. IMPORTANT: if the data-grid has sortable\n   * columns, the user has to be able to navigate to the headers to toggle the\n   * sort. [0,0] is considered the first cell INCLUDING the column header\n   * Therefore if a user is on the first header cell, the position is considered [0, 0],\n   * and if a user is on the first body cell, the position is considered [0, 1].\n   *\n   * We set the selectable cell to the first tbody value by default, but then on the\n   * first render if any of the columns are sortable we'll set the active cell\n   * to [0, 0].\n   */\n  #cellToFocusIfUserTabsIn: CellPosition = [0, 1];\n  #cellUserHasFocused: CellPosition|null = null;\n\n  #hasRenderedAtLeastOnce = false;\n  #userHasFocusInDataGrid = false;\n  #scheduleRender = false;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [dataGridStyles];\n    ComponentHelpers.SetCSSProperty.set(this, '--table-row-height', `${ROW_HEIGHT_PIXELS}px`);\n  }\n\n  get data(): DataGridData {\n    return {\n      columns: this.#columns as Column[],\n      rows: this.#rows as Row[],\n      activeSort: this.#sortState,\n      contextMenus: this.#contextMenus,\n      label: this.#label,\n    };\n  }\n\n  set data(data: DataGridData) {\n    this.#columns = data.columns;\n    this.#rows = data.rows;\n    this.#rows.forEach((row, index) => {\n      this.#rowIndexMap.set(row, index);\n    });\n    this.#sortState = data.activeSort;\n    this.#contextMenus = data.contextMenus;\n    this.#label = data.label;\n\n    /**\n     * On first render, now we have data, we can figure out which cell is the\n     * focusable cell for the table.\n     *\n     * If any columns are sortable, we pick [0, 0], which is the first cell of\n     * the columns row. However, if any columns are hidden, we adjust\n     * accordingly. e.g., if the first column is hidden, we'll set the starting\n     * index as [1, 0].\n     *\n     * If the columns aren't sortable, we pick the first visible body row as the\n     * index.\n     *\n     * We only do this on the first render; otherwise if we re-render and the\n     * user has focused a cell, this logic will reset it.\n     */\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#cellToFocusIfUserTabsIn = calculateFirstFocusableCell({columns: this.#columns, rows: this.#rows});\n    }\n\n    if (this.#hasRenderedAtLeastOnce && this.#userHasCellFocused()) {\n      const [selectedColIndex, selectedRowIndex] = this.#tabbableCell();\n      const columnOutOfBounds = selectedColIndex > this.#columns.length;\n      const rowOutOfBounds = selectedRowIndex > this.#rows.length;\n\n      /** If the row or column was removed, so the user is out of bounds, we\n       * move them to the last focusable cell, which should be close to where\n       * they were. */\n      if (columnOutOfBounds || rowOutOfBounds) {\n        this.#cellUserHasFocused = [\n          columnOutOfBounds ? this.#columns.length : selectedColIndex,\n          rowOutOfBounds ? this.#rows.length : selectedRowIndex,\n        ];\n      }\n    }\n\n    void this.#render();\n  }\n\n  #shouldAutoScrollToBottom(): boolean {\n    /**\n     * If the user's last scroll took them to the bottom, then we assume they\n     * want to automatically scroll.\n     */\n    if (this.#userScrollState === UserScrollState.SCROLLED_TO_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * If the user does not have focus in the data grid (e.g. they haven't\n     * selected a cell), we automatically scroll, as long as the user hasn't\n     * manually scrolled the data-grid to somewhere that isn't the bottom.\n     */\n    if (!this.#userHasFocusInDataGrid && this.#userScrollState !== UserScrollState.MANUAL_SCROLL_NOT_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * Else, the user has focused a cell, or their last scroll action took them\n     * not to the bottom, so we assume that they don't want to be auto-scrolled.\n     */\n    return false;\n  }\n\n  #scrollToBottomIfRequired(): void {\n    if (this.#hasRenderedAtLeastOnce === false || !this.#shouldAutoScrollToBottom()) {\n      return;\n    }\n\n    void coordinator.read(() => {\n      const wrapper = this.#shadow.querySelector('.wrapping-container');\n      if (!wrapper) {\n        return;\n      }\n      const scrollHeight = wrapper.scrollHeight;\n      void coordinator.scroll(() => {\n        wrapper.scrollTo(0, scrollHeight);\n      });\n    });\n  }\n\n  #engageResizeObserver(): void {\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#resizeObserver.observe(this.#shadow.host);\n    }\n  }\n\n  #userHasCellFocused(): boolean {\n    return this.#cellUserHasFocused !== null;\n  }\n\n  #getTableElementForCellUserHasFocused(): HTMLTableCellElement|null {\n    if (!this.#cellUserHasFocused) {\n      return null;\n    }\n    const [columnIndex, rowIndex] = this.#cellUserHasFocused;\n    const cell = this.#shadow.querySelector<HTMLTableCellElement>(\n        `[data-row-index=\"${rowIndex}\"][data-col-index=\"${columnIndex}\"]`);\n    return cell;\n  }\n\n  async #focusTableCellInDOM(cell: HTMLTableCellElement): Promise<void> {\n    await coordinator.write(() => {\n      cell.focus();\n    });\n  }\n\n  #focusCellIfRequired([newColumnIndex, newRowIndex]: CellPosition): void {\n    this.#userHasFocusInDataGrid = true;\n\n    if (this.#cellUserHasFocused && this.#cellUserHasFocused[0] === newColumnIndex &&\n        this.#cellUserHasFocused[1] === newRowIndex) {\n      // The cell is already active and focused so we don't need to do anything.\n      return;\n    }\n\n    this.#cellUserHasFocused = [newColumnIndex, newRowIndex];\n    void this.#render();\n    const tableCell = this.#getTableElementForCellUserHasFocused();\n    if (!tableCell) {\n      // Return in case the cell is out of bounds and we do nothing\n      return;\n    }\n    /* The cell may already be focused if the user clicked into it, but we also\n     * add arrow key support, so in the case where we're programatically moving the\n     * focus, ensure we actually focus the cell.\n     */\n    void this.#focusTableCellInDOM(tableCell);\n  }\n\n  #onTableKeyDown(event: KeyboardEvent): void {\n    const key = event.key;\n\n    if (!this.#cellUserHasFocused) {\n      return;\n    }\n\n    if (KEYS_TREATED_AS_CLICKS.has(key)) {\n      const [focusedColumnIndex, focusedRowIndex] = this.#cellUserHasFocused;\n      const activeColumn = this.#columns[focusedColumnIndex];\n      if (focusedRowIndex === 0 && activeColumn && activeColumn.sortable) {\n        this.#onColumnHeaderClick(activeColumn, focusedColumnIndex);\n      }\n    }\n\n    if (!Platform.KeyboardUtilities.keyIsArrowKey(key)) {\n      return;\n    }\n\n    const nextFocusedCell = handleArrowKeyNavigation({\n      key: key,\n      currentFocusedCell: this.#cellUserHasFocused,\n      columns: this.#columns,\n      rows: this.#rows,\n    });\n    event.preventDefault();\n    this.#focusCellIfRequired(nextFocusedCell);\n  }\n\n  #onColumnHeaderClick(col: Column, index: number): void {\n    this.dispatchEvent(new ColumnHeaderClickEvent(col, index));\n  }\n\n  /**\n   * Applies the aria-sort label to a column's th.\n   * Guidance on values of attribute taken from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html.\n   */\n  #ariaSortForHeader(col: Column): string|undefined {\n    if (col.sortable && (!this.#sortState || this.#sortState.columnId !== col.id)) {\n      // Column is sortable but is not currently sorted\n      return 'none';\n    }\n\n    if (this.#sortState && this.#sortState.columnId === col.id) {\n      return this.#sortState.direction === SortDirection.ASC ? 'ascending' : 'descending';\n    }\n\n    // Column is not sortable, so don't apply any label\n    return undefined;\n  }\n\n  #renderEmptyFillerRow(numberOfVisibleRows: number): LitHtml.TemplateResult {\n    const emptyCells = this.#columns.map((col, colIndex) => {\n      if (!col.visible) {\n        return LitHtml.nothing;\n      }\n      const emptyCellClasses = LitHtml.Directives.classMap({\n        firstVisibleColumn: colIndex === 0,\n      });\n      return LitHtml.html`<td aria-hidden=\"true\" class=${emptyCellClasses} data-filler-row-column-index=${\n          colIndex}></td>`;\n    });\n    const emptyRowClasses = LitHtml.Directives.classMap({\n      'filler-row': true,\n      'padding-row': true,\n      'empty-table': numberOfVisibleRows === 0,\n    });\n    return LitHtml.html`<tr aria-hidden=\"true\" class=${emptyRowClasses}>${emptyCells}</tr>`;\n  }\n\n  #cleanUpAfterResizeColumnComplete(): void {\n    if (!this.#currentResize) {\n      return;\n    }\n    this.#currentResize.documentForCursorChange.body.style.cursor = this.#currentResize.cursorToRestore;\n    this.#currentResize = null;\n    // Realign the scroll handlers now the table columns have been resized.\n    void this.#alignScrollHandlers();\n  }\n\n  #onResizePointerDown(event: PointerEvent): void {\n    if (event.buttons !== 1 || (Host.Platform.isMac() && event.ctrlKey)) {\n      // Ensure we only react to a left click drag mouse down event.\n      // On Mac we ignore Ctrl-click which can be used to bring up context menus, etc.\n      return;\n    }\n    event.preventDefault();\n    const resizerElement = event.target as HTMLElement;\n    if (!resizerElement) {\n      return;\n    }\n    const leftColumnIndex = resizerElement.dataset.columnIndex;\n    if (!leftColumnIndex) {\n      return;\n    }\n    const leftColumnIndexAsNumber = globalThis.parseInt(leftColumnIndex, 10);\n    /* To find the cell to the right we can't just go +1 as it might be hidden,\n     * so find the next index that is visible.\n     */\n    const rightColumnIndexAsNumber = this.#columns.findIndex((column, index) => {\n      return index > leftColumnIndexAsNumber && column.visible === true;\n    });\n\n    const leftCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCell || !rightCell) {\n      return;\n    }\n    // We query for the <col> elements as they are the elements that we put the actual width on.\n    const leftCellCol =\n        this.#shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCellCol =\n        this.#shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCellCol || !rightCellCol) {\n      return;\n    }\n\n    const targetDocumentForCursorChange = (event.target as Node).ownerDocument;\n    if (!targetDocumentForCursorChange) {\n      return;\n    }\n    // We now store values that we'll make use of in the mousemouse event to calculate how much to resize the table by.\n    this.#currentResize = {\n      leftCellCol,\n      rightCellCol,\n      leftCellColInitialPercentageWidth: globalThis.parseInt(leftCellCol.style.width, 10),\n      rightCellColInitialPercentageWidth: globalThis.parseInt(rightCellCol.style.width, 10),\n      initialLeftCellWidth: leftCell.clientWidth,\n      initialRightCellWidth: rightCell.clientWidth,\n      initialMouseX: event.x,\n      documentForCursorChange: targetDocumentForCursorChange,\n      cursorToRestore: resizerElement.style.cursor,\n    };\n\n    targetDocumentForCursorChange.body.style.cursor = 'col-resize';\n    resizerElement.setPointerCapture(event.pointerId);\n    resizerElement.addEventListener('pointermove', this.#boundOnResizePointerMove);\n  }\n\n  #onResizePointerMove(event: PointerEvent): void {\n    event.preventDefault();\n    if (!this.#currentResize) {\n      return;\n    }\n\n    const MIN_CELL_WIDTH_PERCENTAGE = 10;\n    const MAX_CELL_WIDTH_PERCENTAGE = (this.#currentResize.leftCellColInitialPercentageWidth +\n                                       this.#currentResize.rightCellColInitialPercentageWidth) -\n        MIN_CELL_WIDTH_PERCENTAGE;\n    const deltaOfMouseMove = event.x - this.#currentResize.initialMouseX;\n    const absoluteDelta = Math.abs(deltaOfMouseMove);\n    const percentageDelta =\n        (absoluteDelta / (this.#currentResize.initialLeftCellWidth + this.#currentResize.initialRightCellWidth)) * 100;\n\n    let newLeftColumnPercentage;\n    let newRightColumnPercentage;\n    if (deltaOfMouseMove > 0) {\n      /**\n       * A positive delta means the user moved their mouse to the right, so we\n       * want to make the right column smaller, and the left column larger.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.leftCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.rightCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    } else if (deltaOfMouseMove < 0) {\n      /**\n       * Negative delta means the user moved their mouse to the left, which\n       * means we want to make the right column larger, and the left column\n       * smaller.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.leftCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.rightCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    }\n\n    if (!newLeftColumnPercentage || !newRightColumnPercentage) {\n      // The delta was 0, so nothing to do.\n      return;\n    }\n\n    // We limit the values to two decimal places to not work with huge decimals.\n    // It also prevents stuttering if the user barely moves the mouse, as the\n    // browser won't try to move the column by 0.0000001% or similar.\n    this.#currentResize.leftCellCol.style.width = newLeftColumnPercentage.toFixed(2) + '%';\n    this.#currentResize.rightCellCol.style.width = newRightColumnPercentage.toFixed(2) + '%';\n  }\n\n  #onResizePointerUp(event: PointerEvent): void {\n    event.preventDefault();\n    const resizer = event.target as HTMLElement;\n    if (!resizer) {\n      return;\n    }\n    resizer.releasePointerCapture(event.pointerId);\n    resizer.removeEventListener('pointermove', this.#boundOnResizePointerMove);\n    this.#cleanUpAfterResizeColumnComplete();\n  }\n\n  #renderResizeForCell(column: Column, position: CellPosition): LitHtml.LitTemplate {\n    /**\n     * A resizer for a column is placed at the far right of the _previous column\n     * cell_. So when we get called with [1, 0] that means this dragger is\n     * resizing column 1, but the dragger itself is located within column 0. We\n     * need the column to the left because when you resize a column you're not\n     * only resizing it but also the column to its left.\n     */\n    const [columnIndex] = position;\n    const lastVisibleColumnIndex = this.#getIndexOfLastVisibleColumn();\n    // If we are in the very last column, there is no column to the right to resize, so don't render a resizer.\n    if (columnIndex === lastVisibleColumnIndex || !column.visible) {\n      return LitHtml.nothing;\n    }\n\n    return LitHtml.html`<span class=\"cell-resize-handle\"\n     @pointerdown=${this.#onResizePointerDown}\n     @pointerup=${this.#onResizePointerUp}\n     data-column-index=${columnIndex}\n    ></span>`;\n  }\n\n  #getIndexOfLastVisibleColumn(): number {\n    let index = this.#columns.length - 1;\n    for (; index > -1; index--) {\n      const col = this.#columns[index];\n      if (col.visible) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * This function is called when the user right clicks on the header row of the\n   * data grid.\n   */\n  #onHeaderContextMenu(event: MouseEvent): void {\n    if (event.button !== 2) {\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    addColumnVisibilityCheckboxes(this, menu);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy));\n    addSortableColumnItems(this, sortMenu);\n\n    menu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    });\n\n    if (this.#contextMenus && this.#contextMenus.headerRow) {\n      // Let the user append things to the menu\n      this.#contextMenus.headerRow(menu, this.#columns);\n    }\n    void menu.show();\n  }\n\n  #onBodyRowContextMenu(event: MouseEvent): void {\n    if (event.button !== 2) {\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n    /**\n     * We now make sure that the event came from an HTML element with a\n     * data-row-index attribute, else we bail.\n     */\n    if (!event.target || !(event.target instanceof HTMLElement)) {\n      return;\n    }\n    const rowIndexAttribute = event.target.dataset.rowIndex;\n    if (!rowIndexAttribute) {\n      return;\n    }\n\n    const rowIndex = parseInt(rowIndexAttribute, 10);\n    // rowIndex - 1 here because in the UI the 0th row is the column headers.\n    const rowThatWasClicked = this.#rows[rowIndex - 1];\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy));\n    addSortableColumnItems(this, sortMenu);\n\n    const headerOptionsMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.headerOptions));\n    addColumnVisibilityCheckboxes(this, headerOptionsMenu);\n    headerOptionsMenu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    });\n\n    if (this.#contextMenus && this.#contextMenus.bodyRow) {\n      this.#contextMenus.bodyRow(menu, this.#columns, rowThatWasClicked);\n    }\n    void menu.show();\n  }\n\n  #onScroll(event: Event): void {\n    const wrapper = event.target as HTMLElement;\n    if (!wrapper) {\n      return;\n    }\n\n    // Need to Math.round because on high res screens we can end up with decimal\n    // point numbers for scroll positions.\n    const userIsAtBottom = Math.round(wrapper.scrollTop + wrapper.clientHeight) === Math.round(wrapper.scrollHeight);\n    this.#userScrollState =\n        userIsAtBottom ? UserScrollState.SCROLLED_TO_BOTTOM : UserScrollState.MANUAL_SCROLL_NOT_BOTTOM;\n\n    void this.#render();\n  }\n\n  #alignScrollHandlers(): Promise<void> {\n    return coordinator.read(() => {\n      const columnHeaders = this.#shadow.querySelectorAll<HTMLElement>('th:not(.hidden)');\n      const handlers = this.#shadow.querySelectorAll<HTMLElement>('.cell-resize-handle');\n      const table = this.#shadow.querySelector<HTMLTableElement>('table');\n      if (!table) {\n        return;\n      }\n\n      columnHeaders.forEach(async (header, index) => {\n        const columnWidth = header.clientWidth;\n        const columnLeftOffset = header.offsetLeft;\n        if (handlers[index]) {\n          const handlerWidth = handlers[index].clientWidth;\n          void coordinator.write(() => {\n            /**\n             * Render the resizer at the far right of the column; we subtract\n             * its width so it sits on the inner edge of the column.\n             */\n            handlers[index].style.left = `${columnLeftOffset + columnWidth - handlerWidth}px`;\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculates the index of the first row we want to render, and the last row we want to render.\n   * Pads in each direction by PADDING_ROWS_COUNT so we render some rows that are off scren.\n   */\n  #calculateTopAndBottomRowIndexes(): Promise<{topVisibleRow: number, bottomVisibleRow: number}> {\n    return coordinator.read(() => {\n      const wrapper = this.#shadow.querySelector('.wrapping-container');\n\n      // On first render we don't have a wrapper, so we can't get at its\n      // scroll/height values. So we default to the inner height of the window as\n      // the limit for rendering. This means we may over-render by a few rows, but\n      // better that than either render everything, or rendering too few rows.\n      let scrollTop = 0;\n      let clientHeight = window.innerHeight;\n      if (wrapper) {\n        scrollTop = wrapper.scrollTop;\n        clientHeight = wrapper.clientHeight;\n      }\n      const padding = ROW_HEIGHT_PIXELS * PADDING_ROWS_COUNT;\n      let topVisibleRow = Math.floor((scrollTop - padding) / ROW_HEIGHT_PIXELS);\n      let bottomVisibleRow = Math.ceil((scrollTop + clientHeight + padding) / ROW_HEIGHT_PIXELS);\n\n      topVisibleRow = Math.max(0, topVisibleRow);\n      bottomVisibleRow = Math.min(this.#rows.filter(r => !r.hidden).length, bottomVisibleRow);\n\n      return {\n        topVisibleRow,\n        bottomVisibleRow,\n      };\n    });\n  }\n\n  #onFocusOut(): void {\n    /**\n     * When any element in the data-grid loses focus, we set this to false. If\n     * the user then focuses another cell, that code will set the focus to true.\n     * We need to know if the user is focused because if they are and they've\n     * scrolled their focused cell out of rendering view and back in, we want to\n     * refocus it. But if they aren't focused and that happens, we don't, else\n     * we can steal focus away from the user if they are typing into an input\n     * box to filter the data-grid, for example.\n     */\n    this.#userHasFocusInDataGrid = false;\n  }\n\n  #tabbableCell(): CellPosition {\n    /**\n     * If the user has selected a cell, this is the cell that should be\n     * \"tabbable\" if the user tabs out and into the data-grid. If the user\n     * hasn't selected a cell, we fallback to the default cell that we set as\n     * tabbable when we render.\n     */\n    return this.#cellUserHasFocused || this.#cellToFocusIfUserTabsIn;\n  }\n\n  /**\n   * Renders the data-grid table. Note that we do not render all rows; the\n   * performance cost are too high once you have a large enough table. Instead\n   * we calculate the size of the container we are rendering into, and then\n   * render only the rows required to fill that table (plus a bit extra for\n   * padding).\n   */\n  async #render(): Promise<void> {\n    if (this.#isRendering) {\n      // If we receive a request to render during a previous render call, we block\n      // the newly requested render (since we could receive a lot of them in quick\n      // succession), but we do ensure that at the end of the current render we\n      // go again with the latest data.\n      this.#scheduleRender = true;\n      return;\n    }\n    this.#isRendering = true;\n\n    const {topVisibleRow, bottomVisibleRow} = await this.#calculateTopAndBottomRowIndexes();\n    const nonHiddenRows = this.#rows.filter(row => !row.hidden);\n    const renderableRows = nonHiddenRows.filter((_, idx) => idx >= topVisibleRow && idx <= bottomVisibleRow);\n    const indexOfFirstVisibleColumn = this.#columns.findIndex(col => col.visible);\n    const anyColumnsSortable = this.#columns.some(col => col.sortable === true);\n\n    await coordinator.write(() => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      LitHtml.render(LitHtml.html`\n      ${this.#columns.map((col, columnIndex) => {\n        /**\n        * We render the resizers outside of the table. One is rendered for each\n        * column, and they are positioned absolutely at the right position. They\n        * have 100% height so they sit over the entire table and can be grabbed\n        * by the user.\n        */\n        return this.#renderResizeForCell(col, [columnIndex, 0]);\n      })}\n      <div class=\"wrapping-container\" @scroll=${this.#onScroll} @focusout=${this.#onFocusOut}>\n        <table\n          aria-label=${LitHtml.Directives.ifDefined(this.#label)}\n          aria-rowcount=${this.#rows.length}\n          aria-colcount=${this.#columns.length}\n          @keydown=${this.#onTableKeyDown}\n        >\n          <colgroup>\n            ${this.#columns.map((col, colIndex) => {\n              const width = calculateColumnWidthPercentageFromWeighting(this.#columns, col.id);\n              const style = `width: ${width}%`;\n              if (!col.visible) {\n                return LitHtml.nothing;\n              }\n              return LitHtml.html`<col style=${style} data-col-column-index=${colIndex}>`;\n            })}\n          </colgroup>\n          <thead>\n            <tr @contextmenu=${this.#onHeaderContextMenu}>\n              ${this.#columns.map((col, columnIndex) => {\n                const thClasses = LitHtml.Directives.classMap({\n                  hidden: !col.visible,\n                  firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                });\n                const tabbableCell = this.#tabbableCell();\n                const cellIsFocusableCell = anyColumnsSortable && columnIndex === tabbableCell[0] && tabbableCell[1] === 0;\n\n                return LitHtml.html`<th class=${thClasses}\n                  style=${LitHtml.Directives.ifDefined(col.styles ? LitHtml.Directives.styleMap(col.styles) : undefined)}\n                  data-grid-header-cell=${col.id}\n                  @focus=${(): void => {\n                    this.#focusCellIfRequired([columnIndex, 0]);\n                  }}\n                  @click=${(): void => {\n                    /**\n                     * We use click here rather than focus because if you've\n                     * clicked on the header to sort, you've also focused it. If\n                     * you then click it again to change the sorting, this\n                     * doesn't emit a focus event as the cell is already\n                     * focused.\n                     */\n                    this.#onColumnHeaderClick(col, columnIndex);\n                  }}\n                  title=${col.title}\n                  aria-sort=${LitHtml.Directives.ifDefined(this.#ariaSortForHeader(col))}\n                  aria-colindex=${columnIndex + 1}\n                  data-row-index='0'\n                  data-col-index=${columnIndex}\n                  tabindex=${LitHtml.Directives.ifDefined(anyColumnsSortable ? (cellIsFocusableCell ? '0' : '-1') : undefined)}\n                >${col.titleElement || col.title}</th>`;\n              })}\n            </tr>\n          </thead>\n          <tbody>\n            <tr class=\"filler-row-top padding-row\" style=${LitHtml.Directives.styleMap({\n              height: `${topVisibleRow * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n            ${LitHtml.Directives.repeat(renderableRows, row => this.#rowIndexMap.get(row), (row): LitHtml.TemplateResult => {\n              const rowIndex = this.#rowIndexMap.get(row);\n              if (rowIndex === undefined) {\n                throw new Error('Trying to render a row that has no index in the rowIndexMap');\n              }\n              const tabbableCell = this.#tabbableCell();\n              // Remember that row 0 is considered the header row, so the first tbody row is row 1.\n              const tableRowIndex = rowIndex + 1;\n\n              // Check for cellUserHasFocused instead of tabbableCell so that we\n              // don't highlight the active cell before they've even clicked it.\n              const rowIsSelected = this.#cellUserHasFocused ? tableRowIndex === this.#cellUserHasFocused[1] : false;\n\n              const rowClasses = LitHtml.Directives.classMap({\n                selected: rowIsSelected,\n                hidden: row.hidden === true,\n              });\n              return LitHtml.html`\n                <tr\n                  aria-rowindex=${rowIndex + 1}\n                  class=${rowClasses}\n                  style=${LitHtml.Directives.ifDefined(row.styles ? LitHtml.Directives.styleMap(row.styles) : undefined)}\n                  @contextmenu=${this.#onBodyRowContextMenu}\n                >${this.#columns.map((col, columnIndex) => {\n                  const cell = getRowEntryForColumnId(row, col.id);\n                  const cellClasses = LitHtml.Directives.classMap({\n                    hidden: !col.visible,\n                    firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                  });\n                  const cellIsFocusableCell = columnIndex === tabbableCell[0] && tableRowIndex === tabbableCell[1];\n                  const cellOutput = col.visible ? renderCellValue(cell) : null;\n                  return LitHtml.html`<td\n                    class=${cellClasses}\n                    style=${LitHtml.Directives.ifDefined(col.styles ? LitHtml.Directives.styleMap(col.styles) : undefined)}\n                    tabindex=${cellIsFocusableCell ? '0' : '-1'}\n                    aria-colindex=${columnIndex + 1}\n                    title=${cell.title || getCellTitleFromCellContent(String(cell.value))}\n                    data-row-index=${tableRowIndex}\n                    data-col-index=${columnIndex}\n                    data-grid-value-cell-for-column=${col.id}\n                    @focus=${(): void => {\n                      this.#focusCellIfRequired([columnIndex, tableRowIndex]);\n                      this.dispatchEvent(new BodyCellFocusedEvent(cell, row));\n                    }}\n                  >${cellOutput}</td>`;\n                })}\n              `;\n            })}\n            ${this.#renderEmptyFillerRow(renderableRows.length)}\n            <tr class=\"filler-row-bottom padding-row\" style=${LitHtml.Directives.styleMap({\n              height: `${Math.max(0, nonHiddenRows.length - bottomVisibleRow) * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n          </tbody>\n        </table>\n      </div>\n      `, this.#shadow, {\n        host: this,\n      });\n    });\n    // clang-format on\n\n    // This ensures if the user has a cell focused, but then scrolls so that\n    // the focused cell is now not rendered, that when it then gets scrolled\n    // back in, that it becomes rendered.\n    // However, if the cell is a column header, we don't do this, as that\n    // can never be not-rendered.\n    const tabbableCell = this.#tabbableCell();\n    const currentlyFocusedRowIndex = tabbableCell[1];\n    const tabbableCellElement = this.#getTableElementForCellUserHasFocused();\n    if (this.#userHasFocusInDataGrid && currentlyFocusedRowIndex > 0 && tabbableCellElement) {\n      void this.#focusTableCellInDOM(tabbableCellElement);\n    }\n    this.#scrollToBottomIfRequired();\n    this.#engageResizeObserver();\n    if (this.#hasRenderedAtLeastOnce) {\n      // We may have had a cell's width change on a re-render, or it may have\n      // been hidden entirely, so we need to ensure that the resize handlers are\n      // re-positioned correctly if so.\n\n      // We don't have to do this on first render as it will fire when the resize observer is engaged.\n      void this.#alignScrollHandlers();\n    }\n\n    this.#isRendering = false;\n    this.#hasRenderedAtLeastOnce = true;\n\n    // If we've received more data mid-render we will do one extra render at\n    // the end with the most recent data.\n    if (this.#scheduleRender) {\n      this.#scheduleRender = false;\n      void this.#render();\n    }\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-data-grid', DataGrid);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-data-grid': DataGrid;\n  }\n}\n"]}