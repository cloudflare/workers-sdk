{"version":3,"file":"WasmDisassembly.js","sourceRoot":"","sources":["../../../../../../front_end/core/common/WasmDisassembly.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,QAAQ,MAAM,yBAAyB,CAAC;AAWpD,MAAM,OAAO,eAAe;IACjB,QAAQ,CAAW;IAC5B,oBAAoB,CAAuB;IAE3C,YAAY,OAAiB,EAAE,mBAAyC;QACtE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,oBAAoB,GAAG,mBAAmB,CAAC;IAClD,CAAC;IAED,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;IAC9B,CAAC;IAED,0BAA0B,CAAC,cAAsB;QAC/C,OAAO,QAAQ,CAAC,cAAc,CAAC,UAAU,CAC9B,IAAI,CAAC,QAAQ,EAAE,cAAc,EAAE,QAAQ,CAAC,cAAc,CAAC,kBAAkB,CAAC;YACjF,CAAC,CAAC;IACR,CAAC;IAED,0BAA0B,CAAC,UAAkB;QAC3C,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IACnC,CAAC;IAED;;OAEG;IACH,CAAE,uBAAuB;QACvB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,OAAO,UAAU,GAAG,IAAI,CAAC,WAAW,EAAE;YACpC,IAAI,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,EAAE;gBACpD,MAAM,MAAM,GAAG,IAAI,CAAC,0BAA0B,CAAC,UAAU,CAAC,CAAC;gBAC3D,IAAI,MAAM,IAAI,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,CAAC,KAAK,EAAE;oBAC5D,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBACjG,SAAS;iBACV;aACF;YACD,MAAM,UAAU,EAAE,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../platform/platform.js';\n\n/**\n * Metadata to map between bytecode #offsets and line numbers in the\n * disassembly for WebAssembly modules.\n */\n\ninterface FunctionBodyOffset {\n  start: number;\n  end: number;\n}\nexport class WasmDisassembly {\n  readonly #offsets: number[];\n  #functionBodyOffsets: FunctionBodyOffset[];\n\n  constructor(offsets: number[], functionBodyOffsets: FunctionBodyOffset[]) {\n    this.#offsets = offsets;\n    this.#functionBodyOffsets = functionBodyOffsets;\n  }\n\n  get lineNumbers(): number {\n    return this.#offsets.length;\n  }\n\n  bytecodeOffsetToLineNumber(bytecodeOffset: number): number {\n    return Platform.ArrayUtilities.upperBound(\n               this.#offsets, bytecodeOffset, Platform.ArrayUtilities.DEFAULT_COMPARATOR) -\n        1;\n  }\n\n  lineNumberToBytecodeOffset(lineNumber: number): number {\n    return this.#offsets[lineNumber];\n  }\n\n  /**\n   * returns an iterable enumerating all the non-breakable line numbers in the disassembly\n   */\n  * nonBreakableLineNumbers(): Iterable<number> {\n    let lineNumber = 0;\n    let functionIndex = 0;\n    while (lineNumber < this.lineNumbers) {\n      if (functionIndex < this.#functionBodyOffsets.length) {\n        const offset = this.lineNumberToBytecodeOffset(lineNumber);\n        if (offset >= this.#functionBodyOffsets[functionIndex].start) {\n          lineNumber = this.bytecodeOffsetToLineNumber(this.#functionBodyOffsets[functionIndex++].end) + 1;\n          continue;\n        }\n      }\n      yield lineNumber++;\n    }\n  }\n}\n"]}