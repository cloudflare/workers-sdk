{"version":3,"file":"AcornTokenizer.js","sourceRoot":"","sources":["../../../../../../front_end/entrypoints/formatter_worker/AcornTokenizer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nexport type TokenOrComment = Acorn.Token|Acorn.Comment;\n\n/**\n * The tokenizer in Acorn does not allow you to peek into the next token.\n * We use the peekToken method to determine when to stop formatting a\n * particular block of code.\n *\n * To remedy the situation, we implement the peeking of tokens ourselves.\n * To do so, whenever we call `nextToken`, we already retrieve the token\n * after it (in `bufferedToken`), so that `_peekToken` can check if there\n * is more work to do.\n *\n * There are 2 catches:\n *\n * 1. in the constructor we need to start the initialize the buffered token,\n *    such that `peekToken` on the first call is able to retrieve it. However,\n * 2. comments and tokens can arrive intermixed from the tokenizer. This usually\n *    happens when comments are the first comments of a file. In the scenario that\n *    the first comment in a file is a line comment attached to a token, we first\n *    receive the token and after that we receive the comment. However, when tokenizing\n *    we should reverse the order and return the comment, before the token.\n *\n * All that is to say that the `bufferedToken` is only used for *true* tokens.\n * We mimic comments to be tokens to fix the reordering issue, but we store these\n * separately to keep track of them. Any call to `nextTokenInternal` will figure\n * out whether the next token should be the preceding comment or not.\n */\nexport class AcornTokenizer {\n  readonly #content: string;\n  readonly #comments: Acorn.Comment[];\n  #tokenizer: {\n    getToken(): Acorn.Token,\n    [Symbol.iterator](): Iterator<Acorn.Token>,\n  };\n  #textCursor: TextUtils.TextCursor.TextCursor;\n  #tokenLineStartInternal: number;\n  #tokenLineEndInternal: number;\n  #tokenColumnStartInternal: number;\n  #bufferedToken?: TokenOrComment;\n\n  constructor(content: string) {\n    this.#content = content;\n    this.#comments = [];\n    this.#tokenizer =\n        Acorn.tokenizer(this.#content, {onComment: this.#comments, ecmaVersion: ECMA_VERSION, allowHashBang: true});\n    const contentLineEndings = Platform.StringUtilities.findLineEndingIndexes(this.#content);\n    this.#textCursor = new TextUtils.TextCursor.TextCursor(contentLineEndings);\n    this.#tokenLineStartInternal = 0;\n    this.#tokenLineEndInternal = 0;\n    this.#tokenColumnStartInternal = 0;\n    // If the first \"token\" should be a comment, we don't want to shift\n    // the comment from the array (which happens in `nextTokenInternal`).\n    // Therefore, we should bail out from retrieving the token if this\n    // is the case.\n    //\n    // However, sometimes we have leading comments that are attached to tokens\n    // themselves. In that case, we first retrieve the actual token, before\n    // we see the comment itself. In that case, we should proceed and\n    // initialize `bufferedToken` as normal, to allow us to fix the reordering.\n    if (this.#comments.length === 0) {\n      this.#nextTokenInternal();\n    }\n  }\n\n  static punctuator(token: Acorn.Token, values?: string): boolean {\n    return token.type !== Acorn.tokTypes.num && token.type !== Acorn.tokTypes.regexp &&\n        token.type !== Acorn.tokTypes.string && token.type !== Acorn.tokTypes.name && !token.type.keyword &&\n        (!values || (token.type.label.length === 1 && values.indexOf(token.type.label) !== -1));\n  }\n\n  static keyword(token: Acorn.Token, keyword?: string): boolean {\n    return Boolean(token.type.keyword) && token.type !== Acorn.tokTypes['_true'] &&\n        token.type !== Acorn.tokTypes['_false'] && token.type !== Acorn.tokTypes['_null'] &&\n        (!keyword || token.type.keyword === keyword);\n  }\n\n  static identifier(token: TokenOrComment, identifier?: string): boolean {\n    return token.type === Acorn.tokTypes.name && (!identifier || token.value === identifier);\n  }\n\n  static lineComment(token: TokenOrComment): boolean {\n    return token.type === 'Line';\n  }\n\n  static blockComment(token: TokenOrComment): boolean {\n    return token.type === 'Block';\n  }\n\n  #nextTokenInternal(): TokenOrComment|undefined {\n    if (this.#comments.length) {\n      const nextComment = this.#comments.shift();\n      // If this was the last comment to process, we need to make\n      // sure to update our `bufferedToken` to become the actual\n      // token. This only happens when we are processing the very\n      // first comment of a file (usually a hashbang comment)\n      // in which case we don't have to fix the reordering of tokens.\n      if (!this.#bufferedToken && this.#comments.length === 0) {\n        this.#bufferedToken = this.#tokenizer.getToken();\n      }\n      return nextComment;\n    }\n    const token = this.#bufferedToken;\n    this.#bufferedToken = this.#tokenizer.getToken();\n    return token;\n  }\n\n  nextToken(): TokenOrComment|null {\n    const token = this.#nextTokenInternal();\n    if (!token || token.type === Acorn.tokTypes.eof) {\n      return null;\n    }\n\n    this.#textCursor.advance(token.start);\n    this.#tokenLineStartInternal = this.#textCursor.lineNumber();\n    this.#tokenColumnStartInternal = this.#textCursor.columnNumber();\n\n    this.#textCursor.advance(token.end);\n    this.#tokenLineEndInternal = this.#textCursor.lineNumber();\n    return token;\n  }\n\n  peekToken(): TokenOrComment|null {\n    if (this.#comments.length) {\n      return this.#comments[0];\n    }\n    if (!this.#bufferedToken) {\n      return null;\n    }\n    return this.#bufferedToken.type !== Acorn.tokTypes.eof ? this.#bufferedToken : null;\n  }\n\n  tokenLineStart(): number {\n    return this.#tokenLineStartInternal;\n  }\n\n  tokenLineEnd(): number {\n    return this.#tokenLineEndInternal;\n  }\n\n  tokenColumnStart(): number {\n    return this.#tokenColumnStartInternal;\n  }\n}\n\nexport const ECMA_VERSION = 2022;\n"]}