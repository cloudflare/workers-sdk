// @ts-ignore
import AssetWorker from "@cloudflare/workers-shared/dist/asset-worker.mjs";

export default class CustomAssetWorker extends AssetWorker {
	async fetch(request: Request): Promise<Response> {
		const response = await super.fetch!(request);
		const modifiedResponse = new Response(response.body, response);
		modifiedResponse.headers.delete("ETag");
		modifiedResponse.headers.delete("Cache-Control");

		return modifiedResponse;
	}
	async unstable_getByETag(
		eTag: string,
		request: Request
	): Promise<{ readableStream: ReadableStream; contentType: string }> {
		const url = new URL(request.url);
		url.pathname = eTag;
		const pathRequest = new Request(url, request);
		console.log(`AssetWorker: getByEtag(${pathRequest.url})`);
		const response = await fetchAsset(pathRequest);

		const readableStream = response.body;
		if (!readableStream) {
			throw new Error(`Unexpected error. No content found for ${eTag}.`);
		}

		const contentType = response.headers.get("Content-Type");
		if (!contentType) {
			throw new Error(
				`Unexpected error. Content type is missing from the for ${eTag}`
			);
		}

		return { readableStream, contentType };
	}
	async unstable_exists(
		pathname: string,
		request: Request
	): Promise<string | null> {
		try {
			const url = new URL(request.url);
			url.pathname = pathname;
			const pathRequest = new Request(url, request);
			console.log(`AssetWorker: exists(${pathRequest.url}) PRE`);
			const response = await fetchAsset(pathRequest);
			const exists = response.status === 200;
			console.log(
				`AssetWorker: exists(${pathRequest.url}) POST`,
				response.statusText,
				response.status,
				pathname,
				response.headers.get("content-type")
			);
			return exists ? pathname : null;
		} catch (e) {
			console.log("AssetWorker: error");
			console.log(e);
			return null;
		}
	}

	async unstable_canFetch(request: Request) {
		// the 'sec-fetch-mode: navigate' header is stripped by something on its way into this worker
		// so we restore it from 'x-mf-sec-fetch-mode'
		const secFetchMode = request.headers.get("X-Mf-Sec-Fetch-Mode");
		if (secFetchMode) {
			request.headers.set("Sec-Fetch-Mode", secFetchMode);
		}
		return await super.unstable_canFetch(request);
	}
}

function fetchAsset(request: Request) {
	try {
		const headers = new Headers(request.headers);
		headers.set("__CF_REQUEST_TYPE_", "ASSET");
		const newRequest = new Request(request, { headers });
		return fetch(newRequest);
	} catch (error) {
		throw new Error(`Unexpected error. Failed to fetch asset: ${request.url}`);
	}
}
