import { execSync } from "node:child_process";
import { mkdtempSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";

/**
 * # Compatibility Flags Resolution
 *
 * This script generates TypeScript files that are used by `getWorkerdFeatureFlags()`, an implementation of workerd's compatibility flag resolution logic.
 *
 * ## Overview
 *
 * The `getWorkerdFeatureFlags()` function replicates the behavior of workerd's C++ `compileCompatibilityFlags()` function from `src/workerd/io/compatibility-date.c++`. It computes which compatibility flags are enabled based on:
 *
 * 1. **Compatibility Date**: Flags are automatically enabled after their `compatEnableDate`
 * 2. **Explicit Flags**: Users can explicitly enable/disable specific flags
 * 3. **Implied Flags**: Some flags automatically enable others after a certain date (cascading)
 *
 * ## Files
 *
 * - **`src/shared/compatibility-date.ts`**: Cap'n Proto types generated by `capnp-es` (generated and committed to repo)
 * - **`src/shared/compatibility-flags-metadata.ts`**: Annotation metadata extracted from the schema (generated and committed to repo)
 * - **`src/shared/compatibility-flags.ts`**: Main implementation with `getWorkerdFeatureFlags()` function
 *
 * ## Regenerating the Files
 *
 * The generated files should be regenerated when the workerd dependency is updated. This is typically done in CI as part of the workerd update PR automation.
 *
 * ### Prerequisites
 *
 * The build script requires `capnpc` (Cap'n Proto compiler) to be installed:
 *
 * ```bash
 * # macOS
 * brew install capnp
 *
 * # Ubuntu/Debian
 * sudo apt-get install capnproto
 *
 * # Other platforms
 * # See: https://capnproto.org/install.html
 * ```
 *
 * ### Running the Build Script
 *
 * ```bash
 * cd packages/miniflare
 * pnpm run capnp:compat
 * ```
 *
 * The script will:
 *
 * 1. Create a unique temporary directory
 * 2. Download `compatibility-date.capnp` from the workerd repository
 * 3. Compile it to TypeScript using `capnp-es` (requires `capnpc`)
 * 4. Parse the schema to extract annotation metadata (enable flags, dates, implied relationships)
 * 5. Generate both output files in `src/shared/`
 * 6. Clean up the temporary directory
 *
 * ## Architecture
 *
 * ```
 * ┌─────────────────────────────────────────────────────────────────┐
 * │                    workerd repository                           │
 * │  https://github.com/cloudflare/workerd/.../compatibility-date.capnp │
 * └─────────────────────────────────────────────────────────────────┘
 *                               │
 *                               │ download (at build time)
 *                               ▼
 * ┌─────────────────────────────────────────────────────────────────┐
 * │              scripts/build-capnp-compat.mjs                     │
 * │  1. Downloads .capnp to temp directory                          │
 * │  2. Runs capnp-es to generate TypeScript types                  │
 * │  3. Parses .capnp text to extract annotation metadata           │
 * │  4. Cleans up temp directory                                    │
 * └─────────────────────────────────────────────────────────────────┘
 *                               │
 *               ┌───────────────┴───────────────┐
 *               ▼                               ▼
 * ┌─────────────────────────┐     ┌─────────────────────────────────┐
 * │ compatibility-date.ts   │     │ compatibility-flags-metadata.ts │
 * │ (capnp-es generated)    │     │ (annotation metadata)           │
 * │                         │     │                                 │
 * │ - CompatibilityFlags    │     │ - FLAG_METADATA[]               │
 * │   class with typed      │     │   - fieldName                   │
 * │   boolean getters       │     │   - enableFlag                  │
 * │                         │     │   - disableFlag                 │
 * │                         │     │   - enableDate                  │
 * │                         │     │   - impliedBy                   │
 * └─────────────────────────┘     └─────────────────────────────────┘
 *               │                               │
 *               └───────────────┬───────────────┘
 *                               ▼
 * ┌─────────────────────────────────────────────────────────────────┐
 * │                  compatibility-flags.ts                         │
 * │                                                                 │
 * │  getWorkerdFeatureFlags(date, flags) → FeatureFlagsMap          │
 * │                                                                 │
 * │  - Uses FLAG_METADATA for resolution logic                      │
 * │  - Returns typed FeatureFlagsMap (from CompatibilityFlags)      │
 * └─────────────────────────────────────────────────────────────────┘
 * ```
 */
const WORKERD_CAPNP_URL =
	"https://raw.githubusercontent.com/cloudflare/workerd/main/src/workerd/io/compatibility-date.capnp";
const GENERATED_TS_PATH = "src/shared/compatibility-date.ts";
const METADATA_PATH = "src/shared/compatibility-flags-metadata.ts";

/**
 * Downloads the compatibility-date.capnp file from the workerd repository
 * to a temporary directory.
 *
 * @param {string} tempDir - The temporary directory to download to
 * @returns {Promise<{capnpPath: string, content: string}>}
 */
async function downloadCapnpFile(tempDir) {
	console.log(`Downloading ${WORKERD_CAPNP_URL}...`);

	let response;
	try {
		response = await fetch(WORKERD_CAPNP_URL);
	} catch (/** @type {any} */ error) {
		const errorCode = error.cause?.code || error.code;
		if (
			errorCode === "ENOTFOUND" ||
			errorCode === "ENETUNREACH" ||
			errorCode === "ECONNREFUSED"
		) {
			console.error("\nNetwork error: Unable to connect to GitHub.");
			console.error("Please check your internet connection and try again.");
			console.error(`\nAttempted URL: ${WORKERD_CAPNP_URL}`);
		} else {
			console.error(`\nFailed to download: ${error.message}`);
		}
		throw error;
	}

	if (!response.ok) {
		const errorMsg = `Failed to download: ${response.status} ${response.statusText}`;
		console.error(`\n${errorMsg}`);
		console.error(`URL: ${WORKERD_CAPNP_URL}`);
		if (response.status === 404) {
			console.error(
				"The compatibility-date.capnp file may have moved in the workerd repository."
			);
		}
		throw new Error(errorMsg);
	}

	const content = await response.text();
	const capnpPath = join(tempDir, "compatibility-date.capnp");
	writeFileSync(capnpPath, content);
	console.log(`Downloaded to ${capnpPath}`);
	return { capnpPath, content };
}

/**
 * Checks if capnpc is available on the system.
 * @returns {boolean}
 */
function isCapnpcAvailable() {
	try {
		execSync("capnpc --version", { stdio: "ignore" });
		return true;
	} catch {
		return false;
	}
}

/**
 * Compiles the .capnp file to TypeScript using capnp-es.
 * This requires capnpc to be installed on the system.
 *
 * @param {string} capnpPath - Path to the .capnp file
 * @param {string} tempDir - The temporary directory where generated file will be created
 */
function compileCapnpToTypeScript(capnpPath, tempDir) {
	console.log(`Compiling ${capnpPath} with capnp-es...`);

	// Check if capnpc is available before attempting to compile
	if (!isCapnpcAvailable()) {
		console.error("\nError: capnpc (Cap'n Proto compiler) is not installed.");
		console.error(
			"The capnp-es tool requires capnpc to compile .capnp schema files.\n"
		);
		console.error("To install capnpc:");
		console.error("  macOS:        brew install capnp");
		console.error("  Ubuntu/Debian: sudo apt-get install capnproto");
		console.error("  Other:        https://capnproto.org/install.html\n");
		throw new Error("capnpc is not installed");
	}

	try {
		execSync(`npx capnp-es ${capnpPath} -ots`, { stdio: "inherit" });

		// capnp-es generates the .ts file next to the .capnp file
		const generatedInTemp = join(tempDir, "compatibility-date.ts");

		// Read the generated file and prepend our header with documentation link
		const generatedContent = readFileSync(generatedInTemp, "utf-8");
		const header = `/**
 * Auto-generated by capnp-es from compatibility-date.capnp - DO NOT EDIT MANUALLY
 *
 * This file is regenerated when the workerd dependency is updated.
 * Source: ${WORKERD_CAPNP_URL}
 *
 * @see {@link file://./../../../scripts/build-capnp-compat.mjs} for documentation
 */

`;
		writeFileSync(GENERATED_TS_PATH, header + generatedContent);
		console.log(`Generated ${GENERATED_TS_PATH}`);
	} catch (error) {
		console.error("\nFailed to compile .capnp file with capnp-es.");
		throw error;
	}
}

/**
 * @typedef {object} FlagMetadata
 * @property {string} fieldName
 * @property {number} ordinal
 * @property {string} [enableFlag]
 * @property {string} [disableFlag]
 * @property {string} [enableDate]
 * @property {boolean} [experimental]
 * @property {Array<{names: string[], date: string}>} [impliedBy]
 */

/**
 * Parses the compatibility-date.capnp file to extract flag metadata.
 * This extracts field definitions and their annotations which are not
 * included in the capnp-es generated TypeScript.
 *
 * @param {string} content - The content of the .capnp file
 * @returns {FlagMetadata[]}
 */
function parseCapnpAnnotations(content) {
	/** @type {FlagMetadata[]} */
	const flags = [];

	// Split into lines for processing
	const lines = content.split("\n");

	/** @type {FlagMetadata | null} */
	let currentField = null;
	let inCompatibilityFlags = false;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim();

		// Check if we're entering the CompatibilityFlags struct
		if (line.includes("struct CompatibilityFlags")) {
			inCompatibilityFlags = true;
			continue;
		}

		// Skip lines until we're in CompatibilityFlags
		if (!inCompatibilityFlags) continue;

		// End of struct
		if (line === "}" && currentField === null) {
			break;
		}

		// Skip annotation definitions themselves
		if (line.startsWith("annotation ")) {
			continue;
		}

		// Match field definition: fieldName @ordinal :Type
		const fieldMatch = line.match(/^(\w+)\s+@(\d+)\s+:Bool/);
		if (fieldMatch) {
			// Save previous field if exists
			if (currentField) {
				flags.push(currentField);
			}

			// Start new field
			currentField = {
				fieldName: fieldMatch[1],
				ordinal: parseInt(fieldMatch[2]),
			};
			continue;
		}

		// If we have a current field, check for annotations
		if (currentField) {
			// Match $compatEnableFlag("flag_name")
			const enableMatch = line.match(/\$compatEnableFlag\("([^"]+)"\)/);
			if (enableMatch) {
				currentField.enableFlag = enableMatch[1];
			}

			// Match $compatDisableFlag("flag_name")
			const disableMatch = line.match(/\$compatDisableFlag\("([^"]+)"\)/);
			if (disableMatch) {
				currentField.disableFlag = disableMatch[1];
			}

			// Match $compatEnableDate("YYYY-MM-DD")
			const dateMatch = line.match(/\$compatEnableDate\("([^"]+)"\)/);
			if (dateMatch) {
				currentField.enableDate = dateMatch[1];
			}

			// Match $experimental
			if (line.includes("$experimental")) {
				currentField.experimental = true;
			}

			// Match $impliedByAfterDate(name = "flag", date = "YYYY-MM-DD")
			const impliedSingleMatch = line.match(
				/\$impliedByAfterDate\(name\s*=\s*"([^"]+)"\s*,\s*date\s*=\s*"([^"]+)"\)/
			);
			if (impliedSingleMatch) {
				if (!currentField.impliedBy) {
					currentField.impliedBy = [];
				}
				currentField.impliedBy.push({
					names: [impliedSingleMatch[1]],
					date: impliedSingleMatch[2],
				});
			}

			// Match $impliedByAfterDate(names = ["flag1", "flag2"], date = "YYYY-MM-DD")
			const impliedMultiMatch = line.match(
				/\$impliedByAfterDate\(names\s*=\s*\[([^\]]+)\]\s*,\s*date\s*=\s*"([^"]+)"\)/
			);
			if (impliedMultiMatch) {
				const names = impliedMultiMatch[1]
					.split(",")
					.map((s) => s.trim().replace(/"/g, ""));
				if (!currentField.impliedBy) {
					currentField.impliedBy = [];
				}
				currentField.impliedBy.push({
					names,
					date: impliedMultiMatch[2],
				});
			}

			// If line ends with semicolon, this field is complete
			if (line.endsWith(";")) {
				flags.push(currentField);
				currentField = null;
			}
		}
	}

	// Add last field if exists
	if (currentField) {
		flags.push(currentField);
	}

	return flags;
}

/**
 * Generates the metadata TypeScript file from parsed annotations.
 *
 * @param {FlagMetadata[]} flagMetadata
 */
function generateMetadataFile(flagMetadata) {
	const tsContent = `/**
 * Auto-generated from compatibility-date.capnp - DO NOT EDIT MANUALLY
 *
 * This file is regenerated when the workerd dependency is updated.
 * Source: ${WORKERD_CAPNP_URL}
 *
 * @see {@link file://./../../../scripts/build-capnp-compat.mjs} for documentation
 */

export interface FlagMetadata {
	fieldName: string;
	ordinal: number;
	enableFlag?: string;
	disableFlag?: string;
	enableDate?: string;
	experimental?: boolean;
	impliedBy?: Array<{ names: string[]; date: string }>;
}

export const FLAG_METADATA: FlagMetadata[] = ${JSON.stringify(flagMetadata, null, "\t")};
`;

	writeFileSync(METADATA_PATH, tsContent);
	console.log(`Generated ${METADATA_PATH} with ${flagMetadata.length} flags`);
}

// Main execution
async function main() {
	// Create a unique temporary directory for the .capnp file
	const tempDir = mkdtempSync(join(tmpdir(), "capnp-compat-"));
	console.log(`Using temporary directory: ${tempDir}`);

	try {
		// Step 1: Download the .capnp file from workerd to temp directory
		const { capnpPath, content: capnpContent } =
			await downloadCapnpFile(tempDir);

		// Step 2: Compile to TypeScript using capnp-es (requires capnpc)
		compileCapnpToTypeScript(capnpPath, tempDir);

		// Step 3: Parse annotations from the .capnp file
		const flagMetadata = parseCapnpAnnotations(capnpContent);
		console.log(`Parsed ${flagMetadata.length} compatibility flags`);

		// Step 4: Generate the metadata file
		generateMetadataFile(flagMetadata);

		console.log("\nSuccessfully generated compatibility flags files:");
		console.log(`  - ${GENERATED_TS_PATH} (capnp-es generated types)`);
		console.log(`  - ${METADATA_PATH} (annotation metadata)`);
	} catch (/** @type {any} */ error) {
		console.error("Error:", error.message);
		process.exit(1);
	} finally {
		// Clean up the temporary directory
		rmSync(tempDir, { recursive: true, force: true });
		console.log(`Cleaned up temporary directory: ${tempDir}`);
	}
}

main();
