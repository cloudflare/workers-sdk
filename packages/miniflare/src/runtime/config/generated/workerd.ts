// This file has been automatically generated by capnp-es.
import * as $ from "capnp-es";

export const _capnpFileId = 0xe6afd26682091c01n;
/**
 * Top-level configuration for a workerd instance.
 *
 */
export class Config extends $.Struct {
	static readonly _capnp = {
		displayName: "Config",
		id: "8794486c76aaa7d6",
		size: new $.ObjectSize(8, 6),
		defaultStructuredLogging: $.getBitMask(false, 0),
	};
	static _Services: $.ListCtor<Service>;
	static _Sockets: $.ListCtor<Socket>;
	static _Extensions: $.ListCtor<Extension>;
	_adoptServices(value: $.Orphan<$.List<Service>>): void {
		$.utils.adopt(value, $.utils.getPointer(0, this));
	}
	_disownServices(): $.Orphan<$.List<Service>> {
		return $.utils.disown(this.services);
	}
	/**
	 * List of named services defined by this server. These names are private; they are only used
	 * to refer to the services from elsewhere in this config file, as well as for logging and the
	 * like. Services are not reachable until you configure some way to make them reachable, such
	 * as via a Socket.
	 *
	 * If you do not define any service called "internet", one is defined implicitly, representing
	 * the ability to access public internet servers. An explicit definition would look like:
	 *
	 *     ( name = "internet",
	 *       network = (
	 *         allow = ["public"],   # Allows connections to publicly-routable addresses only.
	 *         tlsOptions = (trustBrowserCas = true)
	 *       )
	 *     )
	 *
	 * The "internet" service backs the global `fetch()` function in a Worker, unless that Worker's
	 * configuration specifies some other service using the `globalOutbound` setting.
	 *
	 */
	get services(): $.List<Service> {
		return $.utils.getList(0, Config._Services, this);
	}
	_hasServices(): boolean {
		return !$.utils.isNull($.utils.getPointer(0, this));
	}
	_initServices(length: number): $.List<Service> {
		return $.utils.initList(0, Config._Services, length, this);
	}
	set services(value: $.List<Service>) {
		$.utils.copyFrom(value, $.utils.getPointer(0, this));
	}
	_adoptSockets(value: $.Orphan<$.List<Socket>>): void {
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownSockets(): $.Orphan<$.List<Socket>> {
		return $.utils.disown(this.sockets);
	}
	/**
	 * List of sockets on which this server will listen, and the services that will be exposed
	 * through them.
	 *
	 */
	get sockets(): $.List<Socket> {
		return $.utils.getList(1, Config._Sockets, this);
	}
	_hasSockets(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initSockets(length: number): $.List<Socket> {
		return $.utils.initList(1, Config._Sockets, length, this);
	}
	set sockets(value: $.List<Socket>) {
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptV8Flags(value: $.Orphan<$.List<string>>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownV8Flags(): $.Orphan<$.List<string>> {
		return $.utils.disown(this.v8Flags);
	}
	/**
	 * List of "command-line" flags to pass to V8, like "--expose-gc". We put these in the config
	 * rather than on the actual command line because for most use cases, managing these via the
	 * config file is probably cleaner and easier than passing on the actual CLI.
	 *
	 * WARNING: Use at your own risk. V8 flags can have all sorts of wild effects including completely
	 *   breaking everything. V8 flags also generally do not come with any guarantee of stability
	 *   between V8 versions. Most users should not set any V8 flags.
	 *
	 */
	get v8Flags(): $.List<string> {
		return $.utils.getList(2, $.TextList, this);
	}
	_hasV8Flags(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initV8Flags(length: number): $.List<string> {
		return $.utils.initList(2, $.TextList, length, this);
	}
	set v8Flags(value: $.List<string>) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	_adoptExtensions(value: $.Orphan<$.List<Extension>>): void {
		$.utils.adopt(value, $.utils.getPointer(3, this));
	}
	_disownExtensions(): $.Orphan<$.List<Extension>> {
		return $.utils.disown(this.extensions);
	}
	/**
	 * Extensions provide capabilities to all workers. Extensions are usually prepared separately
	 * and are late-linked with the app using this config field.
	 *
	 */
	get extensions(): $.List<Extension> {
		return $.utils.getList(3, Config._Extensions, this);
	}
	_hasExtensions(): boolean {
		return !$.utils.isNull($.utils.getPointer(3, this));
	}
	_initExtensions(length: number): $.List<Extension> {
		return $.utils.initList(3, Config._Extensions, length, this);
	}
	set extensions(value: $.List<Extension>) {
		$.utils.copyFrom(value, $.utils.getPointer(3, this));
	}
	_adoptAutogates(value: $.Orphan<$.List<string>>): void {
		$.utils.adopt(value, $.utils.getPointer(4, this));
	}
	_disownAutogates(): $.Orphan<$.List<string>> {
		return $.utils.disown(this.autogates);
	}
	/**
	 * A list of gates which are enabled.
	 * These are used to gate features/changes in workerd and in our internal repo. See the equivalent
	 * config definition in our internal repo for more details.
	 *
	 */
	get autogates(): $.List<string> {
		return $.utils.getList(4, $.TextList, this);
	}
	_hasAutogates(): boolean {
		return !$.utils.isNull($.utils.getPointer(4, this));
	}
	_initAutogates(length: number): $.List<string> {
		return $.utils.initList(4, $.TextList, length, this);
	}
	set autogates(value: $.List<string>) {
		$.utils.copyFrom(value, $.utils.getPointer(4, this));
	}
	/**
	 * If true, logs will be emitted as JSON for structured logging.
	 * When false, logs use the traditional human-readable format.
	 * This affects the format of logs from KJ_LOG and exception reporting as well as js logs.
	 * This won't work for logs coming from service worker syntax workers with the old module registry.
	 * Note: This field is obsolete and deprecated. Use the logging struct instead.
	 *
	 */
	get structuredLogging(): boolean {
		return $.utils.getBit(0, this, Config._capnp.defaultStructuredLogging);
	}
	set structuredLogging(value: boolean) {
		$.utils.setBit(0, value, this, Config._capnp.defaultStructuredLogging);
	}
	_adoptLogging(value: $.Orphan<LoggingOptions>): void {
		$.utils.adopt(value, $.utils.getPointer(5, this));
	}
	_disownLogging(): $.Orphan<LoggingOptions> {
		return $.utils.disown(this.logging);
	}
	/**
	 * Console and Stdio logging configuration options.
	 *
	 */
	get logging(): LoggingOptions {
		return $.utils.getStruct(5, LoggingOptions, this);
	}
	_hasLogging(): boolean {
		return !$.utils.isNull($.utils.getPointer(5, this));
	}
	_initLogging(): LoggingOptions {
		return $.utils.initStructAt(5, LoggingOptions, this);
	}
	set logging(value: LoggingOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(5, this));
	}
	toString(): string {
		return "Config_" + super.toString();
	}
}
export class LoggingOptions extends $.Struct {
	static readonly _capnp = {
		displayName: "LoggingOptions",
		id: "c62297899c35d548",
		size: new $.ObjectSize(8, 2),
		defaultStructuredLogging: $.getBitMask(false, 0),
	};
	/**
	 * Override of top-level structured logging (only when true).
	 * If true, logs will be emitted as JSON for structured logging.
	 * When false, logs use the traditional human-readable format.
	 * This affects the format of logs from KJ_LOG and exception reporting as well as js logs.
	 * This won't work for logs coming from service worker syntax workers with the old module registry.
	 *
	 */
	get structuredLogging(): boolean {
		return $.utils.getBit(
			0,
			this,
			LoggingOptions._capnp.defaultStructuredLogging
		);
	}
	set structuredLogging(value: boolean) {
		$.utils.setBit(
			0,
			value,
			this,
			LoggingOptions._capnp.defaultStructuredLogging
		);
	}
	/**
	 * Set a custom prefix for process.stdout. Defaults to "stdout: ".
	 *
	 */
	get stdoutPrefix(): string {
		return $.utils.getText(0, this);
	}
	set stdoutPrefix(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * Set a custom prefix for process.stderr. Defaults to "stderr: ".
	 *
	 */
	get stderrPrefix(): string {
		return $.utils.getText(1, this);
	}
	set stderrPrefix(value: string) {
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return "LoggingOptions_" + super.toString();
	}
}
export class Socket_Https extends $.Struct {
	static readonly _capnp = {
		displayName: "https",
		id: "de123876383cbbdc",
		size: new $.ObjectSize(8, 5),
	};
	_adoptOptions(value: $.Orphan<HttpOptions>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownOptions(): $.Orphan<HttpOptions> {
		return $.utils.disown(this.options);
	}
	get options(): HttpOptions {
		return $.utils.getStruct(2, HttpOptions, this);
	}
	_hasOptions(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initOptions(): HttpOptions {
		return $.utils.initStructAt(2, HttpOptions, this);
	}
	set options(value: HttpOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	_adoptTlsOptions(value: $.Orphan<TlsOptions>): void {
		$.utils.adopt(value, $.utils.getPointer(3, this));
	}
	_disownTlsOptions(): $.Orphan<TlsOptions> {
		return $.utils.disown(this.tlsOptions);
	}
	get tlsOptions(): TlsOptions {
		return $.utils.getStruct(3, TlsOptions, this);
	}
	_hasTlsOptions(): boolean {
		return !$.utils.isNull($.utils.getPointer(3, this));
	}
	_initTlsOptions(): TlsOptions {
		return $.utils.initStructAt(3, TlsOptions, this);
	}
	set tlsOptions(value: TlsOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(3, this));
	}
	toString(): string {
		return "Socket_Https_" + super.toString();
	}
}
export const Socket_Which = {
	/**
	 * Each socket has a unique name which can be used on the command line to override the socket's
	 * address with `--socket-addr <name>=<addr>` or `--socket-fd <name>=<fd>`.
	 *
	 */
	HTTP: 0,
	/**
	 * Address/port on which this socket will listen. Optional; if not specified, then you will be
	 * required to specify the socket on the command line with with `--socket-addr <name>=<addr>` or
	 * `--socket-fd <name>=<fd>`.
	 *
	 * Examples:
	 * - "*:80": Listen on port 80 on all local IPv4 and IPv6 interfaces.
	 * - "1.2.3.4": Listen on the specific IPv4 address on the default port for the protocol.
	 * - "1.2.3.4:80": Listen on the specific IPv4 address and port.
	 * - "1234:5678::abcd": Listen on the specific IPv6 address on the default port for the protocol.
	 * - "[1234:5678::abcd]:80": Listen on the specific IPv6 address and port.
	 * - "unix:/path/to/socket": Listen on a Unix socket.
	 * - "unix-abstract:name": On Linux, listen on the given "abstract" Unix socket name.
	 * - "example.com:80": Perform a DNS lookup to determine the address, and then listen on it. If
	 *     this resolves to multiple addresses, listen on all of them.
	 *
	 * (These are the formats supported by KJ's parseAddress().)
	 *
	 */
	HTTPS: 1,
} as const;
export type Socket_Which = (typeof Socket_Which)[keyof typeof Socket_Which];
export class Socket extends $.Struct {
	static readonly HTTP = Socket_Which.HTTP;
	static readonly HTTPS = Socket_Which.HTTPS;
	static readonly _capnp = {
		displayName: "Socket",
		id: "9a0eba45530ee79f",
		size: new $.ObjectSize(8, 5),
	};
	/**
	 * Each socket has a unique name which can be used on the command line to override the socket's
	 * address with `--socket-addr <name>=<addr>` or `--socket-fd <name>=<fd>`.
	 *
	 */
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * Address/port on which this socket will listen. Optional; if not specified, then you will be
	 * required to specify the socket on the command line with with `--socket-addr <name>=<addr>` or
	 * `--socket-fd <name>=<fd>`.
	 *
	 * Examples:
	 * - "*:80": Listen on port 80 on all local IPv4 and IPv6 interfaces.
	 * - "1.2.3.4": Listen on the specific IPv4 address on the default port for the protocol.
	 * - "1.2.3.4:80": Listen on the specific IPv4 address and port.
	 * - "1234:5678::abcd": Listen on the specific IPv6 address on the default port for the protocol.
	 * - "[1234:5678::abcd]:80": Listen on the specific IPv6 address and port.
	 * - "unix:/path/to/socket": Listen on a Unix socket.
	 * - "unix-abstract:name": On Linux, listen on the given "abstract" Unix socket name.
	 * - "example.com:80": Perform a DNS lookup to determine the address, and then listen on it. If
	 *     this resolves to multiple addresses, listen on all of them.
	 *
	 * (These are the formats supported by KJ's parseAddress().)
	 *
	 */
	get address(): string {
		return $.utils.getText(1, this);
	}
	set address(value: string) {
		$.utils.setText(1, value, this);
	}
	_adoptHttp(value: $.Orphan<HttpOptions>): void {
		$.utils.setUint16(0, 0, this);
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownHttp(): $.Orphan<HttpOptions> {
		return $.utils.disown(this.http);
	}
	get http(): HttpOptions {
		$.utils.testWhich("http", $.utils.getUint16(0, this), 0, this);
		return $.utils.getStruct(2, HttpOptions, this);
	}
	_hasHttp(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initHttp(): HttpOptions {
		$.utils.setUint16(0, 0, this);
		return $.utils.initStructAt(2, HttpOptions, this);
	}
	get _isHttp(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set http(value: HttpOptions) {
		$.utils.setUint16(0, 0, this);
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	get https(): Socket_Https {
		$.utils.testWhich("https", $.utils.getUint16(0, this), 1, this);
		return $.utils.getAs(Socket_Https, this);
	}
	_initHttps(): Socket_Https {
		$.utils.setUint16(0, 1, this);
		return $.utils.getAs(Socket_Https, this);
	}
	get _isHttps(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set https(_: true) {
		$.utils.setUint16(0, 1, this);
	}
	_adoptService(value: $.Orphan<ServiceDesignator>): void {
		$.utils.adopt(value, $.utils.getPointer(4, this));
	}
	_disownService(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.service);
	}
	/**
	 * Service name which should handle requests on this socket.
	 *
	 */
	get service(): ServiceDesignator {
		return $.utils.getStruct(4, ServiceDesignator, this);
	}
	_hasService(): boolean {
		return !$.utils.isNull($.utils.getPointer(4, this));
	}
	_initService(): ServiceDesignator {
		return $.utils.initStructAt(4, ServiceDesignator, this);
	}
	set service(value: ServiceDesignator) {
		$.utils.copyFrom(value, $.utils.getPointer(4, this));
	}
	toString(): string {
		return "Socket_" + super.toString();
	}
	which(): Socket_Which {
		return $.utils.getUint16(0, this) as Socket_Which;
	}
}
export const Service_Which = {
	/**
	 * Name of the service. Used only to refer to the service from elsewhere in the config file.
	 * Services are not accessible unless you explicitly configure them to be, such as through a
	 * `Socket` or through a binding from another Worker.
	 *
	 */
	UNSPECIFIED: 0,
	/**
	 * (This catches when someone forgets to specify one of the union members. Do not set this.)
	 *
	 */
	WORKER: 1,
	/**
	 * A Worker!
	 *
	 */
	NETWORK: 2,
	/**
	 * A service that implements access to a network. fetch() requests are routed according to
	 * the URL hostname.
	 *
	 */
	EXTERNAL: 3,
	/**
	 * A service that forwards all requests to a specific remote server. Typically used to
	 * connect to a back-end server on your internal network.
	 *
	 */
	DISK: 4,
} as const;
export type Service_Which = (typeof Service_Which)[keyof typeof Service_Which];
/**
 * Defines a named service. Each server has a list of named services. The names are private,
 * used to refer to the services within this same config file.
 *
 */
export class Service extends $.Struct {
	static readonly UNSPECIFIED = Service_Which.UNSPECIFIED;
	static readonly WORKER = Service_Which.WORKER;
	static readonly NETWORK = Service_Which.NETWORK;
	static readonly EXTERNAL = Service_Which.EXTERNAL;
	static readonly DISK = Service_Which.DISK;
	static readonly _capnp = {
		displayName: "Service",
		id: "e5c88e8bb7bcb6b9",
		size: new $.ObjectSize(8, 2),
	};
	/**
	 * Name of the service. Used only to refer to the service from elsewhere in the config file.
	 * Services are not accessible unless you explicitly configure them to be, such as through a
	 * `Socket` or through a binding from another Worker.
	 *
	 */
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	get _isUnspecified(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set unspecified(_: true) {
		$.utils.setUint16(0, 0, this);
	}
	_adoptWorker(value: $.Orphan<Worker>): void {
		$.utils.setUint16(0, 1, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownWorker(): $.Orphan<Worker> {
		return $.utils.disown(this.worker);
	}
	/**
	 * A Worker!
	 *
	 */
	get worker(): Worker {
		$.utils.testWhich("worker", $.utils.getUint16(0, this), 1, this);
		return $.utils.getStruct(1, Worker, this);
	}
	_hasWorker(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initWorker(): Worker {
		$.utils.setUint16(0, 1, this);
		return $.utils.initStructAt(1, Worker, this);
	}
	get _isWorker(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set worker(value: Worker) {
		$.utils.setUint16(0, 1, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptNetwork(value: $.Orphan<Network>): void {
		$.utils.setUint16(0, 2, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownNetwork(): $.Orphan<Network> {
		return $.utils.disown(this.network);
	}
	/**
	 * A service that implements access to a network. fetch() requests are routed according to
	 * the URL hostname.
	 *
	 */
	get network(): Network {
		$.utils.testWhich("network", $.utils.getUint16(0, this), 2, this);
		return $.utils.getStruct(1, Network, this);
	}
	_hasNetwork(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initNetwork(): Network {
		$.utils.setUint16(0, 2, this);
		return $.utils.initStructAt(1, Network, this);
	}
	get _isNetwork(): boolean {
		return $.utils.getUint16(0, this) === 2;
	}
	set network(value: Network) {
		$.utils.setUint16(0, 2, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptExternal(value: $.Orphan<ExternalServer>): void {
		$.utils.setUint16(0, 3, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownExternal(): $.Orphan<ExternalServer> {
		return $.utils.disown(this.external);
	}
	/**
	 * A service that forwards all requests to a specific remote server. Typically used to
	 * connect to a back-end server on your internal network.
	 *
	 */
	get external(): ExternalServer {
		$.utils.testWhich("external", $.utils.getUint16(0, this), 3, this);
		return $.utils.getStruct(1, ExternalServer, this);
	}
	_hasExternal(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initExternal(): ExternalServer {
		$.utils.setUint16(0, 3, this);
		return $.utils.initStructAt(1, ExternalServer, this);
	}
	get _isExternal(): boolean {
		return $.utils.getUint16(0, this) === 3;
	}
	set external(value: ExternalServer) {
		$.utils.setUint16(0, 3, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptDisk(value: $.Orphan<DiskDirectory>): void {
		$.utils.setUint16(0, 4, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownDisk(): $.Orphan<DiskDirectory> {
		return $.utils.disown(this.disk);
	}
	/**
	 * An HTTP service backed by a directory on disk, supporting a basic HTTP GET/PUT. Generally
	 * not intended to be exposed directly to the internet; typically you want to bind this into
	 * a Worker that adds logic for setting Content-Type and the like.
	 *
	 */
	get disk(): DiskDirectory {
		$.utils.testWhich("disk", $.utils.getUint16(0, this), 4, this);
		return $.utils.getStruct(1, DiskDirectory, this);
	}
	_hasDisk(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initDisk(): DiskDirectory {
		$.utils.setUint16(0, 4, this);
		return $.utils.initStructAt(1, DiskDirectory, this);
	}
	get _isDisk(): boolean {
		return $.utils.getUint16(0, this) === 4;
	}
	set disk(value: DiskDirectory) {
		$.utils.setUint16(0, 4, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	toString(): string {
		return "Service_" + super.toString();
	}
	which(): Service_Which {
		return $.utils.getUint16(0, this) as Service_Which;
	}
}
export const ServiceDesignator_Props_Which = {
	/**
	 * Empty object. (This is the default.)
	 *
	 */
	EMPTY: 0,
	/**
	 * A JSON-encoded value.
	 *
	 */
	JSON: 1,
} as const;
export type ServiceDesignator_Props_Which =
	(typeof ServiceDesignator_Props_Which)[keyof typeof ServiceDesignator_Props_Which];
/**
 * Value to provide in `ctx.props` in the target worker.
 *
 */
export class ServiceDesignator_Props extends $.Struct {
	static readonly EMPTY = ServiceDesignator_Props_Which.EMPTY;
	static readonly JSON = ServiceDesignator_Props_Which.JSON;
	static readonly _capnp = {
		displayName: "props",
		id: "f0dc90173b494522",
		size: new $.ObjectSize(8, 3),
	};
	get _isEmpty(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set empty(_: true) {
		$.utils.setUint16(0, 0, this);
	}
	/**
	 * A JSON-encoded value.
	 *
	 */
	get json(): string {
		$.utils.testWhich("json", $.utils.getUint16(0, this), 1, this);
		return $.utils.getText(2, this);
	}
	get _isJson(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set json(value: string) {
		$.utils.setUint16(0, 1, this);
		$.utils.setText(2, value, this);
	}
	toString(): string {
		return "ServiceDesignator_Props_" + super.toString();
	}
	which(): ServiceDesignator_Props_Which {
		return $.utils.getUint16(0, this) as ServiceDesignator_Props_Which;
	}
}
/**
 * A reference to a service from elsewhere in the config file, e.g. from a service binding in a
 * Worker.
 *
 * In the case that only `name` needs to be specified, then you can provide a raw string wherever
 * `ServiceDesignator` is needed. Cap'n proto automatically assumes the string is intended to be
 * the value for `name`, since that is the first field. In other words, if you would otherwise
 * write something like:
 *
 *     bindings = [(service = (name = "foo"))]
 *
 * You can write this instead, which is equivalent:
 *
 *     bindings = [(service = "foo")]
 *
 */
export class ServiceDesignator extends $.Struct {
	static readonly _capnp = {
		displayName: "ServiceDesignator",
		id: "ae8ec91cee724450",
		size: new $.ObjectSize(8, 3),
	};
	/**
	 * Name of the service in the Config.services list.
	 *
	 */
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * A modules-syntax Worker can export multiple named entrypoints. `export default {` specifies
	 * the default entrypoint, whereas `export let foo = {` defines an entrypoint named `foo`. If
	 * `entrypoint` is specified here, it names an alternate entrypoint to use on the target worker,
	 * otherwise the default is used.
	 *
	 */
	get entrypoint(): string {
		return $.utils.getText(1, this);
	}
	set entrypoint(value: string) {
		$.utils.setText(1, value, this);
	}
	/**
	 * Value to provide in `ctx.props` in the target worker.
	 *
	 */
	get props(): ServiceDesignator_Props {
		return $.utils.getAs(ServiceDesignator_Props, this);
	}
	_initProps(): ServiceDesignator_Props {
		return $.utils.getAs(ServiceDesignator_Props, this);
	}
	toString(): string {
		return "ServiceDesignator_" + super.toString();
	}
}
export const Worker_Module_Which = {
	/**
	 * Name (or path) used to import the module.
	 *
	 */
	ES_MODULE: 0,
	/**
	 * An ES module file with imports and exports.
	 *
	 * As with `serviceWorkerScript`, above, the value is the raw source code.
	 *
	 */
	COMMON_JS_MODULE: 1,
	/**
	 * A common JS module, using require().
	 *
	 */
	TEXT: 2,
	/**
	 * A raw text blob. Importing this will produce a string with the value.
	 *
	 */
	DATA: 3,
	/**
	 * A raw data blob. Importing this will produce an ArrayBuffer with the value.
	 *
	 */
	WASM: 4,
	/**
	 * A Wasm module. The value is a compiled binary Wasm module file. Importing this will produce
	 * a `WebAssembly.Module` object, which you can then instantiate.
	 *
	 */
	JSON: 5,
	/**
	 * Importing this will produce the result of parsing the given text as JSON.
	 *
	 */
	OBSOLETE: 6,
	/**
	 * This position used to be the nodeJsCompatModule type that has now been
	 * obsoleted.
	 *
	 */
	PYTHON_MODULE: 7,
	/**
	 * A Python module. All bundles containing this value type are converted into a JS/WASM Worker
	 * Bundle prior to execution.
	 *
	 */
	PYTHON_REQUIREMENT: 8,
} as const;
export type Worker_Module_Which =
	(typeof Worker_Module_Which)[keyof typeof Worker_Module_Which];
export class Worker_Module extends $.Struct {
	static readonly ES_MODULE = Worker_Module_Which.ES_MODULE;
	static readonly COMMON_JS_MODULE = Worker_Module_Which.COMMON_JS_MODULE;
	static readonly TEXT = Worker_Module_Which.TEXT;
	static readonly DATA = Worker_Module_Which.DATA;
	static readonly WASM = Worker_Module_Which.WASM;
	static readonly JSON = Worker_Module_Which.JSON;
	static readonly OBSOLETE = Worker_Module_Which.OBSOLETE;
	static readonly PYTHON_MODULE = Worker_Module_Which.PYTHON_MODULE;
	static readonly PYTHON_REQUIREMENT = Worker_Module_Which.PYTHON_REQUIREMENT;
	static readonly _capnp = {
		displayName: "Module",
		id: "d9d87a63770a12f3",
		size: new $.ObjectSize(8, 3),
	};
	/**
	 * Name (or path) used to import the module.
	 *
	 */
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * An ES module file with imports and exports.
	 *
	 * As with `serviceWorkerScript`, above, the value is the raw source code.
	 *
	 */
	get esModule(): string {
		$.utils.testWhich("esModule", $.utils.getUint16(0, this), 0, this);
		return $.utils.getText(1, this);
	}
	get _isEsModule(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set esModule(value: string) {
		$.utils.setUint16(0, 0, this);
		$.utils.setText(1, value, this);
	}
	/**
	 * A common JS module, using require().
	 *
	 */
	get commonJsModule(): string {
		$.utils.testWhich("commonJsModule", $.utils.getUint16(0, this), 1, this);
		return $.utils.getText(1, this);
	}
	get _isCommonJsModule(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set commonJsModule(value: string) {
		$.utils.setUint16(0, 1, this);
		$.utils.setText(1, value, this);
	}
	/**
	 * A raw text blob. Importing this will produce a string with the value.
	 *
	 */
	get text(): string {
		$.utils.testWhich("text", $.utils.getUint16(0, this), 2, this);
		return $.utils.getText(1, this);
	}
	get _isText(): boolean {
		return $.utils.getUint16(0, this) === 2;
	}
	set text(value: string) {
		$.utils.setUint16(0, 2, this);
		$.utils.setText(1, value, this);
	}
	_adoptData(value: $.Orphan<$.Data>): void {
		$.utils.setUint16(0, 3, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownData(): $.Orphan<$.Data> {
		return $.utils.disown(this.data);
	}
	/**
	 * A raw data blob. Importing this will produce an ArrayBuffer with the value.
	 *
	 */
	get data(): $.Data {
		$.utils.testWhich("data", $.utils.getUint16(0, this), 3, this);
		return $.utils.getData(1, this);
	}
	_hasData(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initData(length: number): $.Data {
		$.utils.setUint16(0, 3, this);
		return $.utils.initData(1, length, this);
	}
	get _isData(): boolean {
		return $.utils.getUint16(0, this) === 3;
	}
	set data(value: $.Data) {
		$.utils.setUint16(0, 3, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptWasm(value: $.Orphan<$.Data>): void {
		$.utils.setUint16(0, 4, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownWasm(): $.Orphan<$.Data> {
		return $.utils.disown(this.wasm);
	}
	/**
	 * A Wasm module. The value is a compiled binary Wasm module file. Importing this will produce
	 * a `WebAssembly.Module` object, which you can then instantiate.
	 *
	 */
	get wasm(): $.Data {
		$.utils.testWhich("wasm", $.utils.getUint16(0, this), 4, this);
		return $.utils.getData(1, this);
	}
	_hasWasm(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initWasm(length: number): $.Data {
		$.utils.setUint16(0, 4, this);
		return $.utils.initData(1, length, this);
	}
	get _isWasm(): boolean {
		return $.utils.getUint16(0, this) === 4;
	}
	set wasm(value: $.Data) {
		$.utils.setUint16(0, 4, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	/**
	 * Importing this will produce the result of parsing the given text as JSON.
	 *
	 */
	get json(): string {
		$.utils.testWhich("json", $.utils.getUint16(0, this), 5, this);
		return $.utils.getText(1, this);
	}
	get _isJson(): boolean {
		return $.utils.getUint16(0, this) === 5;
	}
	set json(value: string) {
		$.utils.setUint16(0, 5, this);
		$.utils.setText(1, value, this);
	}
	/**
	 * This position used to be the nodeJsCompatModule type that has now been
	 * obsoleted.
	 *
	 */
	get obsolete(): string {
		$.utils.testWhich("obsolete", $.utils.getUint16(0, this), 6, this);
		return $.utils.getText(1, this);
	}
	get _isObsolete(): boolean {
		return $.utils.getUint16(0, this) === 6;
	}
	set obsolete(value: string) {
		$.utils.setUint16(0, 6, this);
		$.utils.setText(1, value, this);
	}
	/**
	 * A Python module. All bundles containing this value type are converted into a JS/WASM Worker
	 * Bundle prior to execution.
	 *
	 */
	get pythonModule(): string {
		$.utils.testWhich("pythonModule", $.utils.getUint16(0, this), 7, this);
		return $.utils.getText(1, this);
	}
	get _isPythonModule(): boolean {
		return $.utils.getUint16(0, this) === 7;
	}
	set pythonModule(value: string) {
		$.utils.setUint16(0, 7, this);
		$.utils.setText(1, value, this);
	}
	/**
	 * A Python package that is required by this bundle. The package must be supported by
	 * Pyodide (https://pyodide.org/en/stable/usage/packages-in-pyodide.html). All packages listed
	 * will be installed prior to the execution of the worker.
	 *
	 * The value of this field is ignored and should always be an empty string. Only the module
	 * name matters. The field should have been declared `Void`, but it's difficult to change now.
	 *
	 */
	get pythonRequirement(): string {
		$.utils.testWhich("pythonRequirement", $.utils.getUint16(0, this), 8, this);
		return $.utils.getText(1, this);
	}
	get _isPythonRequirement(): boolean {
		return $.utils.getUint16(0, this) === 8;
	}
	set pythonRequirement(value: string) {
		$.utils.setUint16(0, 8, this);
		$.utils.setText(1, value, this);
	}
	_adoptNamedExports(value: $.Orphan<$.List<string>>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownNamedExports(): $.Orphan<$.List<string>> {
		return $.utils.disown(this.namedExports);
	}
	/**
	 * For commonJsModule modules, this is a list of named exports that the
	 * module expects to be exported once the evaluation is complete.
	 *
	 * (`commonJsModule` should have been a group containing the body and `namedExports`, but it's
	 * too late to change now.)
	 *
	 */
	get namedExports(): $.List<string> {
		return $.utils.getList(2, $.TextList, this);
	}
	_hasNamedExports(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initNamedExports(length: number): $.List<string> {
		return $.utils.initList(2, $.TextList, length, this);
	}
	set namedExports(value: $.List<string>) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	toString(): string {
		return "Worker_Module_" + super.toString();
	}
	which(): Worker_Module_Which {
		return $.utils.getUint16(0, this) as Worker_Module_Which;
	}
}
export const Worker_Binding_Type_Which = {
	/**
	 * (This catches when someone forgets to specify one of the union members. Do not set this.)
	 *
	 */
	UNSPECIFIED: 0,
	TEXT: 1,
	DATA: 2,
	JSON: 3,
	WASM: 4,
	CRYPTO_KEY: 5,
	SERVICE: 6,
	DURABLE_OBJECT_NAMESPACE: 7,
	KV_NAMESPACE: 8,
	R2BUCKET: 9,
	R2ADMIN: 10,
	QUEUE: 11,
	ANALYTICS_ENGINE: 12,
	HYPERDRIVE: 13,
	DURABLE_OBJECT_CLASS: 14,
	WORKERD_DEBUG_PORT: 15,
} as const;
export type Worker_Binding_Type_Which =
	(typeof Worker_Binding_Type_Which)[keyof typeof Worker_Binding_Type_Which];
/**
 * Specifies the type of a parameter binding.
 *
 */
export class Worker_Binding_Type extends $.Struct {
	static readonly UNSPECIFIED = Worker_Binding_Type_Which.UNSPECIFIED;
	static readonly TEXT = Worker_Binding_Type_Which.TEXT;
	static readonly DATA = Worker_Binding_Type_Which.DATA;
	static readonly JSON = Worker_Binding_Type_Which.JSON;
	static readonly WASM = Worker_Binding_Type_Which.WASM;
	static readonly CRYPTO_KEY = Worker_Binding_Type_Which.CRYPTO_KEY;
	static readonly SERVICE = Worker_Binding_Type_Which.SERVICE;
	static readonly DURABLE_OBJECT_NAMESPACE =
		Worker_Binding_Type_Which.DURABLE_OBJECT_NAMESPACE;
	static readonly KV_NAMESPACE = Worker_Binding_Type_Which.KV_NAMESPACE;
	static readonly R2BUCKET = Worker_Binding_Type_Which.R2BUCKET;
	static readonly R2ADMIN = Worker_Binding_Type_Which.R2ADMIN;
	static readonly QUEUE = Worker_Binding_Type_Which.QUEUE;
	static readonly ANALYTICS_ENGINE = Worker_Binding_Type_Which.ANALYTICS_ENGINE;
	static readonly HYPERDRIVE = Worker_Binding_Type_Which.HYPERDRIVE;
	static readonly DURABLE_OBJECT_CLASS =
		Worker_Binding_Type_Which.DURABLE_OBJECT_CLASS;
	static readonly WORKERD_DEBUG_PORT =
		Worker_Binding_Type_Which.WORKERD_DEBUG_PORT;
	static readonly _capnp = {
		displayName: "Type",
		id: "8906a1296519bf8a",
		size: new $.ObjectSize(8, 1),
	};
	get _isUnspecified(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set unspecified(_: true) {
		$.utils.setUint16(0, 0, this);
	}
	get _isText(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set text(_: true) {
		$.utils.setUint16(0, 1, this);
	}
	get _isData(): boolean {
		return $.utils.getUint16(0, this) === 2;
	}
	set data(_: true) {
		$.utils.setUint16(0, 2, this);
	}
	get _isJson(): boolean {
		return $.utils.getUint16(0, this) === 3;
	}
	set json(_: true) {
		$.utils.setUint16(0, 3, this);
	}
	get _isWasm(): boolean {
		return $.utils.getUint16(0, this) === 4;
	}
	set wasm(_: true) {
		$.utils.setUint16(0, 4, this);
	}
	_adoptCryptoKey(
		value: $.Orphan<$.List<Worker_Binding_CryptoKey_Usage>>
	): void {
		$.utils.setUint16(0, 5, this);
		$.utils.adopt(value, $.utils.getPointer(0, this));
	}
	_disownCryptoKey(): $.Orphan<$.List<Worker_Binding_CryptoKey_Usage>> {
		return $.utils.disown(this.cryptoKey);
	}
	get cryptoKey(): $.List<Worker_Binding_CryptoKey_Usage> {
		$.utils.testWhich("cryptoKey", $.utils.getUint16(0, this), 5, this);
		return $.utils.getList(
			0,
			$.Uint16List,
			this
		) as $.List<Worker_Binding_CryptoKey_Usage>;
	}
	_hasCryptoKey(): boolean {
		return !$.utils.isNull($.utils.getPointer(0, this));
	}
	_initCryptoKey(length: number): $.List<Worker_Binding_CryptoKey_Usage> {
		$.utils.setUint16(0, 5, this);
		return $.utils.initList(
			0,
			$.Uint16List,
			length,
			this
		) as $.List<Worker_Binding_CryptoKey_Usage>;
	}
	get _isCryptoKey(): boolean {
		return $.utils.getUint16(0, this) === 5;
	}
	set cryptoKey(value: $.List<Worker_Binding_CryptoKey_Usage>) {
		$.utils.setUint16(0, 5, this);
		$.utils.copyFrom(value, $.utils.getPointer(0, this));
	}
	get _isService(): boolean {
		return $.utils.getUint16(0, this) === 6;
	}
	set service(_: true) {
		$.utils.setUint16(0, 6, this);
	}
	get _isDurableObjectNamespace(): boolean {
		return $.utils.getUint16(0, this) === 7;
	}
	set durableObjectNamespace(_: true) {
		$.utils.setUint16(0, 7, this);
	}
	get _isKvNamespace(): boolean {
		return $.utils.getUint16(0, this) === 8;
	}
	set kvNamespace(_: true) {
		$.utils.setUint16(0, 8, this);
	}
	get _isR2Bucket(): boolean {
		return $.utils.getUint16(0, this) === 9;
	}
	set r2Bucket(_: true) {
		$.utils.setUint16(0, 9, this);
	}
	get _isR2Admin(): boolean {
		return $.utils.getUint16(0, this) === 10;
	}
	set r2Admin(_: true) {
		$.utils.setUint16(0, 10, this);
	}
	get _isQueue(): boolean {
		return $.utils.getUint16(0, this) === 11;
	}
	set queue(_: true) {
		$.utils.setUint16(0, 11, this);
	}
	get _isAnalyticsEngine(): boolean {
		return $.utils.getUint16(0, this) === 12;
	}
	set analyticsEngine(_: true) {
		$.utils.setUint16(0, 12, this);
	}
	get _isHyperdrive(): boolean {
		return $.utils.getUint16(0, this) === 13;
	}
	set hyperdrive(_: true) {
		$.utils.setUint16(0, 13, this);
	}
	get _isDurableObjectClass(): boolean {
		return $.utils.getUint16(0, this) === 14;
	}
	set durableObjectClass(_: true) {
		$.utils.setUint16(0, 14, this);
	}
	get _isWorkerdDebugPort(): boolean {
		return $.utils.getUint16(0, this) === 15;
	}
	set workerdDebugPort(_: true) {
		$.utils.setUint16(0, 15, this);
	}
	toString(): string {
		return "Worker_Binding_Type_" + super.toString();
	}
	which(): Worker_Binding_Type_Which {
		return $.utils.getUint16(0, this) as Worker_Binding_Type_Which;
	}
}
/**
 * The type of a Durable Object namespace binding.
 *
 */
export class Worker_Binding_DurableObjectNamespaceDesignator extends $.Struct {
	static readonly _capnp = {
		displayName: "DurableObjectNamespaceDesignator",
		id: "804f144ff477aac7",
		size: new $.ObjectSize(0, 2),
	};
	/**
	 * Exported class name that implements the Durable Object.
	 *
	 */
	get className(): string {
		return $.utils.getText(0, this);
	}
	set className(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * The service name of the worker that defines this class. If omitted, the current worker
	 * is assumed.
	 *
	 * Use of this field is discouraged. Instead, when accessing a different Worker's Durable
	 * Objects, specify a `service` binding to that worker, and have the worker implement an
	 * appropriate API.
	 *
	 * (This is intentionally not a ServiceDesignator because you cannot choose an alternate
	 * entrypoint here; the class name IS the entrypoint.)
	 *
	 */
	get serviceName(): string {
		return $.utils.getText(1, this);
	}
	set serviceName(value: string) {
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return (
			"Worker_Binding_DurableObjectNamespaceDesignator_" + super.toString()
		);
	}
}
export const Worker_Binding_CryptoKey_Usage = {
	ENCRYPT: 0,
	DECRYPT: 1,
	SIGN: 2,
	VERIFY: 3,
	DERIVE_KEY: 4,
	DERIVE_BITS: 5,
	WRAP_KEY: 6,
	UNWRAP_KEY: 7,
} as const;
export type Worker_Binding_CryptoKey_Usage =
	(typeof Worker_Binding_CryptoKey_Usage)[keyof typeof Worker_Binding_CryptoKey_Usage];
export const Worker_Binding_CryptoKey_Algorithm_Which = {
	/**
	 * Just a name, like `AES-GCM`.
	 *
	 */
	NAME: 0,
	/**
	 * An object, encoded here as JSON.
	 *
	 */
	JSON: 1,
} as const;
export type Worker_Binding_CryptoKey_Algorithm_Which =
	(typeof Worker_Binding_CryptoKey_Algorithm_Which)[keyof typeof Worker_Binding_CryptoKey_Algorithm_Which];
/**
 * Value for the `algorithm` parameter.
 *
 */
export class Worker_Binding_CryptoKey_Algorithm extends $.Struct {
	static readonly NAME = Worker_Binding_CryptoKey_Algorithm_Which.NAME;
	static readonly JSON = Worker_Binding_CryptoKey_Algorithm_Which.JSON;
	static readonly _capnp = {
		displayName: "algorithm",
		id: "a1a040c5e00d7021",
		size: new $.ObjectSize(8, 3),
	};
	/**
	 * Just a name, like `AES-GCM`.
	 *
	 */
	get name(): string {
		$.utils.testWhich("name", $.utils.getUint16(2, this), 0, this);
		return $.utils.getText(1, this);
	}
	get _isName(): boolean {
		return $.utils.getUint16(2, this) === 0;
	}
	set name(value: string) {
		$.utils.setUint16(2, 0, this);
		$.utils.setText(1, value, this);
	}
	/**
	 * An object, encoded here as JSON.
	 *
	 */
	get json(): string {
		$.utils.testWhich("json", $.utils.getUint16(2, this), 1, this);
		return $.utils.getText(1, this);
	}
	get _isJson(): boolean {
		return $.utils.getUint16(2, this) === 1;
	}
	set json(value: string) {
		$.utils.setUint16(2, 1, this);
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return "Worker_Binding_CryptoKey_Algorithm_" + super.toString();
	}
	which(): Worker_Binding_CryptoKey_Algorithm_Which {
		return $.utils.getUint16(
			2,
			this
		) as Worker_Binding_CryptoKey_Algorithm_Which;
	}
}
export const Worker_Binding_CryptoKey_Which = {
	RAW: 0,
	HEX: 1,
	/**
	 * Raw key material, possibly hex or base64-encoded. Use this for symmetric keys.
	 *
	 * Hint: `raw` would typically be used with Cap'n Proto's `embed` syntax to embed an
	 * external binary key file. `hex` or `base64` could do that too but can also be specified
	 * inline.
	 *
	 */
	BASE64: 2,
	/**
	 * Private key in PEM-encoded PKCS#8 format.
	 *
	 */
	PKCS8: 3,
	/**
	 * Public key in PEM-encoded SPKI format.
	 *
	 */
	SPKI: 4,
	/**
	 * Key in JSON format.
	 *
	 */
	JWK: 5,
} as const;
export type Worker_Binding_CryptoKey_Which =
	(typeof Worker_Binding_CryptoKey_Which)[keyof typeof Worker_Binding_CryptoKey_Which];
/**
 * Parameters to crypto.subtle.importKey().
 *
 */
export class Worker_Binding_CryptoKey extends $.Struct {
	static readonly RAW = Worker_Binding_CryptoKey_Which.RAW;
	static readonly HEX = Worker_Binding_CryptoKey_Which.HEX;
	static readonly BASE64 = Worker_Binding_CryptoKey_Which.BASE64;
	static readonly PKCS8 = Worker_Binding_CryptoKey_Which.PKCS8;
	static readonly SPKI = Worker_Binding_CryptoKey_Which.SPKI;
	static readonly JWK = Worker_Binding_CryptoKey_Which.JWK;
	static readonly Usage = Worker_Binding_CryptoKey_Usage;
	static readonly _capnp = {
		displayName: "CryptoKey",
		id: "b5e1bff0e57d6eb0",
		size: new $.ObjectSize(8, 3),
		defaultExtractable: $.getBitMask(false, 0),
	};
	_adoptRaw(value: $.Orphan<$.Data>): void {
		$.utils.setUint16(0, 0, this);
		$.utils.adopt(value, $.utils.getPointer(0, this));
	}
	_disownRaw(): $.Orphan<$.Data> {
		return $.utils.disown(this.raw);
	}
	get raw(): $.Data {
		$.utils.testWhich("raw", $.utils.getUint16(0, this), 0, this);
		return $.utils.getData(0, this);
	}
	_hasRaw(): boolean {
		return !$.utils.isNull($.utils.getPointer(0, this));
	}
	_initRaw(length: number): $.Data {
		$.utils.setUint16(0, 0, this);
		return $.utils.initData(0, length, this);
	}
	get _isRaw(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set raw(value: $.Data) {
		$.utils.setUint16(0, 0, this);
		$.utils.copyFrom(value, $.utils.getPointer(0, this));
	}
	get hex(): string {
		$.utils.testWhich("hex", $.utils.getUint16(0, this), 1, this);
		return $.utils.getText(0, this);
	}
	get _isHex(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set hex(value: string) {
		$.utils.setUint16(0, 1, this);
		$.utils.setText(0, value, this);
	}
	/**
	 * Raw key material, possibly hex or base64-encoded. Use this for symmetric keys.
	 *
	 * Hint: `raw` would typically be used with Cap'n Proto's `embed` syntax to embed an
	 * external binary key file. `hex` or `base64` could do that too but can also be specified
	 * inline.
	 *
	 */
	get base64(): string {
		$.utils.testWhich("base64", $.utils.getUint16(0, this), 2, this);
		return $.utils.getText(0, this);
	}
	get _isBase64(): boolean {
		return $.utils.getUint16(0, this) === 2;
	}
	set base64(value: string) {
		$.utils.setUint16(0, 2, this);
		$.utils.setText(0, value, this);
	}
	/**
	 * Private key in PEM-encoded PKCS#8 format.
	 *
	 */
	get pkcs8(): string {
		$.utils.testWhich("pkcs8", $.utils.getUint16(0, this), 3, this);
		return $.utils.getText(0, this);
	}
	get _isPkcs8(): boolean {
		return $.utils.getUint16(0, this) === 3;
	}
	set pkcs8(value: string) {
		$.utils.setUint16(0, 3, this);
		$.utils.setText(0, value, this);
	}
	/**
	 * Public key in PEM-encoded SPKI format.
	 *
	 */
	get spki(): string {
		$.utils.testWhich("spki", $.utils.getUint16(0, this), 4, this);
		return $.utils.getText(0, this);
	}
	get _isSpki(): boolean {
		return $.utils.getUint16(0, this) === 4;
	}
	set spki(value: string) {
		$.utils.setUint16(0, 4, this);
		$.utils.setText(0, value, this);
	}
	/**
	 * Key in JSON format.
	 *
	 */
	get jwk(): string {
		$.utils.testWhich("jwk", $.utils.getUint16(0, this), 5, this);
		return $.utils.getText(0, this);
	}
	get _isJwk(): boolean {
		return $.utils.getUint16(0, this) === 5;
	}
	set jwk(value: string) {
		$.utils.setUint16(0, 5, this);
		$.utils.setText(0, value, this);
	}
	/**
	 * Value for the `algorithm` parameter.
	 *
	 */
	get algorithm(): Worker_Binding_CryptoKey_Algorithm {
		return $.utils.getAs(Worker_Binding_CryptoKey_Algorithm, this);
	}
	_initAlgorithm(): Worker_Binding_CryptoKey_Algorithm {
		return $.utils.getAs(Worker_Binding_CryptoKey_Algorithm, this);
	}
	/**
	 * Is the Worker allowed to export this key to obtain the underlying key material? Setting
	 * this false ensures that the key cannot be leaked by errant JavaScript code; the key can
	 * only be used in WebCrypto operations.
	 *
	 */
	get extractable(): boolean {
		return $.utils.getBit(
			32,
			this,
			Worker_Binding_CryptoKey._capnp.defaultExtractable
		);
	}
	set extractable(value: boolean) {
		$.utils.setBit(
			32,
			value,
			this,
			Worker_Binding_CryptoKey._capnp.defaultExtractable
		);
	}
	_adoptUsages(value: $.Orphan<$.List<Worker_Binding_CryptoKey_Usage>>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownUsages(): $.Orphan<$.List<Worker_Binding_CryptoKey_Usage>> {
		return $.utils.disown(this.usages);
	}
	/**
	 * What operations is this key permitted to be used for?
	 *
	 */
	get usages(): $.List<Worker_Binding_CryptoKey_Usage> {
		return $.utils.getList(
			2,
			$.Uint16List,
			this
		) as $.List<Worker_Binding_CryptoKey_Usage>;
	}
	_hasUsages(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initUsages(length: number): $.List<Worker_Binding_CryptoKey_Usage> {
		return $.utils.initList(
			2,
			$.Uint16List,
			length,
			this
		) as $.List<Worker_Binding_CryptoKey_Usage>;
	}
	set usages(value: $.List<Worker_Binding_CryptoKey_Usage>) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	toString(): string {
		return "Worker_Binding_CryptoKey_" + super.toString();
	}
	which(): Worker_Binding_CryptoKey_Which {
		return $.utils.getUint16(0, this) as Worker_Binding_CryptoKey_Which;
	}
}
export class Worker_Binding_MemoryCacheLimits extends $.Struct {
	static readonly _capnp = {
		displayName: "MemoryCacheLimits",
		id: "8d66725b0867e634",
		size: new $.ObjectSize(16, 0),
	};
	get maxKeys(): number {
		return $.utils.getUint32(0, this);
	}
	set maxKeys(value: number) {
		$.utils.setUint32(0, value, this);
	}
	get maxValueSize(): number {
		return $.utils.getUint32(4, this);
	}
	set maxValueSize(value: number) {
		$.utils.setUint32(4, value, this);
	}
	get maxTotalValueSize(): bigint {
		return $.utils.getUint64(8, this);
	}
	set maxTotalValueSize(value: bigint) {
		$.utils.setUint64(8, value, this);
	}
	toString(): string {
		return "Worker_Binding_MemoryCacheLimits_" + super.toString();
	}
}
/**
 * A binding that wraps a group of (lower-level) bindings in a common API.
 *
 */
export class Worker_Binding_WrappedBinding extends $.Struct {
	static readonly _capnp = {
		displayName: "WrappedBinding",
		id: "e6f066b75f0ea113",
		size: new $.ObjectSize(0, 3),
		defaultEntrypoint: "default",
	};
	static _InnerBindings: $.ListCtor<Worker_Binding>;
	/**
	 * Wrapper module name.
	 * The module must be an internal one (provided by extension or registered in the c++ code).
	 * Module will be instantitated during binding initialization phase.
	 *
	 */
	get moduleName(): string {
		return $.utils.getText(0, this);
	}
	set moduleName(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * Module needs to export a function with a given name (default export gets "default" name).
	 * The function needs to accept a single `env` argument - a dictionary with inner bindings.
	 * Function will be invoked during initialization phase and its return value will be used as
	 * resulting binding value.
	 *
	 */
	get entrypoint(): string {
		return $.utils.getText(
			1,
			this,
			Worker_Binding_WrappedBinding._capnp.defaultEntrypoint
		);
	}
	set entrypoint(value: string) {
		$.utils.setText(1, value, this);
	}
	_adoptInnerBindings(value: $.Orphan<$.List<Worker_Binding>>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownInnerBindings(): $.Orphan<$.List<Worker_Binding>> {
		return $.utils.disown(this.innerBindings);
	}
	/**
	 * Inner bindings that will be created and passed in the env dictionary.
	 * These bindings shall be used to implement end-user api, and are not available to the
	 * binding consumers unless "re-exported" in wrapBindings function.
	 *
	 */
	get innerBindings(): $.List<Worker_Binding> {
		return $.utils.getList(
			2,
			Worker_Binding_WrappedBinding._InnerBindings,
			this
		);
	}
	_hasInnerBindings(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initInnerBindings(length: number): $.List<Worker_Binding> {
		return $.utils.initList(
			2,
			Worker_Binding_WrappedBinding._InnerBindings,
			length,
			this
		);
	}
	set innerBindings(value: $.List<Worker_Binding>) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	toString(): string {
		return "Worker_Binding_WrappedBinding_" + super.toString();
	}
}
/**
 * Indicates that the Worker requires a binding of the given type, but it won't be specified
 * here. Another Worker can inherit this Worker and fill in this binding.
 *
 */
export class Worker_Binding_Parameter extends $.Struct {
	static readonly _capnp = {
		displayName: "parameter",
		id: "dc57e1258d26d152",
		size: new $.ObjectSize(8, 6),
	};
	_adoptType(value: $.Orphan<Worker_Binding_Type>): void {
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownType(): $.Orphan<Worker_Binding_Type> {
		return $.utils.disown(this.type);
	}
	/**
	 * Expected type of this parameter.
	 *
	 */
	get type(): Worker_Binding_Type {
		return $.utils.getStruct(1, Worker_Binding_Type, this);
	}
	_hasType(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initType(): Worker_Binding_Type {
		return $.utils.initStructAt(1, Worker_Binding_Type, this);
	}
	set type(value: Worker_Binding_Type) {
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	/**
	 * If true, this binding is optional. Derived workers need not specify it, in which case
	 * the binding won't be present in the environment object passed to the worker.
	 *
	 * When a Worker has any non-optional parameters that haven't been filled in, then it can
	 * only be used for inheritance; it cannot be invoked directly.
	 *
	 */
	get optional(): boolean {
		return $.utils.getBit(16, this);
	}
	set optional(value: boolean) {
		$.utils.setBit(16, value, this);
	}
	toString(): string {
		return "Worker_Binding_Parameter_" + super.toString();
	}
}
/**
 * A binding for Hyperdrive. Allows workers to use Hyperdrive caching & pooling for Postgres
 * databases.
 *
 */
export class Worker_Binding_Hyperdrive extends $.Struct {
	static readonly _capnp = {
		displayName: "hyperdrive",
		id: "ad6c391cd55f3134",
		size: new $.ObjectSize(8, 6),
	};
	_adoptDesignator(value: $.Orphan<ServiceDesignator>): void {
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownDesignator(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.designator);
	}
	get designator(): ServiceDesignator {
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasDesignator(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initDesignator(): ServiceDesignator {
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	set designator(value: ServiceDesignator) {
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	get database(): string {
		return $.utils.getText(2, this);
	}
	set database(value: string) {
		$.utils.setText(2, value, this);
	}
	get user(): string {
		return $.utils.getText(3, this);
	}
	set user(value: string) {
		$.utils.setText(3, value, this);
	}
	get password(): string {
		return $.utils.getText(4, this);
	}
	set password(value: string) {
		$.utils.setText(4, value, this);
	}
	get scheme(): string {
		return $.utils.getText(5, this);
	}
	set scheme(value: string) {
		$.utils.setText(5, value, this);
	}
	toString(): string {
		return "Worker_Binding_Hyperdrive_" + super.toString();
	}
}
/**
 * A binding representing access to an in-memory cache.
 *
 */
export class Worker_Binding_MemoryCache extends $.Struct {
	static readonly _capnp = {
		displayName: "memoryCache",
		id: "aed5760c349869da",
		size: new $.ObjectSize(8, 6),
	};
	/**
	 * The identifier associated with this cache. Any number of isolates
	 * can access the same in-memory cache (within the same process), and
	 * each worker may use any number of in-memory caches.
	 *
	 */
	get id(): string {
		return $.utils.getText(1, this);
	}
	set id(value: string) {
		$.utils.setText(1, value, this);
	}
	_adoptLimits(value: $.Orphan<Worker_Binding_MemoryCacheLimits>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownLimits(): $.Orphan<Worker_Binding_MemoryCacheLimits> {
		return $.utils.disown(this.limits);
	}
	get limits(): Worker_Binding_MemoryCacheLimits {
		return $.utils.getStruct(2, Worker_Binding_MemoryCacheLimits, this);
	}
	_hasLimits(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initLimits(): Worker_Binding_MemoryCacheLimits {
		return $.utils.initStructAt(2, Worker_Binding_MemoryCacheLimits, this);
	}
	set limits(value: Worker_Binding_MemoryCacheLimits) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	toString(): string {
		return "Worker_Binding_MemoryCache_" + super.toString();
	}
}
/**
 * A binding representing the ability to dynamically load Workers from code presented at
 * runtime.
 *
 * A Worker loader is not just a function that loads a Worker, but also serves as a
 * cache of Workers, automatically unloading Workers that are not in use. To that end, each
 * Worker must have a name, and if a Worker with that name already exists, it'll be reused.
 *
 */
export class Worker_Binding_WorkerLoader extends $.Struct {
	static readonly _capnp = {
		displayName: "workerLoader",
		id: "a3de996091635c4d",
		size: new $.ObjectSize(8, 6),
	};
	/**
	 * Optional: The identifier associated with this Worker loader. Multiple Workers can bind to
	 * the same ID in order to access the same loader, so that if they request the same name
	 * from it, they'll end up sharing the same loaded Worker.
	 *
	 * (If omitted, the binding will not share a cache with any other binding.)
	 *
	 */
	get id(): string {
		return $.utils.getText(1, this);
	}
	set id(value: string) {
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return "Worker_Binding_WorkerLoader_" + super.toString();
	}
}
export const Worker_Binding_Which = {
	UNSPECIFIED: 0,
	/**
	 * (This catches when someone forgets to specify one of the union members. Do not set this.)
	 *
	 */
	PARAMETER: 1,
	/**
	 * Indicates that the Worker requires a binding of the given type, but it won't be specified
	 * here. Another Worker can inherit this Worker and fill in this binding.
	 *
	 */
	TEXT: 2,
	/**
	 * A string.
	 *
	 */
	DATA: 3,
	/**
	 * An ArrayBuffer.
	 *
	 */
	JSON: 4,
	/**
	 * A value parsed from JSON.
	 *
	 */
	WASM_MODULE: 5,
	/**
	 * A WebAssembly module. The binding will be an instance of `WebAssembly.Module`. Only
	 * supported when using Service Workers syntax.
	 *
	 * DEPRECATED: Please switch to ES modules syntax instead, and embed Wasm modules as modules.
	 *
	 */
	CRYPTO_KEY: 6,
	/**
	 * A CryptoKey instance, for use with the WebCrypto API.
	 *
	 * Note that by setting `extractable = false`, you can prevent the Worker code from accessing
	 * or leaking the raw key material; it will only be able to use the key to perform WebCrypto
	 * operations.
	 *
	 */
	SERVICE: 7,
	/**
	 * A binding representing access to an in-memory cache.
	 *
	 */
	DURABLE_OBJECT_CLASS: 19,
	/**
	 * Binding to a named service (possibly, a worker).
	 *
	 */
	DURABLE_OBJECT_NAMESPACE: 8,
	/**
	 * Binding to the durable object namespace implemented by the given class.
	 *
	 * In the common case that this refers to a class in the same Worker, you can specify just
	 * a string, like:
	 *
	 *     durableObjectNamespace = "MyClass"
	 *
	 */
	KV_NAMESPACE: 9,
	/**
	 * A KV namespace, implemented by the named service. The Worker sees a KvNamespace-typed
	 * binding. Requests to the namespace will be converted into HTTP requests targeting the
	 * given service name.
	 *
	 */
	R2BUCKET: 10,
	R2ADMIN: 11,
	/**
	 * R2 bucket and admin API bindings. Similar to KV namespaces, these turn operations into
	 * HTTP requests aimed at the named service.
	 *
	 */
	WRAPPED: 12,
	/**
	 * Wraps a collection of inner bindings in a common api functionality.
	 *
	 */
	QUEUE: 13,
	/**
	 * A Queue binding, implemented by the named service. Requests to the
	 * namespace will be converted into HTTP requests targeting the given
	 * service name.
	 *
	 */
	FROM_ENVIRONMENT: 14,
	/**
	 * Takes the value of an environment variable from the system. The value specified here is
	 * the name of a system environment variable. The value of the binding is obtained by invoking
	 * `getenv()` with that name. If the environment variable isn't set, the binding value is
	 * `null`.
	 *
	 */
	ANALYTICS_ENGINE: 15,
	/**
	 * A binding for Analytics Engine. Allows workers to store information through Analytics Engine Events.
	 * workerd will forward AnalyticsEngineEvents to designated service in the body of HTTP requests
	 * This binding is subject to change and requires the `--experimental` flag
	 *
	 */
	HYPERDRIVE: 16,
	/**
	 * A binding for Hyperdrive. Allows workers to use Hyperdrive caching & pooling for Postgres
	 * databases.
	 *
	 */
	UNSAFE_EVAL: 17,
	/**
	 * A simple binding that enables access to the UnsafeEval API.
	 *
	 */
	MEMORY_CACHE: 18,
	/**
	 * A Durable Object class binding, without an actual storage namespace. This can be used to
	 * implement a facet.
	 *
	 */
	WORKER_LOADER: 20,
	/**
	 * A binding representing the ability to dynamically load Workers from code presented at
	 * runtime.
	 *
	 * A Worker loader is not just a function that loads a Worker, but also serves as a
	 * cache of Workers, automatically unloading Workers that are not in use. To that end, each
	 * Worker must have a name, and if a Worker with that name already exists, it'll be reused.
	 *
	 */
	WORKERD_DEBUG_PORT: 21,
} as const;
export type Worker_Binding_Which =
	(typeof Worker_Binding_Which)[keyof typeof Worker_Binding_Which];
export class Worker_Binding extends $.Struct {
	static readonly UNSPECIFIED = Worker_Binding_Which.UNSPECIFIED;
	static readonly PARAMETER = Worker_Binding_Which.PARAMETER;
	static readonly TEXT = Worker_Binding_Which.TEXT;
	static readonly DATA = Worker_Binding_Which.DATA;
	static readonly JSON = Worker_Binding_Which.JSON;
	static readonly WASM_MODULE = Worker_Binding_Which.WASM_MODULE;
	static readonly CRYPTO_KEY = Worker_Binding_Which.CRYPTO_KEY;
	static readonly SERVICE = Worker_Binding_Which.SERVICE;
	static readonly DURABLE_OBJECT_CLASS =
		Worker_Binding_Which.DURABLE_OBJECT_CLASS;
	static readonly DURABLE_OBJECT_NAMESPACE =
		Worker_Binding_Which.DURABLE_OBJECT_NAMESPACE;
	static readonly KV_NAMESPACE = Worker_Binding_Which.KV_NAMESPACE;
	static readonly R2BUCKET = Worker_Binding_Which.R2BUCKET;
	static readonly R2ADMIN = Worker_Binding_Which.R2ADMIN;
	static readonly WRAPPED = Worker_Binding_Which.WRAPPED;
	static readonly QUEUE = Worker_Binding_Which.QUEUE;
	static readonly FROM_ENVIRONMENT = Worker_Binding_Which.FROM_ENVIRONMENT;
	static readonly ANALYTICS_ENGINE = Worker_Binding_Which.ANALYTICS_ENGINE;
	static readonly HYPERDRIVE = Worker_Binding_Which.HYPERDRIVE;
	static readonly UNSAFE_EVAL = Worker_Binding_Which.UNSAFE_EVAL;
	static readonly MEMORY_CACHE = Worker_Binding_Which.MEMORY_CACHE;
	static readonly WORKER_LOADER = Worker_Binding_Which.WORKER_LOADER;
	static readonly WORKERD_DEBUG_PORT = Worker_Binding_Which.WORKERD_DEBUG_PORT;
	static readonly Type = Worker_Binding_Type;
	static readonly DurableObjectNamespaceDesignator =
		Worker_Binding_DurableObjectNamespaceDesignator;
	static readonly CryptoKey = Worker_Binding_CryptoKey;
	static readonly MemoryCacheLimits = Worker_Binding_MemoryCacheLimits;
	static readonly WrappedBinding = Worker_Binding_WrappedBinding;
	static readonly _capnp = {
		displayName: "Binding",
		id: "8e7e492fd7e35f3e",
		size: new $.ObjectSize(8, 6),
	};
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	get _isUnspecified(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set unspecified(_: true) {
		$.utils.setUint16(0, 0, this);
	}
	/**
	 * Indicates that the Worker requires a binding of the given type, but it won't be specified
	 * here. Another Worker can inherit this Worker and fill in this binding.
	 *
	 */
	get parameter(): Worker_Binding_Parameter {
		$.utils.testWhich("parameter", $.utils.getUint16(0, this), 1, this);
		return $.utils.getAs(Worker_Binding_Parameter, this);
	}
	_initParameter(): Worker_Binding_Parameter {
		$.utils.setUint16(0, 1, this);
		return $.utils.getAs(Worker_Binding_Parameter, this);
	}
	get _isParameter(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set parameter(_: true) {
		$.utils.setUint16(0, 1, this);
	}
	/**
	 * A string.
	 *
	 */
	get text(): string {
		$.utils.testWhich("text", $.utils.getUint16(0, this), 2, this);
		return $.utils.getText(1, this);
	}
	get _isText(): boolean {
		return $.utils.getUint16(0, this) === 2;
	}
	set text(value: string) {
		$.utils.setUint16(0, 2, this);
		$.utils.setText(1, value, this);
	}
	_adoptData(value: $.Orphan<$.Data>): void {
		$.utils.setUint16(0, 3, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownData(): $.Orphan<$.Data> {
		return $.utils.disown(this.data);
	}
	/**
	 * An ArrayBuffer.
	 *
	 */
	get data(): $.Data {
		$.utils.testWhich("data", $.utils.getUint16(0, this), 3, this);
		return $.utils.getData(1, this);
	}
	_hasData(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initData(length: number): $.Data {
		$.utils.setUint16(0, 3, this);
		return $.utils.initData(1, length, this);
	}
	get _isData(): boolean {
		return $.utils.getUint16(0, this) === 3;
	}
	set data(value: $.Data) {
		$.utils.setUint16(0, 3, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	/**
	 * A value parsed from JSON.
	 *
	 */
	get json(): string {
		$.utils.testWhich("json", $.utils.getUint16(0, this), 4, this);
		return $.utils.getText(1, this);
	}
	get _isJson(): boolean {
		return $.utils.getUint16(0, this) === 4;
	}
	set json(value: string) {
		$.utils.setUint16(0, 4, this);
		$.utils.setText(1, value, this);
	}
	_adoptWasmModule(value: $.Orphan<$.Data>): void {
		$.utils.setUint16(0, 5, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownWasmModule(): $.Orphan<$.Data> {
		return $.utils.disown(this.wasmModule);
	}
	/**
	 * A WebAssembly module. The binding will be an instance of `WebAssembly.Module`. Only
	 * supported when using Service Workers syntax.
	 *
	 * DEPRECATED: Please switch to ES modules syntax instead, and embed Wasm modules as modules.
	 *
	 */
	get wasmModule(): $.Data {
		$.utils.testWhich("wasmModule", $.utils.getUint16(0, this), 5, this);
		return $.utils.getData(1, this);
	}
	_hasWasmModule(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initWasmModule(length: number): $.Data {
		$.utils.setUint16(0, 5, this);
		return $.utils.initData(1, length, this);
	}
	get _isWasmModule(): boolean {
		return $.utils.getUint16(0, this) === 5;
	}
	set wasmModule(value: $.Data) {
		$.utils.setUint16(0, 5, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptCryptoKey(value: $.Orphan<Worker_Binding_CryptoKey>): void {
		$.utils.setUint16(0, 6, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownCryptoKey(): $.Orphan<Worker_Binding_CryptoKey> {
		return $.utils.disown(this.cryptoKey);
	}
	/**
	 * A CryptoKey instance, for use with the WebCrypto API.
	 *
	 * Note that by setting `extractable = false`, you can prevent the Worker code from accessing
	 * or leaking the raw key material; it will only be able to use the key to perform WebCrypto
	 * operations.
	 *
	 */
	get cryptoKey(): Worker_Binding_CryptoKey {
		$.utils.testWhich("cryptoKey", $.utils.getUint16(0, this), 6, this);
		return $.utils.getStruct(1, Worker_Binding_CryptoKey, this);
	}
	_hasCryptoKey(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initCryptoKey(): Worker_Binding_CryptoKey {
		$.utils.setUint16(0, 6, this);
		return $.utils.initStructAt(1, Worker_Binding_CryptoKey, this);
	}
	get _isCryptoKey(): boolean {
		return $.utils.getUint16(0, this) === 6;
	}
	set cryptoKey(value: Worker_Binding_CryptoKey) {
		$.utils.setUint16(0, 6, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptService(value: $.Orphan<ServiceDesignator>): void {
		$.utils.setUint16(0, 7, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownService(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.service);
	}
	/**
	 * Binding to a named service (possibly, a worker).
	 *
	 */
	get service(): ServiceDesignator {
		$.utils.testWhich("service", $.utils.getUint16(0, this), 7, this);
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasService(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initService(): ServiceDesignator {
		$.utils.setUint16(0, 7, this);
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	get _isService(): boolean {
		return $.utils.getUint16(0, this) === 7;
	}
	set service(value: ServiceDesignator) {
		$.utils.setUint16(0, 7, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptDurableObjectClass(value: $.Orphan<ServiceDesignator>): void {
		$.utils.setUint16(0, 19, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownDurableObjectClass(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.durableObjectClass);
	}
	/**
	 * A Durable Object class binding, without an actual storage namespace. This can be used to
	 * implement a facet.
	 *
	 */
	get durableObjectClass(): ServiceDesignator {
		$.utils.testWhich(
			"durableObjectClass",
			$.utils.getUint16(0, this),
			19,
			this
		);
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasDurableObjectClass(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initDurableObjectClass(): ServiceDesignator {
		$.utils.setUint16(0, 19, this);
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	get _isDurableObjectClass(): boolean {
		return $.utils.getUint16(0, this) === 19;
	}
	set durableObjectClass(value: ServiceDesignator) {
		$.utils.setUint16(0, 19, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptDurableObjectNamespace(
		value: $.Orphan<Worker_Binding_DurableObjectNamespaceDesignator>
	): void {
		$.utils.setUint16(0, 8, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownDurableObjectNamespace(): $.Orphan<Worker_Binding_DurableObjectNamespaceDesignator> {
		return $.utils.disown(this.durableObjectNamespace);
	}
	/**
	 * Binding to the durable object namespace implemented by the given class.
	 *
	 * In the common case that this refers to a class in the same Worker, you can specify just
	 * a string, like:
	 *
	 *     durableObjectNamespace = "MyClass"
	 *
	 */
	get durableObjectNamespace(): Worker_Binding_DurableObjectNamespaceDesignator {
		$.utils.testWhich(
			"durableObjectNamespace",
			$.utils.getUint16(0, this),
			8,
			this
		);
		return $.utils.getStruct(
			1,
			Worker_Binding_DurableObjectNamespaceDesignator,
			this
		);
	}
	_hasDurableObjectNamespace(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initDurableObjectNamespace(): Worker_Binding_DurableObjectNamespaceDesignator {
		$.utils.setUint16(0, 8, this);
		return $.utils.initStructAt(
			1,
			Worker_Binding_DurableObjectNamespaceDesignator,
			this
		);
	}
	get _isDurableObjectNamespace(): boolean {
		return $.utils.getUint16(0, this) === 8;
	}
	set durableObjectNamespace(
		value: Worker_Binding_DurableObjectNamespaceDesignator
	) {
		$.utils.setUint16(0, 8, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptKvNamespace(value: $.Orphan<ServiceDesignator>): void {
		$.utils.setUint16(0, 9, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownKvNamespace(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.kvNamespace);
	}
	/**
	 * A KV namespace, implemented by the named service. The Worker sees a KvNamespace-typed
	 * binding. Requests to the namespace will be converted into HTTP requests targeting the
	 * given service name.
	 *
	 */
	get kvNamespace(): ServiceDesignator {
		$.utils.testWhich("kvNamespace", $.utils.getUint16(0, this), 9, this);
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasKvNamespace(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initKvNamespace(): ServiceDesignator {
		$.utils.setUint16(0, 9, this);
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	get _isKvNamespace(): boolean {
		return $.utils.getUint16(0, this) === 9;
	}
	set kvNamespace(value: ServiceDesignator) {
		$.utils.setUint16(0, 9, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptR2Bucket(value: $.Orphan<ServiceDesignator>): void {
		$.utils.setUint16(0, 10, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownR2Bucket(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.r2Bucket);
	}
	get r2Bucket(): ServiceDesignator {
		$.utils.testWhich("r2Bucket", $.utils.getUint16(0, this), 10, this);
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasR2Bucket(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initR2Bucket(): ServiceDesignator {
		$.utils.setUint16(0, 10, this);
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	get _isR2Bucket(): boolean {
		return $.utils.getUint16(0, this) === 10;
	}
	set r2Bucket(value: ServiceDesignator) {
		$.utils.setUint16(0, 10, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptR2Admin(value: $.Orphan<ServiceDesignator>): void {
		$.utils.setUint16(0, 11, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownR2Admin(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.r2Admin);
	}
	/**
	 * R2 bucket and admin API bindings. Similar to KV namespaces, these turn operations into
	 * HTTP requests aimed at the named service.
	 *
	 */
	get r2Admin(): ServiceDesignator {
		$.utils.testWhich("r2Admin", $.utils.getUint16(0, this), 11, this);
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasR2Admin(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initR2Admin(): ServiceDesignator {
		$.utils.setUint16(0, 11, this);
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	get _isR2Admin(): boolean {
		return $.utils.getUint16(0, this) === 11;
	}
	set r2Admin(value: ServiceDesignator) {
		$.utils.setUint16(0, 11, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptWrapped(value: $.Orphan<Worker_Binding_WrappedBinding>): void {
		$.utils.setUint16(0, 12, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownWrapped(): $.Orphan<Worker_Binding_WrappedBinding> {
		return $.utils.disown(this.wrapped);
	}
	/**
	 * Wraps a collection of inner bindings in a common api functionality.
	 *
	 */
	get wrapped(): Worker_Binding_WrappedBinding {
		$.utils.testWhich("wrapped", $.utils.getUint16(0, this), 12, this);
		return $.utils.getStruct(1, Worker_Binding_WrappedBinding, this);
	}
	_hasWrapped(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initWrapped(): Worker_Binding_WrappedBinding {
		$.utils.setUint16(0, 12, this);
		return $.utils.initStructAt(1, Worker_Binding_WrappedBinding, this);
	}
	get _isWrapped(): boolean {
		return $.utils.getUint16(0, this) === 12;
	}
	set wrapped(value: Worker_Binding_WrappedBinding) {
		$.utils.setUint16(0, 12, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptQueue(value: $.Orphan<ServiceDesignator>): void {
		$.utils.setUint16(0, 13, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownQueue(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.queue);
	}
	/**
	 * A Queue binding, implemented by the named service. Requests to the
	 * namespace will be converted into HTTP requests targeting the given
	 * service name.
	 *
	 */
	get queue(): ServiceDesignator {
		$.utils.testWhich("queue", $.utils.getUint16(0, this), 13, this);
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasQueue(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initQueue(): ServiceDesignator {
		$.utils.setUint16(0, 13, this);
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	get _isQueue(): boolean {
		return $.utils.getUint16(0, this) === 13;
	}
	set queue(value: ServiceDesignator) {
		$.utils.setUint16(0, 13, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	/**
	 * Takes the value of an environment variable from the system. The value specified here is
	 * the name of a system environment variable. The value of the binding is obtained by invoking
	 * `getenv()` with that name. If the environment variable isn't set, the binding value is
	 * `null`.
	 *
	 */
	get fromEnvironment(): string {
		$.utils.testWhich("fromEnvironment", $.utils.getUint16(0, this), 14, this);
		return $.utils.getText(1, this);
	}
	get _isFromEnvironment(): boolean {
		return $.utils.getUint16(0, this) === 14;
	}
	set fromEnvironment(value: string) {
		$.utils.setUint16(0, 14, this);
		$.utils.setText(1, value, this);
	}
	_adoptAnalyticsEngine(value: $.Orphan<ServiceDesignator>): void {
		$.utils.setUint16(0, 15, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownAnalyticsEngine(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.analyticsEngine);
	}
	/**
	 * A binding for Analytics Engine. Allows workers to store information through Analytics Engine Events.
	 * workerd will forward AnalyticsEngineEvents to designated service in the body of HTTP requests
	 * This binding is subject to change and requires the `--experimental` flag
	 *
	 */
	get analyticsEngine(): ServiceDesignator {
		$.utils.testWhich("analyticsEngine", $.utils.getUint16(0, this), 15, this);
		return $.utils.getStruct(1, ServiceDesignator, this);
	}
	_hasAnalyticsEngine(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initAnalyticsEngine(): ServiceDesignator {
		$.utils.setUint16(0, 15, this);
		return $.utils.initStructAt(1, ServiceDesignator, this);
	}
	get _isAnalyticsEngine(): boolean {
		return $.utils.getUint16(0, this) === 15;
	}
	set analyticsEngine(value: ServiceDesignator) {
		$.utils.setUint16(0, 15, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	/**
	 * A binding for Hyperdrive. Allows workers to use Hyperdrive caching & pooling for Postgres
	 * databases.
	 *
	 */
	get hyperdrive(): Worker_Binding_Hyperdrive {
		$.utils.testWhich("hyperdrive", $.utils.getUint16(0, this), 16, this);
		return $.utils.getAs(Worker_Binding_Hyperdrive, this);
	}
	_initHyperdrive(): Worker_Binding_Hyperdrive {
		$.utils.setUint16(0, 16, this);
		return $.utils.getAs(Worker_Binding_Hyperdrive, this);
	}
	get _isHyperdrive(): boolean {
		return $.utils.getUint16(0, this) === 16;
	}
	set hyperdrive(_: true) {
		$.utils.setUint16(0, 16, this);
	}
	get _isUnsafeEval(): boolean {
		return $.utils.getUint16(0, this) === 17;
	}
	set unsafeEval(_: true) {
		$.utils.setUint16(0, 17, this);
	}
	/**
	 * A binding representing access to an in-memory cache.
	 *
	 */
	get memoryCache(): Worker_Binding_MemoryCache {
		$.utils.testWhich("memoryCache", $.utils.getUint16(0, this), 18, this);
		return $.utils.getAs(Worker_Binding_MemoryCache, this);
	}
	_initMemoryCache(): Worker_Binding_MemoryCache {
		$.utils.setUint16(0, 18, this);
		return $.utils.getAs(Worker_Binding_MemoryCache, this);
	}
	get _isMemoryCache(): boolean {
		return $.utils.getUint16(0, this) === 18;
	}
	set memoryCache(_: true) {
		$.utils.setUint16(0, 18, this);
	}
	/**
	 * A binding representing the ability to dynamically load Workers from code presented at
	 * runtime.
	 *
	 * A Worker loader is not just a function that loads a Worker, but also serves as a
	 * cache of Workers, automatically unloading Workers that are not in use. To that end, each
	 * Worker must have a name, and if a Worker with that name already exists, it'll be reused.
	 *
	 */
	get workerLoader(): Worker_Binding_WorkerLoader {
		$.utils.testWhich("workerLoader", $.utils.getUint16(0, this), 20, this);
		return $.utils.getAs(Worker_Binding_WorkerLoader, this);
	}
	_initWorkerLoader(): Worker_Binding_WorkerLoader {
		$.utils.setUint16(0, 20, this);
		return $.utils.getAs(Worker_Binding_WorkerLoader, this);
	}
	get _isWorkerLoader(): boolean {
		return $.utils.getUint16(0, this) === 20;
	}
	set workerLoader(_: true) {
		$.utils.setUint16(0, 20, this);
	}
	get _isWorkerdDebugPort(): boolean {
		return $.utils.getUint16(0, this) === 21;
	}
	set workerdDebugPort(_: true) {
		$.utils.setUint16(0, 21, this);
	}
	toString(): string {
		return "Worker_Binding_" + super.toString();
	}
	which(): Worker_Binding_Which {
		return $.utils.getUint16(0, this) as Worker_Binding_Which;
	}
}
export class Worker_DurableObjectNamespace_ContainerOptions extends $.Struct {
	static readonly _capnp = {
		displayName: "ContainerOptions",
		id: "a609621a4d236cd7",
		size: new $.ObjectSize(0, 1),
	};
	/**
	 * Image name to be used to create the container using supported provider.
	 * By default, we pull the "latest" tag of this image.
	 *
	 */
	get imageName(): string {
		return $.utils.getText(0, this);
	}
	set imageName(value: string) {
		$.utils.setText(0, value, this);
	}
	toString(): string {
		return "Worker_DurableObjectNamespace_ContainerOptions_" + super.toString();
	}
}
export const Worker_DurableObjectNamespace_Which = {
	/**
	 * Exported class name that implements the Durable Object.
	 *
	 * Changing the class name will not break compatibility with existing storage, so long as
	 * `uniqueKey` stays the same.
	 *
	 */
	UNIQUE_KEY: 0,
	/**
	 * A unique, stable ID associated with this namespace. This could be a  GUID, or any other
	 * string which does not appear anywhere else in the world.
	 *
	 * This string is used to ensure that objects of this class have unique identifiers distinct
	 * from objects of any other class. Object IDs are cryptographically derived from `uniqueKey`
	 * and validated against it. It is impossible to guess or forge a valid object ID without
	 * knowing the `uniqueKey`. Hence, if you keep the key secret, you can prevent anyone from
	 * forging IDs. However, if you don't care if users can forge valid IDs, then it's not a big
	 * deal if the key leaks.
	 *
	 * DO NOT LOSE this key, otherwise it may be difficult or impossible to recover stored data.
	 *
	 */
	EPHEMERAL_LOCAL: 1,
} as const;
export type Worker_DurableObjectNamespace_Which =
	(typeof Worker_DurableObjectNamespace_Which)[keyof typeof Worker_DurableObjectNamespace_Which];
export class Worker_DurableObjectNamespace extends $.Struct {
	static readonly UNIQUE_KEY = Worker_DurableObjectNamespace_Which.UNIQUE_KEY;
	static readonly EPHEMERAL_LOCAL =
		Worker_DurableObjectNamespace_Which.EPHEMERAL_LOCAL;
	static readonly ContainerOptions =
		Worker_DurableObjectNamespace_ContainerOptions;
	static readonly _capnp = {
		displayName: "DurableObjectNamespace",
		id: "b429dd547d15747d",
		size: new $.ObjectSize(8, 3),
	};
	/**
	 * Exported class name that implements the Durable Object.
	 *
	 * Changing the class name will not break compatibility with existing storage, so long as
	 * `uniqueKey` stays the same.
	 *
	 */
	get className(): string {
		return $.utils.getText(0, this);
	}
	set className(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * A unique, stable ID associated with this namespace. This could be a  GUID, or any other
	 * string which does not appear anywhere else in the world.
	 *
	 * This string is used to ensure that objects of this class have unique identifiers distinct
	 * from objects of any other class. Object IDs are cryptographically derived from `uniqueKey`
	 * and validated against it. It is impossible to guess or forge a valid object ID without
	 * knowing the `uniqueKey`. Hence, if you keep the key secret, you can prevent anyone from
	 * forging IDs. However, if you don't care if users can forge valid IDs, then it's not a big
	 * deal if the key leaks.
	 *
	 * DO NOT LOSE this key, otherwise it may be difficult or impossible to recover stored data.
	 *
	 */
	get uniqueKey(): string {
		$.utils.testWhich("uniqueKey", $.utils.getUint16(0, this), 0, this);
		return $.utils.getText(1, this);
	}
	get _isUniqueKey(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set uniqueKey(value: string) {
		$.utils.setUint16(0, 0, this);
		$.utils.setText(1, value, this);
	}
	get _isEphemeralLocal(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set ephemeralLocal(_: true) {
		$.utils.setUint16(0, 1, this);
	}
	/**
	 * By default, Durable Objects are evicted after 10 seconds of inactivity, and expire 70 seconds
	 * after all clients have disconnected. Some applications may want to keep their Durable Objects
	 * pinned to memory forever, so we provide this flag to change the default behavior.
	 *
	 * Note that this is only supported in Workerd; production Durable Objects cannot toggle eviction.
	 *
	 */
	get preventEviction(): boolean {
		return $.utils.getBit(16, this);
	}
	set preventEviction(value: boolean) {
		$.utils.setBit(16, value, this);
	}
	/**
	 * Whether or not Durable Objects in this namespace can use the `storage.sql` API to execute SQL
	 * queries.
	 *
	 * workerd uses SQLite to back all Durable Objects, but the SQL API is hidden by default to
	 * emulate behavior of traditional DO namespaces on Cloudflare that aren't SQLite-backed. This
	 * flag should be enabled when testing code that will run on a SQLite-backed namespace.
	 *
	 */
	get enableSql(): boolean {
		return $.utils.getBit(17, this);
	}
	set enableSql(value: boolean) {
		$.utils.setBit(17, value, this);
	}
	_adoptContainer(
		value: $.Orphan<Worker_DurableObjectNamespace_ContainerOptions>
	): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownContainer(): $.Orphan<Worker_DurableObjectNamespace_ContainerOptions> {
		return $.utils.disown(this.container);
	}
	/**
	 * If present, Durable Objects in this namespace have attached containers.
	 * workerd will talk to the configured container engine to start containers for each
	 * Durable Object based on the given image. The Durable Object can access the container via the
	 * ctx.container API. TODO(CloudChamber): add link to docs.
	 *
	 */
	get container(): Worker_DurableObjectNamespace_ContainerOptions {
		return $.utils.getStruct(
			2,
			Worker_DurableObjectNamespace_ContainerOptions,
			this
		);
	}
	_hasContainer(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initContainer(): Worker_DurableObjectNamespace_ContainerOptions {
		return $.utils.initStructAt(
			2,
			Worker_DurableObjectNamespace_ContainerOptions,
			this
		);
	}
	set container(value: Worker_DurableObjectNamespace_ContainerOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	toString(): string {
		return "Worker_DurableObjectNamespace_" + super.toString();
	}
	which(): Worker_DurableObjectNamespace_Which {
		return $.utils.getUint16(0, this) as Worker_DurableObjectNamespace_Which;
	}
}
export class Worker_DockerConfiguration extends $.Struct {
	static readonly _capnp = {
		displayName: "DockerConfiguration",
		id: "e62f96c20d9fb872",
		size: new $.ObjectSize(0, 1),
	};
	/**
	 * Path to the Docker socket.
	 *
	 */
	get socketPath(): string {
		return $.utils.getText(0, this);
	}
	set socketPath(value: string) {
		$.utils.setText(0, value, this);
	}
	toString(): string {
		return "Worker_DockerConfiguration_" + super.toString();
	}
}
export const Worker_DurableObjectStorage_Which = {
	/**
	 * Default. The worker has no Durable Objects. `durableObjectNamespaces` must be empty, or
	 * define all namespaces as `ephemeralLocal`, or this must be an abstract worker (meant to be
	 * inherited by other workers, who will specify `durableObjectStorage`).
	 *
	 */
	NONE: 0,
	/**
	 * The `state.storage` API stores in-memory only. All stored data will persist for the
	 * lifetime of the process, but will be lost upon process exit.
	 *
	 * Individual objects will still shut down when idle as normal -- only data stored with the
	 * `state.storage` interface is persistent for the lifetime of the process.
	 *
	 * This mode is intended for local testing purposes.
	 *
	 */
	IN_MEMORY: 1,
	/**
	 * ** EXPERIMENTAL; SUBJECT TO BACKWARDS-INCOMPATIBLE CHANGE **
	 *
	 * Durable Object data will be stored in a directory on local disk. This field is the name of
	 * a service, which must be a DiskDirectory service. For each Durable Object class, a
	 * subdirectory will be created using `uniqueKey` as the name. Within the directory, one or
	 * more files are created for each object, with names `<id>.<ext>`, where `.<ext>` may be any of
	 * a number of different extensions depending on the storage mode. (Currently, the main storage
	 * is a file with the extension `.sqlite`, and in certain situations extra files with the
	 * extensions `.sqlite-wal`, and `.sqlite-shm` may also be present.)
	 *
	 */
	LOCAL_DISK: 2,
} as const;
export type Worker_DurableObjectStorage_Which =
	(typeof Worker_DurableObjectStorage_Which)[keyof typeof Worker_DurableObjectStorage_Which];
/**
 * Specifies where this worker's Durable Objects are stored.
 *
 */
export class Worker_DurableObjectStorage extends $.Struct {
	static readonly NONE = Worker_DurableObjectStorage_Which.NONE;
	static readonly IN_MEMORY = Worker_DurableObjectStorage_Which.IN_MEMORY;
	static readonly LOCAL_DISK = Worker_DurableObjectStorage_Which.LOCAL_DISK;
	static readonly _capnp = {
		displayName: "durableObjectStorage",
		id: "cc72b3faa57827d4",
		size: new $.ObjectSize(8, 13),
	};
	get _isNone(): boolean {
		return $.utils.getUint16(2, this) === 0;
	}
	set none(_: true) {
		$.utils.setUint16(2, 0, this);
	}
	get _isInMemory(): boolean {
		return $.utils.getUint16(2, this) === 1;
	}
	set inMemory(_: true) {
		$.utils.setUint16(2, 1, this);
	}
	/**
	 * ** EXPERIMENTAL; SUBJECT TO BACKWARDS-INCOMPATIBLE CHANGE **
	 *
	 * Durable Object data will be stored in a directory on local disk. This field is the name of
	 * a service, which must be a DiskDirectory service. For each Durable Object class, a
	 * subdirectory will be created using `uniqueKey` as the name. Within the directory, one or
	 * more files are created for each object, with names `<id>.<ext>`, where `.<ext>` may be any of
	 * a number of different extensions depending on the storage mode. (Currently, the main storage
	 * is a file with the extension `.sqlite`, and in certain situations extra files with the
	 * extensions `.sqlite-wal`, and `.sqlite-shm` may also be present.)
	 *
	 */
	get localDisk(): string {
		$.utils.testWhich("localDisk", $.utils.getUint16(2, this), 2, this);
		return $.utils.getText(8, this);
	}
	get _isLocalDisk(): boolean {
		return $.utils.getUint16(2, this) === 2;
	}
	set localDisk(value: string) {
		$.utils.setUint16(2, 2, this);
		$.utils.setText(8, value, this);
	}
	toString(): string {
		return "Worker_DurableObjectStorage_" + super.toString();
	}
	which(): Worker_DurableObjectStorage_Which {
		return $.utils.getUint16(2, this) as Worker_DurableObjectStorage_Which;
	}
}
export const Worker_ContainerEngine_Which = {
	/**
	 * No container engine configured. Container operations will not be available.
	 *
	 */
	NONE: 0,
	/**
	 * Use local Docker daemon for container operations.
	 * Only used for local development and testing purposes.
	 *
	 */
	LOCAL_DOCKER: 1,
} as const;
export type Worker_ContainerEngine_Which =
	(typeof Worker_ContainerEngine_Which)[keyof typeof Worker_ContainerEngine_Which];
export class Worker_ContainerEngine extends $.Struct {
	static readonly NONE = Worker_ContainerEngine_Which.NONE;
	static readonly LOCAL_DOCKER = Worker_ContainerEngine_Which.LOCAL_DOCKER;
	static readonly _capnp = {
		displayName: "containerEngine",
		id: "82de68f58dc2eb24",
		size: new $.ObjectSize(8, 13),
	};
	get _isNone(): boolean {
		return $.utils.getUint16(4, this) === 0;
	}
	set none(_: true) {
		$.utils.setUint16(4, 0, this);
	}
	_adoptLocalDocker(value: $.Orphan<Worker_DockerConfiguration>): void {
		$.utils.setUint16(4, 1, this);
		$.utils.adopt(value, $.utils.getPointer(12, this));
	}
	_disownLocalDocker(): $.Orphan<Worker_DockerConfiguration> {
		return $.utils.disown(this.localDocker);
	}
	/**
	 * Use local Docker daemon for container operations.
	 * Only used for local development and testing purposes.
	 *
	 */
	get localDocker(): Worker_DockerConfiguration {
		$.utils.testWhich("localDocker", $.utils.getUint16(4, this), 1, this);
		return $.utils.getStruct(12, Worker_DockerConfiguration, this);
	}
	_hasLocalDocker(): boolean {
		return !$.utils.isNull($.utils.getPointer(12, this));
	}
	_initLocalDocker(): Worker_DockerConfiguration {
		$.utils.setUint16(4, 1, this);
		return $.utils.initStructAt(12, Worker_DockerConfiguration, this);
	}
	get _isLocalDocker(): boolean {
		return $.utils.getUint16(4, this) === 1;
	}
	set localDocker(value: Worker_DockerConfiguration) {
		$.utils.setUint16(4, 1, this);
		$.utils.copyFrom(value, $.utils.getPointer(12, this));
	}
	toString(): string {
		return "Worker_ContainerEngine_" + super.toString();
	}
	which(): Worker_ContainerEngine_Which {
		return $.utils.getUint16(4, this) as Worker_ContainerEngine_Which;
	}
}
export const Worker_Which = {
	/**
	 * The Worker is composed of ES modules that may import each other. The first module in the list
	 * is the main module, which exports event handlers.
	 *
	 */
	MODULES: 0,
	/**
	 * The Worker is composed of one big script that uses global `addEventListener()` to register
	 * event handlers.
	 *
	 * The value of this field is the raw source code. When using Cap'n Proto text format, use the
	 * `embed` directive to read the code from an external file:
	 *
	 *     serviceWorkerScript = embed "worker.js"
	 *
	 */
	SERVICE_WORKER_SCRIPT: 1,
	/**
	 * Inherit the configuration of some other Worker by its service name. This Worker is a clone
	 * of the other worker, but various settings can be modified:
	 * * `bindings`, if specified, overrides specific named bindings. (Each binding listed in the
	 *   derived worker must match the name and type of some binding in the inherited worker.)
	 * * `globalOutbound`, if non-null, overrides the one specified in the inherited worker.
	 * * `compatibilityDate` and `compatibilityFlags` CANNOT be modified; they must be null.
	 * * If the inherited worker defines durable object namespaces, then the derived worker must
	 *   specify `durableObjectStorage` to specify where its instances should be stored. Each
	 *   devived worker receives its own namespace of objects. `durableObjectUniqueKeyModifier`
	 *   must also be specified by derived workers.
	 *
	 * This can be useful when you want to run the same Worker in multiple configurations or hooked
	 * up to different back-ends. Note that all derived workers run in the same isolate as the
	 * base worker; they differ in the content of the `env` object passed to them, which contains
	 * the bindings. (When using service workers syntax, the global scope contains the bindings;
	 * in this case each derived worker runs in its own global scope, though still in the same
	 * isolate.)
	 *
	 */
	INHERIT: 2,
} as const;
export type Worker_Which = (typeof Worker_Which)[keyof typeof Worker_Which];
export class Worker extends $.Struct {
	static readonly MODULES = Worker_Which.MODULES;
	static readonly SERVICE_WORKER_SCRIPT = Worker_Which.SERVICE_WORKER_SCRIPT;
	static readonly INHERIT = Worker_Which.INHERIT;
	static readonly Module = Worker_Module;
	static readonly Binding = Worker_Binding;
	static readonly DurableObjectNamespace = Worker_DurableObjectNamespace;
	static readonly DockerConfiguration = Worker_DockerConfiguration;
	static readonly _capnp = {
		displayName: "Worker",
		id: "acfa77e88fd97d1c",
		size: new $.ObjectSize(8, 13),
		defaultGlobalOutbound: $.readRawPointer(
			new Uint8Array([
				16, 7, 80, 1, 3, 0, 0, 17, 9, 74, 0, 1, 255, 105, 110, 116, 101, 114,
				110, 101, 116, 0, 0, 0,
			]).buffer
		),
	};
	static _Modules: $.ListCtor<Worker_Module>;
	static _Bindings: $.ListCtor<Worker_Binding>;
	static _DurableObjectNamespaces: $.ListCtor<Worker_DurableObjectNamespace>;
	static _Tails: $.ListCtor<ServiceDesignator>;
	static _StreamingTails: $.ListCtor<ServiceDesignator>;
	_adoptModules(value: $.Orphan<$.List<Worker_Module>>): void {
		$.utils.setUint16(0, 0, this);
		$.utils.adopt(value, $.utils.getPointer(0, this));
	}
	_disownModules(): $.Orphan<$.List<Worker_Module>> {
		return $.utils.disown(this.modules);
	}
	/**
	 * The Worker is composed of ES modules that may import each other. The first module in the list
	 * is the main module, which exports event handlers.
	 *
	 */
	get modules(): $.List<Worker_Module> {
		$.utils.testWhich("modules", $.utils.getUint16(0, this), 0, this);
		return $.utils.getList(0, Worker._Modules, this);
	}
	_hasModules(): boolean {
		return !$.utils.isNull($.utils.getPointer(0, this));
	}
	_initModules(length: number): $.List<Worker_Module> {
		$.utils.setUint16(0, 0, this);
		return $.utils.initList(0, Worker._Modules, length, this);
	}
	get _isModules(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set modules(value: $.List<Worker_Module>) {
		$.utils.setUint16(0, 0, this);
		$.utils.copyFrom(value, $.utils.getPointer(0, this));
	}
	/**
	 * The Worker is composed of one big script that uses global `addEventListener()` to register
	 * event handlers.
	 *
	 * The value of this field is the raw source code. When using Cap'n Proto text format, use the
	 * `embed` directive to read the code from an external file:
	 *
	 *     serviceWorkerScript = embed "worker.js"
	 *
	 */
	get serviceWorkerScript(): string {
		$.utils.testWhich(
			"serviceWorkerScript",
			$.utils.getUint16(0, this),
			1,
			this
		);
		return $.utils.getText(0, this);
	}
	get _isServiceWorkerScript(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set serviceWorkerScript(value: string) {
		$.utils.setUint16(0, 1, this);
		$.utils.setText(0, value, this);
	}
	/**
	 * Inherit the configuration of some other Worker by its service name. This Worker is a clone
	 * of the other worker, but various settings can be modified:
	 * * `bindings`, if specified, overrides specific named bindings. (Each binding listed in the
	 *   derived worker must match the name and type of some binding in the inherited worker.)
	 * * `globalOutbound`, if non-null, overrides the one specified in the inherited worker.
	 * * `compatibilityDate` and `compatibilityFlags` CANNOT be modified; they must be null.
	 * * If the inherited worker defines durable object namespaces, then the derived worker must
	 *   specify `durableObjectStorage` to specify where its instances should be stored. Each
	 *   devived worker receives its own namespace of objects. `durableObjectUniqueKeyModifier`
	 *   must also be specified by derived workers.
	 *
	 * This can be useful when you want to run the same Worker in multiple configurations or hooked
	 * up to different back-ends. Note that all derived workers run in the same isolate as the
	 * base worker; they differ in the content of the `env` object passed to them, which contains
	 * the bindings. (When using service workers syntax, the global scope contains the bindings;
	 * in this case each derived worker runs in its own global scope, though still in the same
	 * isolate.)
	 *
	 */
	get inherit(): string {
		$.utils.testWhich("inherit", $.utils.getUint16(0, this), 2, this);
		return $.utils.getText(0, this);
	}
	get _isInherit(): boolean {
		return $.utils.getUint16(0, this) === 2;
	}
	set inherit(value: string) {
		$.utils.setUint16(0, 2, this);
		$.utils.setText(0, value, this);
	}
	get compatibilityDate(): string {
		return $.utils.getText(1, this);
	}
	set compatibilityDate(value: string) {
		$.utils.setText(1, value, this);
	}
	_adoptCompatibilityFlags(value: $.Orphan<$.List<string>>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownCompatibilityFlags(): $.Orphan<$.List<string>> {
		return $.utils.disown(this.compatibilityFlags);
	}
	/**
	 * See: https://developers.cloudflare.com/workers/platform/compatibility-dates/
	 *
	 * `compatibilityDate` must be specified, unless the Worker inhits from another worker, in which
	 * case it must not be specified. `compatibilityFlags` can optionally be specified when
	 * `compatibilityDate` is specified.
	 *
	 */
	get compatibilityFlags(): $.List<string> {
		return $.utils.getList(2, $.TextList, this);
	}
	_hasCompatibilityFlags(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initCompatibilityFlags(length: number): $.List<string> {
		return $.utils.initList(2, $.TextList, length, this);
	}
	set compatibilityFlags(value: $.List<string>) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	_adoptBindings(value: $.Orphan<$.List<Worker_Binding>>): void {
		$.utils.adopt(value, $.utils.getPointer(3, this));
	}
	_disownBindings(): $.Orphan<$.List<Worker_Binding>> {
		return $.utils.disown(this.bindings);
	}
	/**
	 * List of bindings, which give the Worker access to external resources and configuration
	 * settings.
	 *
	 * For Workers using ES modules syntax, the bindings are delivered via the `env` object. For
	 * service workers syntax, each binding shows up as a global variable.
	 *
	 */
	get bindings(): $.List<Worker_Binding> {
		return $.utils.getList(3, Worker._Bindings, this);
	}
	_hasBindings(): boolean {
		return !$.utils.isNull($.utils.getPointer(3, this));
	}
	_initBindings(length: number): $.List<Worker_Binding> {
		return $.utils.initList(3, Worker._Bindings, length, this);
	}
	set bindings(value: $.List<Worker_Binding>) {
		$.utils.copyFrom(value, $.utils.getPointer(3, this));
	}
	_adoptGlobalOutbound(value: $.Orphan<ServiceDesignator>): void {
		$.utils.adopt(value, $.utils.getPointer(4, this));
	}
	_disownGlobalOutbound(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.globalOutbound);
	}
	/**
	 * Where should the global "fetch" go to? The default is the service called "internet", which
	 * should usually be configured to talk to the public internet.
	 *
	 */
	get globalOutbound(): ServiceDesignator {
		return $.utils.getStruct(
			4,
			ServiceDesignator,
			this,
			Worker._capnp.defaultGlobalOutbound
		);
	}
	_hasGlobalOutbound(): boolean {
		return !$.utils.isNull($.utils.getPointer(4, this));
	}
	_initGlobalOutbound(): ServiceDesignator {
		return $.utils.initStructAt(4, ServiceDesignator, this);
	}
	set globalOutbound(value: ServiceDesignator) {
		$.utils.copyFrom(value, $.utils.getPointer(4, this));
	}
	_adoptCacheApiOutbound(value: $.Orphan<ServiceDesignator>): void {
		$.utils.adopt(value, $.utils.getPointer(7, this));
	}
	_disownCacheApiOutbound(): $.Orphan<ServiceDesignator> {
		return $.utils.disown(this.cacheApiOutbound);
	}
	/**
	 * Where should cache API (i.e. caches.default and caches.open(...)) requests go?
	 *
	 */
	get cacheApiOutbound(): ServiceDesignator {
		return $.utils.getStruct(7, ServiceDesignator, this);
	}
	_hasCacheApiOutbound(): boolean {
		return !$.utils.isNull($.utils.getPointer(7, this));
	}
	_initCacheApiOutbound(): ServiceDesignator {
		return $.utils.initStructAt(7, ServiceDesignator, this);
	}
	set cacheApiOutbound(value: ServiceDesignator) {
		$.utils.copyFrom(value, $.utils.getPointer(7, this));
	}
	_adoptDurableObjectNamespaces(
		value: $.Orphan<$.List<Worker_DurableObjectNamespace>>
	): void {
		$.utils.adopt(value, $.utils.getPointer(5, this));
	}
	_disownDurableObjectNamespaces(): $.Orphan<
		$.List<Worker_DurableObjectNamespace>
	> {
		return $.utils.disown(this.durableObjectNamespaces);
	}
	/**
	 * List of durable object namespaces in this Worker.
	 *
	 */
	get durableObjectNamespaces(): $.List<Worker_DurableObjectNamespace> {
		return $.utils.getList(5, Worker._DurableObjectNamespaces, this);
	}
	_hasDurableObjectNamespaces(): boolean {
		return !$.utils.isNull($.utils.getPointer(5, this));
	}
	_initDurableObjectNamespaces(
		length: number
	): $.List<Worker_DurableObjectNamespace> {
		return $.utils.initList(5, Worker._DurableObjectNamespaces, length, this);
	}
	set durableObjectNamespaces(value: $.List<Worker_DurableObjectNamespace>) {
		$.utils.copyFrom(value, $.utils.getPointer(5, this));
	}
	/**
	 * Additional text which is hashed together with `DurableObjectNamespace.uniqueKey`. When using
	 * worker inheritance, each derived worker must specify a unique modifier to ensure that its
	 * Durable Object instances have unique IDs from all other workers inheriting the same parent.
	 *
	 * DO NOT LOSE this value, otherwise it may be difficult or impossible to recover stored data.
	 *
	 */
	get durableObjectUniqueKeyModifier(): string {
		return $.utils.getText(6, this);
	}
	set durableObjectUniqueKeyModifier(value: string) {
		$.utils.setText(6, value, this);
	}
	/**
	 * Specifies where this worker's Durable Objects are stored.
	 *
	 */
	get durableObjectStorage(): Worker_DurableObjectStorage {
		return $.utils.getAs(Worker_DurableObjectStorage, this);
	}
	_initDurableObjectStorage(): Worker_DurableObjectStorage {
		return $.utils.getAs(Worker_DurableObjectStorage, this);
	}
	get moduleFallback(): string {
		return $.utils.getText(9, this);
	}
	set moduleFallback(value: string) {
		$.utils.setText(9, value, this);
	}
	_adoptTails(value: $.Orphan<$.List<ServiceDesignator>>): void {
		$.utils.adopt(value, $.utils.getPointer(10, this));
	}
	_disownTails(): $.Orphan<$.List<ServiceDesignator>> {
		return $.utils.disown(this.tails);
	}
	/**
	 * List of tail worker services that should receive tail events for this worker.
	 * See: https://developers.cloudflare.com/workers/observability/logs/tail-workers/
	 *
	 */
	get tails(): $.List<ServiceDesignator> {
		return $.utils.getList(10, Worker._Tails, this);
	}
	_hasTails(): boolean {
		return !$.utils.isNull($.utils.getPointer(10, this));
	}
	_initTails(length: number): $.List<ServiceDesignator> {
		return $.utils.initList(10, Worker._Tails, length, this);
	}
	set tails(value: $.List<ServiceDesignator>) {
		$.utils.copyFrom(value, $.utils.getPointer(10, this));
	}
	_adoptStreamingTails(value: $.Orphan<$.List<ServiceDesignator>>): void {
		$.utils.adopt(value, $.utils.getPointer(11, this));
	}
	_disownStreamingTails(): $.Orphan<$.List<ServiceDesignator>> {
		return $.utils.disown(this.streamingTails);
	}
	/**
	 * List of streaming tail worker services that should receive tail events for this worker.
	 * NOTE: This will be deleted in a future refactor, do not depend on this.
	 *
	 */
	get streamingTails(): $.List<ServiceDesignator> {
		return $.utils.getList(11, Worker._StreamingTails, this);
	}
	_hasStreamingTails(): boolean {
		return !$.utils.isNull($.utils.getPointer(11, this));
	}
	_initStreamingTails(length: number): $.List<ServiceDesignator> {
		return $.utils.initList(11, Worker._StreamingTails, length, this);
	}
	set streamingTails(value: $.List<ServiceDesignator>) {
		$.utils.copyFrom(value, $.utils.getPointer(11, this));
	}
	get containerEngine(): Worker_ContainerEngine {
		return $.utils.getAs(Worker_ContainerEngine, this);
	}
	_initContainerEngine(): Worker_ContainerEngine {
		return $.utils.getAs(Worker_ContainerEngine, this);
	}
	toString(): string {
		return "Worker_" + super.toString();
	}
	which(): Worker_Which {
		return $.utils.getUint16(0, this) as Worker_Which;
	}
}
/**
 * Talk to the server over encrypted HTTPS.
 *
 */
export class ExternalServer_Https extends $.Struct {
	static readonly _capnp = {
		displayName: "https",
		id: "ac37e02afd3dc6db",
		size: new $.ObjectSize(8, 4),
	};
	_adoptOptions(value: $.Orphan<HttpOptions>): void {
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownOptions(): $.Orphan<HttpOptions> {
		return $.utils.disown(this.options);
	}
	get options(): HttpOptions {
		return $.utils.getStruct(1, HttpOptions, this);
	}
	_hasOptions(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initOptions(): HttpOptions {
		return $.utils.initStructAt(1, HttpOptions, this);
	}
	set options(value: HttpOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptTlsOptions(value: $.Orphan<TlsOptions>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownTlsOptions(): $.Orphan<TlsOptions> {
		return $.utils.disown(this.tlsOptions);
	}
	get tlsOptions(): TlsOptions {
		return $.utils.getStruct(2, TlsOptions, this);
	}
	_hasTlsOptions(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initTlsOptions(): TlsOptions {
		return $.utils.initStructAt(2, TlsOptions, this);
	}
	set tlsOptions(value: TlsOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	/**
	 * If present, expect the host to present a certificate authenticating it as this hostname.
	 * If `certificateHost` is not provided, then the certificate is checked against `address`.
	 *
	 */
	get certificateHost(): string {
		return $.utils.getText(3, this);
	}
	set certificateHost(value: string) {
		$.utils.setText(3, value, this);
	}
	toString(): string {
		return "ExternalServer_Https_" + super.toString();
	}
}
/**
 * Connect to the server over raw TCP. Bindings to this service will only support the
 * `connect()` method; `fetch()` will throw an exception.
 *
 */
export class ExternalServer_Tcp extends $.Struct {
	static readonly _capnp = {
		displayName: "tcp",
		id: "d941637df0fb39f1",
		size: new $.ObjectSize(8, 4),
	};
	_adoptTlsOptions(value: $.Orphan<TlsOptions>): void {
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownTlsOptions(): $.Orphan<TlsOptions> {
		return $.utils.disown(this.tlsOptions);
	}
	get tlsOptions(): TlsOptions {
		return $.utils.getStruct(1, TlsOptions, this);
	}
	_hasTlsOptions(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initTlsOptions(): TlsOptions {
		return $.utils.initStructAt(1, TlsOptions, this);
	}
	set tlsOptions(value: TlsOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	get certificateHost(): string {
		return $.utils.getText(2, this);
	}
	set certificateHost(value: string) {
		$.utils.setText(2, value, this);
	}
	toString(): string {
		return "ExternalServer_Tcp_" + super.toString();
	}
}
export const ExternalServer_Which = {
	/**
	 * Address/port of the server. Optional; if not specified, then you will be required to specify
	 * the address on the command line with with `--external-addr <name>=<addr>`.
	 *
	 * Examples:
	 * - "1.2.3.4": Connect to the given IPv4 address on the protocol's default port.
	 * - "1.2.3.4:80": Connect to the given IPv4 address and port.
	 * - "1234:5678::abcd": Connect to the given IPv6 address on the protocol's default port.
	 * - "[1234:5678::abcd]:80": Connect to the given IPv6 address and port.
	 * - "unix:/path/to/socket": Connect to the given Unix Domain socket by path.
	 * - "unix-abstract:name": On Linux, connect to the given "abstract" Unix socket name.
	 * - "example.com:80": Perform a DNS lookup to determine the address, and then connect to it.
	 *
	 * (These are the formats supported by KJ's parseAddress().)
	 *
	 */
	HTTP: 0,
	/**
	 * Talk to the server over unencrypted HTTP.
	 *
	 */
	HTTPS: 1,
	/**
	 * Talk to the server over encrypted HTTPS.
	 *
	 */
	TCP: 2,
} as const;
export type ExternalServer_Which =
	(typeof ExternalServer_Which)[keyof typeof ExternalServer_Which];
/**
 * Describes the ability to talk to a specific server, typically a back-end server available
 * on the internal network.
 *
 * When a Worker contains a service binding that points to an ExternalServer, *all* fetch()
 * calls on that binding will be delivered to that server, regardless of whether the hostname
 * or protocol specified in the URL actually match the hostname or protocol used by the actual
 * server. Typically, a Worker implementing a reverse proxy would use this to forward a request
 * to a back-end application server. Such a back-end typically does not have a real public
 * hostname, since it is only reachable through the proxy, but the requests forwarded to it will
 * keep the hostname that was on the original request.
 *
 * Note that this also implies that regardless of whether the original URL was http: or https:,
 * the request will be delivered to the target server using the protocol specified below. A
 * header like `X-Forwarded-Proto` can be used to pass along the original protocol; see
 * `HttpOptions`.
 *
 */
export class ExternalServer extends $.Struct {
	static readonly HTTP = ExternalServer_Which.HTTP;
	static readonly HTTPS = ExternalServer_Which.HTTPS;
	static readonly TCP = ExternalServer_Which.TCP;
	static readonly _capnp = {
		displayName: "ExternalServer",
		id: "ff209f9aa352f5a4",
		size: new $.ObjectSize(8, 4),
	};
	/**
	 * Address/port of the server. Optional; if not specified, then you will be required to specify
	 * the address on the command line with with `--external-addr <name>=<addr>`.
	 *
	 * Examples:
	 * - "1.2.3.4": Connect to the given IPv4 address on the protocol's default port.
	 * - "1.2.3.4:80": Connect to the given IPv4 address and port.
	 * - "1234:5678::abcd": Connect to the given IPv6 address on the protocol's default port.
	 * - "[1234:5678::abcd]:80": Connect to the given IPv6 address and port.
	 * - "unix:/path/to/socket": Connect to the given Unix Domain socket by path.
	 * - "unix-abstract:name": On Linux, connect to the given "abstract" Unix socket name.
	 * - "example.com:80": Perform a DNS lookup to determine the address, and then connect to it.
	 *
	 * (These are the formats supported by KJ's parseAddress().)
	 *
	 */
	get address(): string {
		return $.utils.getText(0, this);
	}
	set address(value: string) {
		$.utils.setText(0, value, this);
	}
	_adoptHttp(value: $.Orphan<HttpOptions>): void {
		$.utils.setUint16(0, 0, this);
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownHttp(): $.Orphan<HttpOptions> {
		return $.utils.disown(this.http);
	}
	/**
	 * Talk to the server over unencrypted HTTP.
	 *
	 */
	get http(): HttpOptions {
		$.utils.testWhich("http", $.utils.getUint16(0, this), 0, this);
		return $.utils.getStruct(1, HttpOptions, this);
	}
	_hasHttp(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initHttp(): HttpOptions {
		$.utils.setUint16(0, 0, this);
		return $.utils.initStructAt(1, HttpOptions, this);
	}
	get _isHttp(): boolean {
		return $.utils.getUint16(0, this) === 0;
	}
	set http(value: HttpOptions) {
		$.utils.setUint16(0, 0, this);
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	/**
	 * Talk to the server over encrypted HTTPS.
	 *
	 */
	get https(): ExternalServer_Https {
		$.utils.testWhich("https", $.utils.getUint16(0, this), 1, this);
		return $.utils.getAs(ExternalServer_Https, this);
	}
	_initHttps(): ExternalServer_Https {
		$.utils.setUint16(0, 1, this);
		return $.utils.getAs(ExternalServer_Https, this);
	}
	get _isHttps(): boolean {
		return $.utils.getUint16(0, this) === 1;
	}
	set https(_: true) {
		$.utils.setUint16(0, 1, this);
	}
	/**
	 * Connect to the server over raw TCP. Bindings to this service will only support the
	 * `connect()` method; `fetch()` will throw an exception.
	 *
	 */
	get tcp(): ExternalServer_Tcp {
		$.utils.testWhich("tcp", $.utils.getUint16(0, this), 2, this);
		return $.utils.getAs(ExternalServer_Tcp, this);
	}
	_initTcp(): ExternalServer_Tcp {
		$.utils.setUint16(0, 2, this);
		return $.utils.getAs(ExternalServer_Tcp, this);
	}
	get _isTcp(): boolean {
		return $.utils.getUint16(0, this) === 2;
	}
	set tcp(_: true) {
		$.utils.setUint16(0, 2, this);
	}
	toString(): string {
		return "ExternalServer_" + super.toString();
	}
	which(): ExternalServer_Which {
		return $.utils.getUint16(0, this) as ExternalServer_Which;
	}
}
/**
 * Describes the ability to talk to a network.
 *
 * This is commonly used to define the "internet" service which is the default `globalOutbound`
 * for all Workers. To prevent SSRF, by default Workers will not be permitted to reach internal
 * network addresses using global fetch(). It's recommended that you create ExternalServer
 * bindings instead to grant access to specific servers. However, if you really want to, you
 * can configure a service that grants arbitrary internal network access, like:
 *
 *     ( name = "internalNetwork",
 *       network = (
 *         allow = ["public", "private"],
 *       )
 *     )
 *
 */
export class Network extends $.Struct {
	static readonly _capnp = {
		displayName: "Network",
		id: "fa42244f950c9b9c",
		size: new $.ObjectSize(0, 3),
		defaultAllow: $.readRawPointer(
			new Uint8Array([
				16, 3, 17, 1, 14, 17, 1, 58, 63, 112, 117, 98, 108, 105, 99,
			]).buffer
		),
	};
	_adoptAllow(value: $.Orphan<$.List<string>>): void {
		$.utils.adopt(value, $.utils.getPointer(0, this));
	}
	_disownAllow(): $.Orphan<$.List<string>> {
		return $.utils.disown(this.allow);
	}
	get allow(): $.List<string> {
		return $.utils.getList(0, $.TextList, this, Network._capnp.defaultAllow);
	}
	_hasAllow(): boolean {
		return !$.utils.isNull($.utils.getPointer(0, this));
	}
	_initAllow(length: number): $.List<string> {
		return $.utils.initList(0, $.TextList, length, this);
	}
	set allow(value: $.List<string>) {
		$.utils.copyFrom(value, $.utils.getPointer(0, this));
	}
	_adoptDeny(value: $.Orphan<$.List<string>>): void {
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownDeny(): $.Orphan<$.List<string>> {
		return $.utils.disown(this.deny);
	}
	/**
	 * Specifies which network addresses the Worker will be allowed to connect to, e.g. using fetch().
	 * The default allows publicly-routable IP addresses only, in order to prevent SSRF attacks.
	 *
	 * The allow and deny lists specify network blocks in CIDR notation (IPv4 and IPv6), such as
	 * "192.0.2.0/24" or "2001:db8::/32". Traffic will be permitted as long as the address
	 * matches at least one entry in the allow list and none in the deny list.
	 *
	 * In addition to IPv4 and IPv6 CIDR notation, several special strings may be specified:
	 * - "private": Matches network addresses that are reserved by standards for private networks,
	 *   such as "10.0.0.0/8" or "192.168.0.0/16". This is a superset of "local".
	 * - "public": Opposite of "private".
	 * - "local": Matches network addresses that are defined by standards to only be accessible from
	 *   the local machine, such as "127.0.0.0/8" or Unix domain addresses.
	 * - "network": Opposite of "local".
	 * - "unix": Matches all Unix domain socket addresses. (In the future, we may support specifying a
	 *   glob to narrow this to specific paths.)
	 * - "unix-abstract": Matches Linux's "abstract unix domain" addresses. (In the future, we may
	 *   support specifying a glob.)
	 *
	 * In the case that the Worker specifies a DNS hostname rather than a raw address, these rules are
	 * used to filter the addresses returned by the lookup. If none of the returned addresses turn
	 * out to be permitted, then the system will behave as if the DNS entry did not exist.
	 *
	 * (The above is exactly the format supported by kj::Network::restrictPeers().)
	 *
	 */
	get deny(): $.List<string> {
		return $.utils.getList(1, $.TextList, this);
	}
	_hasDeny(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initDeny(length: number): $.List<string> {
		return $.utils.initList(1, $.TextList, length, this);
	}
	set deny(value: $.List<string>) {
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	_adoptTlsOptions(value: $.Orphan<TlsOptions>): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownTlsOptions(): $.Orphan<TlsOptions> {
		return $.utils.disown(this.tlsOptions);
	}
	get tlsOptions(): TlsOptions {
		return $.utils.getStruct(2, TlsOptions, this);
	}
	_hasTlsOptions(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initTlsOptions(): TlsOptions {
		return $.utils.initStructAt(2, TlsOptions, this);
	}
	set tlsOptions(value: TlsOptions) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	toString(): string {
		return "Network_" + super.toString();
	}
}
/**
 * Configures access to a directory on disk. This is a type of service which will expose an HTTP
 * interface to the directory content.
 *
 * This is very bare-bones, generally not suitable for serving a web site on its own. In
 * particular, no attempt is made to guess the `Content-Type` header. You normally would wrap
 * this in a Worker that fills in the metadata in the way you want.
 *
 * A GET request targeting a directory (rather than a file) will return a basic JSAN directory
 * listing like:
 *
 *     [{"name":"foo","type":"file"},{"name":"bar","type":"directory"}]
 *
 * Possible "type" values are "file", "directory", "symlink", "blockDevice", "characterDevice",
 * "namedPipe", "socket", "other".
 *
 * `Content-Type` will be `application/octet-stream` for files or `application/json` for a
 * directory listing. Files will have a `Content-Length` header, directories will not. Symlinks
 * will be followed (but there is intentionally no way to create one, even if `writable` is
 * `true`), and treated according to the type of file they point to. The other inode types cannot
 * be opened; trying to do so will produce a "406 Not Acceptable" error (on the theory that there
 * is no acceptable format for these, regardless of what the client says it accepts).
 *
 * `HEAD` requests are properly optimized to perform a stat() without actually opening the file.
 *
 */
export class DiskDirectory extends $.Struct {
	static readonly _capnp = {
		displayName: "DiskDirectory",
		id: "9048ab22835f51c3",
		size: new $.ObjectSize(8, 1),
		defaultWritable: $.getBitMask(false, 0),
		defaultAllowDotfiles: $.getBitMask(false, 1),
	};
	/**
	 * The filesystem path of the directory. If not specified, then it must be specified on the
	 * command line with `--directory-path <service-name>=<path>`.
	 *
	 * Relative paths are interpreted relative to the current directory where the server is executed,
	 * NOT relative to the config file. So, you should usually use absolute paths in the config file.
	 *
	 */
	get path(): string {
		return $.utils.getText(0, this);
	}
	set path(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * Whether to support PUT requests for writing. A PUT will write to a temporary file which
	 * is atomically moved into place upon successful completion of the upload. Parent directories are
	 * created as needed.
	 *
	 */
	get writable(): boolean {
		return $.utils.getBit(0, this, DiskDirectory._capnp.defaultWritable);
	}
	set writable(value: boolean) {
		$.utils.setBit(0, value, this, DiskDirectory._capnp.defaultWritable);
	}
	/**
	 * Whether to allow access to files and directories whose name starts with '.'. These are made
	 * inaccessible by default since they very often store metadata that is not meant to be served,
	 * e.g. a git repository or an `.htaccess` file.
	 *
	 * Note that the special links "." and ".." will never be accessible regardless of this setting.
	 *
	 */
	get allowDotfiles(): boolean {
		return $.utils.getBit(1, this, DiskDirectory._capnp.defaultAllowDotfiles);
	}
	set allowDotfiles(value: boolean) {
		$.utils.setBit(1, value, this, DiskDirectory._capnp.defaultAllowDotfiles);
	}
	toString(): string {
		return "DiskDirectory_" + super.toString();
	}
}
export const HttpOptions_Style = {
	/**
	 * Normal HTTP. The request line contains only the path, and the separate `Host` header
	 * specifies the hostname.
	 *
	 */
	HOST: 0,
	/**
	 * HTTP proxy protocol. The request line contains a full URL instead of a path. No `Host`
	 * header is required. This is the protocol used by HTTP forward proxies. This allows you to
	 * implement such a proxy as a Worker.
	 *
	 */
	PROXY: 1,
} as const;
export type HttpOptions_Style =
	(typeof HttpOptions_Style)[keyof typeof HttpOptions_Style];
export class HttpOptions_Header extends $.Struct {
	static readonly _capnp = {
		displayName: "Header",
		id: "dc0394b5a6f3417e",
		size: new $.ObjectSize(0, 2),
	};
	/**
	 * Case-insensitive.
	 *
	 */
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * If null, the header will be removed.
	 *
	 */
	get value(): string {
		return $.utils.getText(1, this);
	}
	set value(value: string) {
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return "HttpOptions_Header_" + super.toString();
	}
}
/**
 * Options for using HTTP (as a client or server). In particular, this specifies behavior that is
 * important in the presence of proxy servers, whether forward or reverse.
 *
 */
export class HttpOptions extends $.Struct {
	static readonly Style = HttpOptions_Style;
	static readonly Header = HttpOptions_Header;
	static readonly _capnp = {
		displayName: "HttpOptions",
		id: "aa8dc6885da78f19",
		size: new $.ObjectSize(8, 5),
		defaultStyle: $.getUint16Mask(0),
	};
	static _InjectRequestHeaders: $.ListCtor<HttpOptions_Header>;
	static _InjectResponseHeaders: $.ListCtor<HttpOptions_Header>;
	get style(): HttpOptions_Style {
		return $.utils.getUint16(
			0,
			this,
			HttpOptions._capnp.defaultStyle
		) as HttpOptions_Style;
	}
	set style(value: HttpOptions_Style) {
		$.utils.setUint16(0, value, this, HttpOptions._capnp.defaultStyle);
	}
	/**
	 * If specified, then when the given header is present on a request, it specifies the protocol
	 * ("http" or "https") that was used by the original client. The request URL reported to the
	 * Worker will reflect this protocol. Otherwise, the URL will reflect the actual physical protocol
	 * used by the server in receiving the request.
	 *
	 * This option is useful when this server sits behind a reverse proxy that performs TLS
	 * termination. Typically such proxies forward the original protocol in a header named something
	 * like "X-Forwarded-Proto".
	 *
	 * This setting is ignored when `style` is `proxy`.
	 *
	 */
	get forwardedProtoHeader(): string {
		return $.utils.getText(0, this);
	}
	set forwardedProtoHeader(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * If set, then the `request.cf` object will be encoded (as JSON) into / parsed from the header
	 * with this name. Otherwise, it will be discarded on send / `undefined` on receipt.
	 *
	 */
	get cfBlobHeader(): string {
		return $.utils.getText(1, this);
	}
	set cfBlobHeader(value: string) {
		$.utils.setText(1, value, this);
	}
	_adoptInjectRequestHeaders(
		value: $.Orphan<$.List<HttpOptions_Header>>
	): void {
		$.utils.adopt(value, $.utils.getPointer(2, this));
	}
	_disownInjectRequestHeaders(): $.Orphan<$.List<HttpOptions_Header>> {
		return $.utils.disown(this.injectRequestHeaders);
	}
	/**
	 * List of headers which will be automatically injected into all requests. This can be used
	 * e.g. to add an authorization token to all requests when using `ExternalServer`. It can also
	 * apply to incoming requests received on a `Socket` to modify the headers that will be delivered
	 * to the app. Any existing header with the same name is removed.
	 *
	 */
	get injectRequestHeaders(): $.List<HttpOptions_Header> {
		return $.utils.getList(2, HttpOptions._InjectRequestHeaders, this);
	}
	_hasInjectRequestHeaders(): boolean {
		return !$.utils.isNull($.utils.getPointer(2, this));
	}
	_initInjectRequestHeaders(length: number): $.List<HttpOptions_Header> {
		return $.utils.initList(2, HttpOptions._InjectRequestHeaders, length, this);
	}
	set injectRequestHeaders(value: $.List<HttpOptions_Header>) {
		$.utils.copyFrom(value, $.utils.getPointer(2, this));
	}
	_adoptInjectResponseHeaders(
		value: $.Orphan<$.List<HttpOptions_Header>>
	): void {
		$.utils.adopt(value, $.utils.getPointer(3, this));
	}
	_disownInjectResponseHeaders(): $.Orphan<$.List<HttpOptions_Header>> {
		return $.utils.disown(this.injectResponseHeaders);
	}
	/**
	 * Same as `injectRequestHeaders` but for responses.
	 *
	 */
	get injectResponseHeaders(): $.List<HttpOptions_Header> {
		return $.utils.getList(3, HttpOptions._InjectResponseHeaders, this);
	}
	_hasInjectResponseHeaders(): boolean {
		return !$.utils.isNull($.utils.getPointer(3, this));
	}
	_initInjectResponseHeaders(length: number): $.List<HttpOptions_Header> {
		return $.utils.initList(
			3,
			HttpOptions._InjectResponseHeaders,
			length,
			this
		);
	}
	set injectResponseHeaders(value: $.List<HttpOptions_Header>) {
		$.utils.copyFrom(value, $.utils.getPointer(3, this));
	}
	/**
	 * A CONNECT request for this host+port will be treated as a request to form a Cap'n Proto RPC
	 * connection. The server will expose a WorkerdBootstrap as the bootstrap interface, allowing
	 * events to be delivered to the target worker via capnp. Clients will use capnp for non-HTTP
	 * event types (especially JSRPC).
	 *
	 */
	get capnpConnectHost(): string {
		return $.utils.getText(4, this);
	}
	set capnpConnectHost(value: string) {
		$.utils.setText(4, value, this);
	}
	toString(): string {
		return "HttpOptions_" + super.toString();
	}
}
export class TlsOptions_Keypair extends $.Struct {
	static readonly _capnp = {
		displayName: "Keypair",
		id: "f546bf2d5d8bd13e",
		size: new $.ObjectSize(0, 2),
	};
	/**
	 * Private key in PEM format. Supports PKCS8 keys as well as "traditional format" RSA and DSA
	 * keys.
	 *
	 * Remember that you can use Cap'n Proto's `embed` syntax to reference an external file.
	 *
	 */
	get privateKey(): string {
		return $.utils.getText(0, this);
	}
	set privateKey(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * Certificate chain in PEM format. A chain can be constructed by concatenating multiple
	 * PEM-encoded certificates, starting with the leaf certificate.
	 *
	 */
	get certificateChain(): string {
		return $.utils.getText(1, this);
	}
	set certificateChain(value: string) {
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return "TlsOptions_Keypair_" + super.toString();
	}
}
export const TlsOptions_Version = {
	/**
	 * A good default chosen by the code maintainers. May change over time.
	 *
	 */
	GOOD_DEFAULT: 0,
	SSL3: 1,
	TLS1DOT0: 2,
	TLS1DOT1: 3,
	TLS1DOT2: 4,
	TLS1DOT3: 5,
} as const;
export type TlsOptions_Version =
	(typeof TlsOptions_Version)[keyof typeof TlsOptions_Version];
/**
 * Options that apply when using TLS. Can apply on either the client or the server side, depending
 * on the context.
 *
 * This is based on KJ's TlsContext::Options.
 *
 */
export class TlsOptions extends $.Struct {
	static readonly Keypair = TlsOptions_Keypair;
	static readonly Version = TlsOptions_Version;
	static readonly _capnp = {
		displayName: "TlsOptions",
		id: "aabb3c3778ac4311",
		size: new $.ObjectSize(8, 3),
		defaultRequireClientCerts: $.getBitMask(false, 0),
		defaultTrustBrowserCas: $.getBitMask(false, 1),
		defaultMinVersion: $.getUint16Mask(0),
	};
	_adoptKeypair(value: $.Orphan<TlsOptions_Keypair>): void {
		$.utils.adopt(value, $.utils.getPointer(0, this));
	}
	_disownKeypair(): $.Orphan<TlsOptions_Keypair> {
		return $.utils.disown(this.keypair);
	}
	/**
	 * The default private key and certificate to use. Optional when acting as a client.
	 *
	 */
	get keypair(): TlsOptions_Keypair {
		return $.utils.getStruct(0, TlsOptions_Keypair, this);
	}
	_hasKeypair(): boolean {
		return !$.utils.isNull($.utils.getPointer(0, this));
	}
	_initKeypair(): TlsOptions_Keypair {
		return $.utils.initStructAt(0, TlsOptions_Keypair, this);
	}
	set keypair(value: TlsOptions_Keypair) {
		$.utils.copyFrom(value, $.utils.getPointer(0, this));
	}
	/**
	 * If true, then when acting as a server, incoming connections will be rejected unless they bear
	 * a certificate signed by one of the trusted CAs.
	 *
	 * Typically, when using this, you'd set `trustBrowserCas = false` and list a specific private CA
	 * in `trustedCertificates`.
	 *
	 */
	get requireClientCerts(): boolean {
		return $.utils.getBit(0, this, TlsOptions._capnp.defaultRequireClientCerts);
	}
	set requireClientCerts(value: boolean) {
		$.utils.setBit(0, value, this, TlsOptions._capnp.defaultRequireClientCerts);
	}
	/**
	 * If true, trust certificates which are signed by one of the CAs that browsers normally trust.
	 * You should typically set this true when talking to the public internet, but you may want to
	 * set it false when talking to servers on your internal network.
	 *
	 */
	get trustBrowserCas(): boolean {
		return $.utils.getBit(1, this, TlsOptions._capnp.defaultTrustBrowserCas);
	}
	set trustBrowserCas(value: boolean) {
		$.utils.setBit(1, value, this, TlsOptions._capnp.defaultTrustBrowserCas);
	}
	_adoptTrustedCertificates(value: $.Orphan<$.List<string>>): void {
		$.utils.adopt(value, $.utils.getPointer(1, this));
	}
	_disownTrustedCertificates(): $.Orphan<$.List<string>> {
		return $.utils.disown(this.trustedCertificates);
	}
	/**
	 * Additional CA certificates to trust, in PEM format. Remember that you can use Cap'n Proto's
	 * `embed` syntax to read the certificates from other files.
	 *
	 */
	get trustedCertificates(): $.List<string> {
		return $.utils.getList(1, $.TextList, this);
	}
	_hasTrustedCertificates(): boolean {
		return !$.utils.isNull($.utils.getPointer(1, this));
	}
	_initTrustedCertificates(length: number): $.List<string> {
		return $.utils.initList(1, $.TextList, length, this);
	}
	set trustedCertificates(value: $.List<string>) {
		$.utils.copyFrom(value, $.utils.getPointer(1, this));
	}
	/**
	 * Minimum TLS version that will be allowed. Generally you should not override this unless you
	 * have unusual backwards-compatibility needs.
	 *
	 */
	get minVersion(): TlsOptions_Version {
		return $.utils.getUint16(
			2,
			this,
			TlsOptions._capnp.defaultMinVersion
		) as TlsOptions_Version;
	}
	set minVersion(value: TlsOptions_Version) {
		$.utils.setUint16(2, value, this, TlsOptions._capnp.defaultMinVersion);
	}
	/**
	 * OpenSSL cipher list string. The default is a curated list designed to be compatible with
	 * almost all software in current use (specifically, based on Mozilla's "intermediate"
	 * recommendations). The defaults will change in future versions of this software to account
	 * for the latest cryptanalysis.
	 *
	 * Generally you should only specify your own `cipherList` if:
	 * - You have extreme backwards-compatibility needs and wish to enable obsolete and/or broken
	 *   algorithms.
	 * - You need quickly to disable an algorithm recently discovered to be broken.
	 *
	 */
	get cipherList(): string {
		return $.utils.getText(2, this);
	}
	set cipherList(value: string) {
		$.utils.setText(2, value, this);
	}
	toString(): string {
		return "TlsOptions_" + super.toString();
	}
}
/**
 * A module extending workerd functionality.
 *
 */
export class Extension_Module extends $.Struct {
	static readonly _capnp = {
		displayName: "Module",
		id: "d5d16e76fdedc37d",
		size: new $.ObjectSize(8, 2),
		defaultInternal: $.getBitMask(false, 0),
	};
	/**
	 * Full js module name.
	 *
	 */
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	/**
	 * Internal modules can be imported by other extension modules only and not the user code.
	 *
	 */
	get internal(): boolean {
		return $.utils.getBit(0, this, Extension_Module._capnp.defaultInternal);
	}
	set internal(value: boolean) {
		$.utils.setBit(0, value, this, Extension_Module._capnp.defaultInternal);
	}
	/**
	 * Raw source code of ES module.
	 *
	 */
	get esModule(): string {
		return $.utils.getText(1, this);
	}
	set esModule(value: string) {
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return "Extension_Module_" + super.toString();
	}
}
/**
 * Additional capabilities for workers.
 *
 */
export class Extension extends $.Struct {
	static readonly Module = Extension_Module;
	static readonly _capnp = {
		displayName: "Extension",
		id: "e390128a861973a6",
		size: new $.ObjectSize(0, 1),
	};
	static _Modules: $.ListCtor<Extension_Module>;
	_adoptModules(value: $.Orphan<$.List<Extension_Module>>): void {
		$.utils.adopt(value, $.utils.getPointer(0, this));
	}
	_disownModules(): $.Orphan<$.List<Extension_Module>> {
		return $.utils.disown(this.modules);
	}
	/**
	 * List of javascript modules provided by the extension.
	 * These modules can either be imported directly as user-level api (if not marked internal)
	 * or used to define more complicated workerd constructs such as wrapped bindings and events.
	 *
	 */
	get modules(): $.List<Extension_Module> {
		return $.utils.getList(0, Extension._Modules, this);
	}
	_hasModules(): boolean {
		return !$.utils.isNull($.utils.getPointer(0, this));
	}
	_initModules(length: number): $.List<Extension_Module> {
		return $.utils.initList(0, Extension._Modules, length, this);
	}
	set modules(value: $.List<Extension_Module>) {
		$.utils.copyFrom(value, $.utils.getPointer(0, this));
	}
	toString(): string {
		return "Extension_" + super.toString();
	}
}
export class FallbackServiceRequest_Attribute extends $.Struct {
	static readonly _capnp = {
		displayName: "Attribute",
		id: "ecfe563249c01f75",
		size: new $.ObjectSize(0, 2),
	};
	get name(): string {
		return $.utils.getText(0, this);
	}
	set name(value: string) {
		$.utils.setText(0, value, this);
	}
	get value(): string {
		return $.utils.getText(1, this);
	}
	set value(value: string) {
		$.utils.setText(1, value, this);
	}
	toString(): string {
		return "FallbackServiceRequest_Attribute_" + super.toString();
	}
}
export class FallbackServiceRequest extends $.Struct {
	static readonly Attribute = FallbackServiceRequest_Attribute;
	static readonly _capnp = {
		displayName: "FallbackServiceRequest",
		id: "daf79e36b3f32800",
		size: new $.ObjectSize(0, 5),
	};
	static _Attributes: $.ListCtor<FallbackServiceRequest_Attribute>;
	get type(): string {
		return $.utils.getText(0, this);
	}
	set type(value: string) {
		$.utils.setText(0, value, this);
	}
	get specifier(): string {
		return $.utils.getText(1, this);
	}
	set specifier(value: string) {
		$.utils.setText(1, value, this);
	}
	get rawSpecifier(): string {
		return $.utils.getText(2, this);
	}
	set rawSpecifier(value: string) {
		$.utils.setText(2, value, this);
	}
	get referrer(): string {
		return $.utils.getText(3, this);
	}
	set referrer(value: string) {
		$.utils.setText(3, value, this);
	}
	_adoptAttributes(
		value: $.Orphan<$.List<FallbackServiceRequest_Attribute>>
	): void {
		$.utils.adopt(value, $.utils.getPointer(4, this));
	}
	_disownAttributes(): $.Orphan<$.List<FallbackServiceRequest_Attribute>> {
		return $.utils.disown(this.attributes);
	}
	get attributes(): $.List<FallbackServiceRequest_Attribute> {
		return $.utils.getList(4, FallbackServiceRequest._Attributes, this);
	}
	_hasAttributes(): boolean {
		return !$.utils.isNull($.utils.getPointer(4, this));
	}
	_initAttributes(length: number): $.List<FallbackServiceRequest_Attribute> {
		return $.utils.initList(
			4,
			FallbackServiceRequest._Attributes,
			length,
			this
		);
	}
	set attributes(value: $.List<FallbackServiceRequest_Attribute>) {
		$.utils.copyFrom(value, $.utils.getPointer(4, this));
	}
	toString(): string {
		return "FallbackServiceRequest_" + super.toString();
	}
}
Config._Services = $.CompositeList(Service);
Config._Sockets = $.CompositeList(Socket);
Config._Extensions = $.CompositeList(Extension);
Worker_Binding_WrappedBinding._InnerBindings = $.CompositeList(Worker_Binding);
Worker._Modules = $.CompositeList(Worker_Module);
Worker._Bindings = $.CompositeList(Worker_Binding);
Worker._DurableObjectNamespaces = $.CompositeList(
	Worker_DurableObjectNamespace
);
Worker._Tails = $.CompositeList(ServiceDesignator);
Worker._StreamingTails = $.CompositeList(ServiceDesignator);
HttpOptions._InjectRequestHeaders = $.CompositeList(HttpOptions_Header);
HttpOptions._InjectResponseHeaders = $.CompositeList(HttpOptions_Header);
Extension._Modules = $.CompositeList(Extension_Module);
FallbackServiceRequest._Attributes = $.CompositeList(
	FallbackServiceRequest_Attribute
);
