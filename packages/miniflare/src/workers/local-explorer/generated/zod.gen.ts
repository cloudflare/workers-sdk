// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zD1QueryMeta = z.object({
	changed_db: z.boolean().optional(),
	changes: z.number().optional(),
	duration: z.number().optional(),
	last_row_id: z.number().optional(),
	rows_read: z.number().optional(),
	rows_written: z.number().optional(),
	size_after: z.number().optional(),
	timings: z
		.object({
			sql_duration_ms: z.number().optional(),
		})
		.optional(),
});

export const zD1RawResultResponse = z.object({
	meta: zD1QueryMeta.optional(),
	results: z
		.object({
			columns: z.array(z.string()).optional(),
			rows: z
				.array(
					z.array(z.union([z.number(), z.string(), z.record(z.unknown())]))
				)
				.optional(),
		})
		.optional(),
	success: z.boolean().optional(),
});

/**
 * Your SQL query. Supports multiple statements, joined by semicolons, which will be executed as a batch.
 */
export const zD1Sql = z.string();

export const zD1Params = z.array(z.string());

/**
 * single query
 *
 * A single query with or without parameters
 */
export const zD1SingleQuery = z.object({
	params: zD1Params.optional(),
	sql: zD1Sql,
});

/**
 * A single query object or a batch query object
 */
export const zD1BatchQuery = z.union([
	zD1SingleQuery,
	z.object({
		batch: z.array(zD1SingleQuery),
	}),
]);

/**
 * D1 database identifier (UUID).
 */
export const zD1DatabaseIdentifier = z.string().readonly();

export const zD1Messages = z.array(
	z.object({
		code: z.number().int().gte(1000),
		message: z.string(),
	})
);

export const zD1ApiResponseCommonFailure = z.object({
	errors: zD1Messages,
	messages: zD1Messages,
	result: z.unknown(),
	success: z.literal(false),
});

export const zD1DatabaseVersion = z.string().regex(/^(alpha|beta|production)$/);

/**
 * D1 database name.
 */
export const zD1DatabaseName = z.string().regex(/^[a-zA-Z0-9][a-zA-Z0-9_-]*$/);

export const zD1DatabaseResponse = z.object({
	name: zD1DatabaseName.optional(),
	uuid: zD1DatabaseIdentifier.optional(),
	version: zD1DatabaseVersion.optional(),
});

export const zD1ApiResponseCommon = z.object({
	errors: zD1Messages,
	messages: zD1Messages,
	success: z.literal(true),
});

export const zWorkersKvAny: z.ZodTypeAny = z.union([
	z.string(),
	z.number(),
	z.number().int(),
	z.boolean(),
	z.union([z.record(z.unknown()), z.null()]),
	z.array(z.lazy(() => zWorkersKvAny)),
]);

/**
 * Expires the key at a certain time, measured in number of seconds since the UNIX epoch.
 */
export const zWorkersKvExpiration = z.number();

export const zWorkersKvBulkGetResultWithMetadata = z.object({
	values: z
		.record(
			z.union([
				z.object({
					expiration: zWorkersKvExpiration.optional(),
					metadata: zWorkersKvAny.and(z.unknown()),
					value: zWorkersKvAny.and(z.unknown()),
				}),
				z.null(),
			])
		)
		.optional(),
});

export const zWorkersKvBulkGetResult = z.object({
	values: z
		.record(
			z.union([
				z.string(),
				z.number(),
				z.boolean(),
				z.record(z.unknown()),
				z.null(),
			])
		)
		.optional(),
});

/**
 * A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid.
 */
export const zWorkersKvKeyNameBulk = z.string().max(512);

export const zWorkersKvMessages = z.array(
	z.object({
		code: z.number().int().gte(1000),
		message: z.string(),
	})
);

export const zWorkersKvApiResponseCommon = z.object({
	errors: zWorkersKvMessages,
	messages: zWorkersKvMessages,
	success: z.literal(true),
});

export const zWorkersKvApiResponseCommonNoResult =
	zWorkersKvApiResponseCommon.and(
		z.object({
			result: z.union([z.record(z.unknown()), z.null()]).optional(),
		})
	);

export const zWorkersKvMetadata = zWorkersKvAny.and(z.unknown());

/**
 * A byte sequence to be stored, up to 25 MiB in length.
 */
export const zWorkersKvValue = z.union([z.string(), z.string()]);

/**
 * A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL.
 */
export const zWorkersKvKeyName = z.string().max(512);

/**
 * Opaque token indicating the position from which to continue when requesting the next set of records if the amount of list results was limited by the limit parameter. A valid value for the cursor can be obtained from the cursors object in the result_info structure.
 */
export const zWorkersKvCursor = z.string();

export const zWorkersKvCursorResultInfo = z.object({
	count: z.number().optional(),
	cursor: zWorkersKvCursor.optional(),
});

export const zWorkersKvListMetadata = zWorkersKvAny.and(z.unknown());

/**
 * A name for a value. A value stored under a given key may be retrieved via the same key.
 */
export const zWorkersKvKey = z.object({
	expiration: z.number().optional(),
	metadata: zWorkersKvListMetadata.optional(),
	name: zWorkersKvKeyName,
});

/**
 * Namespace identifier tag.
 */
export const zWorkersKvNamespaceIdentifier = z.string().max(32).readonly();

export const zWorkersKvApiResponseCommonFailure = z.object({
	errors: zWorkersKvMessages,
	messages: zWorkersKvMessages,
	result: z.union([z.record(z.unknown()), z.null()]),
	success: z.literal(false),
});

/**
 * A human-readable string name for a Namespace.
 */
export const zWorkersKvNamespaceTitle = z.string().max(512);

export const zWorkersKvNamespace = z.object({
	id: zWorkersKvNamespaceIdentifier,
	title: zWorkersKvNamespaceTitle,
});

export const zWorkersKvResultInfo = z.object({
	count: z.number().optional(),
	page: z.number().optional(),
	per_page: z.number().optional(),
	total_count: z.number().optional(),
});

export const zWorkersKvApiResponseCollection = zWorkersKvApiResponseCommon.and(
	z.object({
		result_info: zWorkersKvResultInfo.optional(),
	})
);

export const zD1DatabaseResponseWritable = z.object({
	name: zD1DatabaseName.optional(),
	version: zD1DatabaseVersion.optional(),
});

export const zWorkersKvAnyWritable: z.ZodTypeAny = z.union([
	z.string(),
	z.number(),
	z.number().int(),
	z.boolean(),
	z.union([z.record(z.unknown()), z.null()]),
	z.array(z.lazy(() => zWorkersKvAnyWritable)),
]);

export const zWorkersKvMetadataWritable = zWorkersKvAnyWritable.and(
	z.unknown()
);

export const zWorkersKvListMetadataWritable = zWorkersKvAnyWritable.and(
	z.unknown()
);

export const zWorkersKvNamespaceWritable = z.object({
	title: zWorkersKvNamespaceTitle,
});

export const zWorkersKvNamespaceListNamespacesData = z.object({
	body: z.never().optional(),
	path: z.never().optional(),
	query: z
		.object({
			page: z.number().gte(1).optional().default(1),
			per_page: z.number().gte(1).lte(1000).optional().default(20),
			order: z.enum(["id", "title"]).optional(),
			direction: z.enum(["asc", "desc"]).optional(),
		})
		.optional(),
});

/**
 * List Namespaces response.
 */
export const zWorkersKvNamespaceListNamespacesResponse =
	zWorkersKvApiResponseCollection.and(
		z.object({
			result: z.array(zWorkersKvNamespace).optional(),
		})
	);

export const zWorkersKvNamespaceListANamespaceSKeysData = z.object({
	body: z.never().optional(),
	path: z.object({
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z
		.object({
			limit: z.number().gte(10).lte(1000).optional().default(1000),
			prefix: z.string().optional(),
			cursor: z.string().optional(),
		})
		.optional(),
});

/**
 * List a Namespace's Keys response.
 */
export const zWorkersKvNamespaceListANamespaceSKeysResponse =
	zWorkersKvApiResponseCommon.and(
		z.object({
			result: z.array(zWorkersKvKey).optional(),
			result_info: zWorkersKvCursorResultInfo.optional(),
		})
	);

export const zWorkersKvNamespaceDeleteKeyValuePairData = z.object({
	body: z.unknown(),
	path: z.object({
		key_name: zWorkersKvKeyName,
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.never().optional(),
});

/**
 * Delete key-value pair response.
 */
export const zWorkersKvNamespaceDeleteKeyValuePairResponse =
	zWorkersKvApiResponseCommonNoResult;

export const zWorkersKvNamespaceReadKeyValuePairData = z.object({
	body: z.never().optional(),
	path: z.object({
		key_name: zWorkersKvKeyName,
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.never().optional(),
});

/**
 * Read key-value pair response.
 */
export const zWorkersKvNamespaceReadKeyValuePairResponse = zWorkersKvValue;

export const zWorkersKvNamespaceWriteKeyValuePairWithMetadataData = z.object({
	body: zWorkersKvValue,
	path: z.object({
		key_name: zWorkersKvKeyName,
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.never().optional(),
});

/**
 * Write key-value pair with metadata response.
 */
export const zWorkersKvNamespaceWriteKeyValuePairWithMetadataResponse =
	zWorkersKvApiResponseCommonNoResult;

export const zWorkersKvNamespaceGetMultipleKeyValuePairsData = z.object({
	body: z.object({
		keys: z.array(zWorkersKvKeyNameBulk).max(100),
	}),
	path: z.object({
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.never().optional(),
});

/**
 * Get multiple key-value pairs response.
 */
export const zWorkersKvNamespaceGetMultipleKeyValuePairsResponse =
	zWorkersKvApiResponseCommonNoResult.and(
		z.object({
			result: z
				.union([zWorkersKvBulkGetResult, zWorkersKvBulkGetResultWithMetadata])
				.optional(),
		})
	);

export const zCloudflareD1ListDatabasesData = z.object({
	body: z.never().optional(),
	path: z.never().optional(),
	query: z
		.object({
			name: z.string().optional(),
			page: z.number().gte(1).optional().default(1),
			per_page: z.number().gte(10).lte(10000).optional().default(1000),
		})
		.optional(),
});

/**
 * List D1 databases response
 */
export const zCloudflareD1ListDatabasesResponse = zD1ApiResponseCommon.and(
	z.object({
		result: z.array(zD1DatabaseResponse).optional(),
		result_info: z
			.object({
				count: z.number().optional(),
				page: z.number().optional(),
				per_page: z.number().optional(),
				total_count: z.number().optional(),
			})
			.optional(),
	})
);

export const zCloudflareD1RawDatabaseQueryData = z.object({
	body: zD1BatchQuery,
	path: z.object({
		database_id: zD1DatabaseIdentifier,
	}),
	query: z.never().optional(),
});

/**
 * Raw query response
 */
export const zCloudflareD1RawDatabaseQueryResponse = zD1ApiResponseCommon.and(
	z.object({
		result: z.array(zD1RawResultResponse).optional(),
	})
);
