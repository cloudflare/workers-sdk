// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zWorkersKvAny = z.union([
	z.string(),
	z.number(),
	z.int(),
	z.boolean(),
	z.union([z.record(z.string(), z.unknown()), z.null()]),
	z.array(z.lazy((): any => zWorkersKvAny)),
]);

/**
 * Expires the key at a certain time, measured in number of seconds since the UNIX epoch.
 */
export const zWorkersKvExpiration = z.number();

export const zWorkersKvBulkGetResultWithMetadata = z.object({
	values: z.optional(
		z.record(
			z.string(),
			z.union([
				z.object({
					expiration: z.optional(zWorkersKvExpiration),
					metadata: zWorkersKvAny.and(z.unknown()),
					value: zWorkersKvAny.and(z.unknown()),
				}),
				z.null(),
			])
		)
	),
});

export const zWorkersKvBulkGetResult = z.object({
	values: z.optional(
		z.record(
			z.string(),
			z.union([
				z.string(),
				z.number(),
				z.boolean(),
				z.record(z.string(), z.unknown()),
				z.null(),
			])
		)
	),
});

/**
 * A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid.
 */
export const zWorkersKvKeyNameBulk = z.string().max(512);

export const zWorkersKvMessages = z.array(
	z.object({
		code: z.int().gte(1000),
		message: z.string(),
	})
);

export const zWorkersKvApiResponseCommon = z.object({
	errors: zWorkersKvMessages,
	messages: zWorkersKvMessages,
	success: z.literal(true),
});

export const zWorkersKvApiResponseCommonNoResult =
	zWorkersKvApiResponseCommon.and(
		z.object({
			result: z.optional(
				z.union([z.record(z.string(), z.unknown()), z.null()])
			),
		})
	);

export const zWorkersKvMetadata = zWorkersKvAny.and(z.unknown());

/**
 * A byte sequence to be stored, up to 25 MiB in length.
 */
export const zWorkersKvValue = z.union([z.string(), z.string()]);

/**
 * A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL.
 */
export const zWorkersKvKeyName = z.string().max(512);

/**
 * Opaque token indicating the position from which to continue when requesting the next set of records if the amount of list results was limited by the limit parameter. A valid value for the cursor can be obtained from the cursors object in the result_info structure.
 */
export const zWorkersKvCursor = z.string();

export const zWorkersKvListMetadata = zWorkersKvAny.and(z.unknown());

/**
 * A name for a value. A value stored under a given key may be retrieved via the same key.
 */
export const zWorkersKvKey = z.object({
	expiration: z.optional(z.number()),
	metadata: z.optional(zWorkersKvListMetadata),
	name: zWorkersKvKeyName,
});

/**
 * Namespace identifier tag.
 */
export const zWorkersKvNamespaceIdentifier = z.string().max(32).readonly();

export const zWorkersKvApiResponseCommonFailure = z.object({
	errors: zWorkersKvMessages,
	messages: zWorkersKvMessages,
	result: z.union([z.record(z.string(), z.unknown()), z.null()]),
	success: z.literal(false),
});

/**
 * A human-readable string name for a Namespace.
 */
export const zWorkersKvNamespaceTitle = z.string().max(512);

export const zWorkersKvNamespace = z.object({
	id: zWorkersKvNamespaceIdentifier,
	title: zWorkersKvNamespaceTitle,
});

export const zWorkersKvResultInfo = z.object({
	count: z.optional(z.number()),
	page: z.optional(z.number()),
	per_page: z.optional(z.number()),
	total_count: z.optional(z.number()),
});

export const zWorkersKvApiResponseCollection = zWorkersKvApiResponseCommon.and(
	z.object({
		result_info: z.optional(zWorkersKvResultInfo),
	})
);

export const zWorkersKvAnyWritable = z.union([
	z.string(),
	z.number(),
	z.int(),
	z.boolean(),
	z.union([z.record(z.string(), z.unknown()), z.null()]),
	z.array(z.lazy((): any => zWorkersKvAnyWritable)),
]);

export const zWorkersKvMetadataWritable = zWorkersKvAnyWritable.and(
	z.unknown()
);

export const zWorkersKvListMetadataWritable = zWorkersKvAnyWritable.and(
	z.unknown()
);

export const zWorkersKvNamespaceWritable = z.object({
	title: zWorkersKvNamespaceTitle,
});

export const zWorkersKvNamespaceListNamespacesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			page: z.optional(z.number().gte(1)).default(1),
			per_page: z.optional(z.number().gte(1).lte(1000)).default(20),
			order: z.optional(z.enum(["id", "title"])),
			direction: z.optional(z.enum(["asc", "desc"])),
		})
	),
});

/**
 * List Namespaces response.
 */
export const zWorkersKvNamespaceListNamespacesResponse =
	zWorkersKvApiResponseCollection.and(
		z.object({
			result: z.optional(z.array(zWorkersKvNamespace)),
		})
	);

export const zWorkersKvNamespaceListANamespaceSKeysData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.optional(
		z.object({
			limit: z.optional(z.number().gte(10).lte(1000)).default(1000),
			cursor: z.optional(z.string()),
		})
	),
});

/**
 * List a Namespace's Keys response.
 */
export const zWorkersKvNamespaceListANamespaceSKeysResponse =
	zWorkersKvApiResponseCommon.and(
		z.object({
			result: z.optional(z.array(zWorkersKvKey)),
			result_info: z.optional(
				z.object({
					count: z.optional(z.number()),
					cursor: z.optional(zWorkersKvCursor),
				})
			),
		})
	);

export const zWorkersKvNamespaceDeleteKeyValuePairData = z.object({
	body: z.unknown(),
	path: z.object({
		key_name: zWorkersKvKeyName,
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.optional(z.never()),
});

/**
 * Delete key-value pair response.
 */
export const zWorkersKvNamespaceDeleteKeyValuePairResponse =
	zWorkersKvApiResponseCommonNoResult;

export const zWorkersKvNamespaceReadKeyValuePairData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		key_name: zWorkersKvKeyName,
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.optional(z.never()),
});

/**
 * Read key-value pair response.
 */
export const zWorkersKvNamespaceReadKeyValuePairResponse = zWorkersKvValue;

export const zWorkersKvNamespaceWriteKeyValuePairWithMetadataData = z.object({
	body: zWorkersKvValue,
	path: z.object({
		key_name: zWorkersKvKeyName,
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.optional(z.never()),
});

/**
 * Write key-value pair with metadata response.
 */
export const zWorkersKvNamespaceWriteKeyValuePairWithMetadataResponse =
	zWorkersKvApiResponseCommonNoResult;

export const zWorkersKvNamespaceGetMultipleKeyValuePairsData = z.object({
	body: z.object({
		keys: z.array(zWorkersKvKeyNameBulk).max(100),
	}),
	path: z.object({
		namespace_id: zWorkersKvNamespaceIdentifier,
	}),
	query: z.optional(z.never()),
});

/**
 * Get multiple key-value pairs response.
 */
export const zWorkersKvNamespaceGetMultipleKeyValuePairsResponse =
	zWorkersKvApiResponseCommonNoResult.and(
		z.object({
			result: z.optional(
				z.union([zWorkersKvBulkGetResult, zWorkersKvBulkGetResultWithMetadata])
			),
		})
	);
