import TOML from "@iarna/toml";
import { existsSync } from "node:fs";
import path from "node:path";
import { prompt, select } from "../dialogs";
import { FatalError, UserError } from "../errors";
import { logger } from "../logger";
import { EXIT_CODE_INVALID_PAGES_CONFIG } from "../pages/errors";
import { parseJSONC, parseTOML, readFileSync } from "../parse";
import { friendlyBindingNames } from "../utils/print-bindings";
import { resolveWranglerConfigPath } from "./config-helpers";
import { experimental_patchConfig } from "./patch-config";
import { isPagesConfig, normalizeAndValidateConfig } from "./validation";
import { validatePagesConfig } from "./validation-pages";
import type { CfWorkerInit } from "../deployment-bundle/worker";
import type { CommonYargsOptions } from "../yargs-types";
import type { Config, OnlyCamelCase, RawConfig } from "./config";
import type { ResolveConfigPathOptions } from "./config-helpers";
import type { NormalizeAndValidateConfigArgs } from "./validation";

export type {
	Config,
	ConfigFields,
	DevConfig,
	RawConfig,
	RawDevConfig,
} from "./config";
export type {
	ConfigModuleRuleType,
	Environment,
	RawEnvironment,
} from "./environment";

export function configFormat(
	configPath: string | undefined
): "jsonc" | "toml" | "none" {
	if (configPath?.endsWith("toml")) {
		return "toml";
	} else if (configPath?.endsWith("json") || configPath?.endsWith("jsonc")) {
		return "jsonc";
	}
	return "none";
}

export function configFileName(configPath: string | undefined) {
	const format = configFormat(configPath);
	if (format === "toml") {
		return "wrangler.toml";
	} else if (format === "jsonc") {
		return "wrangler.json";
	} else {
		return "Wrangler configuration";
	}
}

export function formatConfigSnippet(
	snippet: RawConfig,
	configPath: Config["configPath"],
	formatted = true
) {
	const format = configFormat(configPath);
	if (format === "toml") {
		return TOML.stringify(snippet as TOML.JsonMap);
	} else {
		return formatted
			? JSON.stringify(snippet, null, 2)
			: JSON.stringify(snippet);
	}
}

export async function updateConfigFile(
	snippet: (
		bindingName?: string
	) => Partial<{ [K in keyof CfWorkerInit["bindings"]]: RawConfig[K] }>,
	configPath: Config["configPath"],
	env: string | undefined,
	offerToUpdate: boolean = true
) {
	const resource = Object.keys(snippet())[0] as keyof CfWorkerInit["bindings"];
	const envString = env ? ` in the "${env}" environment` : "";
	logger.log(
		`To access your new ${friendlyBindingNames[resource]} in your Worker, add the following snippet to your configuration file${envString}:`
	);

	logger.log(formatConfigSnippet(snippet(), configPath));

	if (configPath && offerToUpdate && configFormat(configPath) === "jsonc") {
		const autoAdd = await select(
			"Would you like Wrangler to add it on your behalf?",
			{
				choices: [
					{ title: "Yes", value: "yes" },
					{
						title: "Yes, but let me choose the binding name",
						value: "yes-but",
					},
					{ title: "No", value: "no" },
				],
				defaultOption: 0,
				fallbackOption: 2,
			}
		);
		let bindingName;

		if (autoAdd === "yes-but") {
			bindingName = await prompt("What binding name would you like to use?");
		}

		if (autoAdd !== "no") {
			experimental_patchConfig(
				configPath,
				env ? { env: { [env]: snippet(bindingName) } } : snippet(bindingName),
				true
			);
		}
	}
}

export type ReadConfigCommandArgs = NormalizeAndValidateConfigArgs & {
	config?: string;
	script?: string;
};

export type ReadConfigOptions = ResolveConfigPathOptions & {
	hideWarnings?: boolean;
	// Used by the Vite plugin
	// If set to `true`, the `main` field is not converted to an absolute path
	preserveOriginalMain?: boolean;
};

export type ConfigBindingOptions = Pick<
	Config,
	| "ai"
	| "browser"
	| "d1_databases"
	| "dispatch_namespaces"
	| "durable_objects"
	| "queues"
	| "r2_buckets"
	| "services"
	| "kv_namespaces"
	| "mtls_certificates"
	| "vectorize"
	| "workflows"
	| "vpc_services"
>;

// Enhanced interface for auto-generated configs
export interface ConfigWithMetadata extends Config {
	_autoGenerated?: boolean;
	_framework?: string;
}

// Simple framework detection integration
export async function ensureConfigExists(
	configPath: string | undefined,
	interactive: boolean = false
): Promise<{ config: Config; configPath: string; wasGenerated: boolean }> {
	// Check if config already exists
	if (configPath && existsSync(configPath)) {
		const config = readConfig({ config: configPath });
		return { config, configPath, wasGenerated: false };
	}

	// Check for config in default locations
	const defaultPaths = ['wrangler.toml', 'wrangler.json', 'wrangler.jsonc'];
	const projectRoot = configPath ? path.dirname(configPath) : process.cwd();
	
	for (const defaultPath of defaultPaths) {
		const fullPath = path.join(projectRoot, defaultPath);
		if (existsSync(fullPath)) {
			const config = readConfig({ config: fullPath });
			return { config, configPath: fullPath, wasGenerated: false };
		}
	}

	// No config found, try framework detection and auto-generation
	logger.debug("No configuration found, attempting framework detection...");
	
	try {
		// Dynamic import to avoid circular dependencies
		const { FrameworkDetector } = await import("../framework-detection");
		const { ConfigGenerator } = await import("./auto-generate");
		
		const detector = new FrameworkDetector(projectRoot);
		const detection = await detector.detect();
		
		if (!detection) {
			throw new Error(
				"No configuration file found and unable to detect framework. " +
				"Please create a wrangler.jsonc file or ensure your project uses a supported framework."
			);
		}

		const generator = new ConfigGenerator(projectRoot);
		const projectName = await getProjectName(projectRoot);
		const generated = await generator.generateConfig(detection.framework, projectName);

		const config = readConfig({ config: generated.configPath });
		
		// Mark as auto-generated
		(config as ConfigWithMetadata)._autoGenerated = true;
		(config as ConfigWithMetadata)._framework = detection.framework.name;

		return { 
			config, 
			configPath: generated.configPath, 
			wasGenerated: true 
		};
	} catch (error) {
		throw new Error(
			"No configuration file found and unable to detect framework. " +
			"Please create a wrangler.jsonc file or ensure your project uses a supported framework."
		);
	}
}

async function getProjectName(projectRoot: string): Promise<string> {
	try {
		const packageJsonPath = path.join(projectRoot, 'package.json');
		if (existsSync(packageJsonPath)) {
			const packageJson = JSON.parse(readFileSync(packageJsonPath));
			if (packageJson.name) {
				return packageJson.name.toLowerCase().replace(/[^a-z0-9-]/g, '-');
			}
		}
	} catch {
		// Ignore errors
	}
	
	// Fallback to directory name
	const dirName = path.basename(projectRoot);
	return dirName.toLowerCase().replace(/[^a-z0-9-]/g, '-') || 'my-worker';
}

/**
 * Get the Wrangler configuration; read it from the give `configPath` if available.
 */
export function readConfig(
	args: ReadConfigCommandArgs,
	options: ReadConfigOptions = {}
): Config {
	const { rawConfig, configPath, userConfigPath } = experimental_readRawConfig(
		args,
		options
	);

	const { config, diagnostics } = normalizeAndValidateConfig(
		rawConfig,
		configPath,
		userConfigPath,
		args,
		options.preserveOriginalMain
	);

	if (diagnostics.hasWarnings() && !options?.hideWarnings) {
		logger.warn(diagnostics.renderWarnings());
	}
	if (diagnostics.hasErrors()) {
		throw new UserError(diagnostics.renderErrors());
	}

	return config;
}

export function readPagesConfig(
	args: ReadConfigCommandArgs,
	options: ReadConfigOptions = {}
): Omit<Config, "pages_build_output_dir"> & { pages_build_output_dir: string } {
	let rawConfig: RawConfig;
	let configPath: string | undefined;
	let userConfigPath: string | undefined;
	try {
		({ rawConfig, configPath, userConfigPath } = experimental_readRawConfig(
			args,
			options
		));
	} catch (e) {
		logger.error(e);
		throw new FatalError(
			`Your ${configFileName(configPath)} file is not a valid Pages configuration file`,
			EXIT_CODE_INVALID_PAGES_CONFIG
		);
	}

	if (!isPagesConfig(rawConfig)) {
		throw new FatalError(
			`Your ${configFileName(configPath)} file is not a valid Pages configuration file`,
			EXIT_CODE_INVALID_PAGES_CONFIG
		);
	}

	const { config, diagnostics } = normalizeAndValidateConfig(
		rawConfig,
		configPath,
		userConfigPath,
		args
	);

	if (diagnostics.hasWarnings() && !options.hideWarnings) {
		logger.warn(diagnostics.renderWarnings());
	}
	if (diagnostics.hasErrors()) {
		throw new UserError(diagnostics.renderErrors());
	}

	logger.debug(
		`Configuration file belonging to ⚡️ Pages ⚡️ project detected.`
	);

	const envNames = rawConfig.env ? Object.keys(rawConfig.env) : [];
	const projectName = rawConfig?.name;
	const pagesDiagnostics = validatePagesConfig(config, envNames, projectName);

	if (pagesDiagnostics.hasWarnings()) {
		logger.warn(pagesDiagnostics.renderWarnings());
	}
	if (pagesDiagnostics.hasErrors()) {
		throw new UserError(pagesDiagnostics.renderErrors());
	}

	return config as Omit<Config, "pages_build_output_dir"> & {
		pages_build_output_dir: string;
	};
}

export const parseRawConfigFile = (configPath: string): RawConfig => {
	if (configPath.endsWith(".toml")) {
		return parseTOML(readFileSync(configPath), configPath);
	}

	if (configPath.endsWith(".json") || configPath.endsWith(".jsonc")) {
		return parseJSONC(readFileSync(configPath), configPath) as RawConfig;
	}

	return {};
};

export const experimental_readRawConfig = (
	args: ReadConfigCommandArgs,
	options: ReadConfigOptions = {}
): {
	rawConfig: RawConfig;
	configPath: string | undefined;
	userConfigPath: string | undefined;
} => {
	// Load the configuration from disk if available
	const { configPath, userConfigPath } = resolveWranglerConfigPath(
		args,
		options
	);

	const rawConfig = parseRawConfigFile(configPath ?? "");

	return { rawConfig, configPath, userConfigPath };
};

export function withConfig<T>(
	handler: (
		args: OnlyCamelCase<T & CommonYargsOptions> & { config: Config }
	) => Promise<void>,
	options?: Parameters<typeof readConfig>[1]
) {
	return (args: OnlyCamelCase<T & CommonYargsOptions>) => {
		return handler({ ...args, config: readConfig(args, options) });
	};
}

// Simple exports for auto-generation (will be implemented separately)
export class ConfigGenerator {
	constructor(private projectRoot: string) {}
	async generateConfig(framework: any, projectName: string): Promise<any> {
		return null; // Placeholder
	}
}

export async function generateConfigNonInteractive(): Promise<any> {
	return null; // Placeholder
}
