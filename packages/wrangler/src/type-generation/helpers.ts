import { readFileSync, writeFileSync } from "node:fs";
import { version } from "workerd";
import { logger } from "../logger";
import { generateRuntimeTypes } from "./runtime";
import { generateEnvTypes } from ".";
import type { Entry } from "../deployment-bundle/entry";
import type { Config } from "@cloudflare/workers-utils";

export const DEFAULT_WORKERS_TYPES_FILE_NAME = "worker-configuration.d.ts";
export const DEFAULT_WORKERS_TYPES_FILE_PATH = `./${DEFAULT_WORKERS_TYPES_FILE_NAME}`;

// Checks the default location for a generated types file and compares if the
// recorded Env hash, workerd version or compat date and flags have changed
// compared to the current values in the config. Prompts user to re-run wrangler
// types if so.
export const checkTypesDiff = async (config: Config, entry: Entry) => {
	if (!entry.file.endsWith(".ts")) {
		return;
	}
	let maybeExistingTypesFileLines: string[];
	try {
		// Checking the default location only
		maybeExistingTypesFileLines = readFileSync(
			DEFAULT_WORKERS_TYPES_FILE_PATH,
			"utf-8"
		).split("\n");
	} catch {
		return;
	}
	const existingEnvHeader = maybeExistingTypesFileLines.find((line) =>
		line.startsWith("// Generated by Wrangler by running")
	);
	const maybeExistingHash =
		existingEnvHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;
	const previousStrictVars = existingEnvHeader?.match(
		/--strict-vars(=|\s)(?<result>true|false)/
	)?.groups?.result;
	const previousEnvInterface = existingEnvHeader?.match(
		/--env-interface(=|\s)(?<result>[a-zA-Z][a-zA-Z0-9_]*)/
	)?.groups?.result;

	let newEnvHeader: string | undefined;
	let newEnvTypes: string | undefined;
	try {
		const { envHeader, envTypes } = await generateEnvTypes(
			config,
			{ strictVars: previousStrictVars === "false" ? false : true },
			previousEnvInterface ?? "Env",
			DEFAULT_WORKERS_TYPES_FILE_NAME,
			entry,
			new Map(),
			// don't log anything
			false
		);
		newEnvHeader = envHeader;
		newEnvTypes = envTypes;
	} catch (e) {
		logger.error(e);
	}

	const newHash = newEnvHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;

	const existingRuntimeHeader = maybeExistingTypesFileLines.find((line) =>
		line.startsWith("// Runtime types generated with")
	);
	const newRuntimeHeader = `// Runtime types generated with workerd@${version} ${config.compatibility_date} ${config.compatibility_flags.sort().join(",")}`;

	const envOutOfDate = existingEnvHeader && maybeExistingHash !== newHash;
	const runtimeOutOfDate =
		existingRuntimeHeader && existingRuntimeHeader !== newRuntimeHeader;

	// Check if the users types have changed since last generation, and if so either prompt them to
	// re-run `wrangler types` or automatically do so for them by enabling `dev.generate_types` or
	// using `wrangler dev --types`.
	const changed = envOutOfDate || runtimeOutOfDate;
	if (!changed) {
		return false;
	}

	if (!config.dev.generate_types) {
		logger.log(
			"❓ Your types might be out of date. Re-run `wrangler types` to ensure your types are correct."
		);
		return true;
	}

	const { runtimeHeader, runtimeTypes } = await generateRuntimeTypes({
		config,
		outFile: DEFAULT_WORKERS_TYPES_FILE_PATH,
	});
	const newTypesFile = [
		newEnvHeader,
		runtimeHeader,
		newEnvTypes,
		runtimeTypes,
	].join("\n");
	try {
		writeFileSync(DEFAULT_WORKERS_TYPES_FILE_PATH, newTypesFile);
		logger.log(
			`❓ Your types looked out of date. We've re-run \`wrangler types\` for you and updated ${DEFAULT_WORKERS_TYPES_FILE_PATH}`
		);
	} catch (e) {
		logger.error(e);
	}

	return true;
};
