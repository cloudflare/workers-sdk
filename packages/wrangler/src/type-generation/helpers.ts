import { readFileSync, writeFileSync } from "node:fs";
import {
	configFileName,
	ParseError,
	UserError,
} from "@cloudflare/workers-utils";
import { version } from "workerd";
import yargs from "yargs";
import { getEntry } from "../deployment-bundle/entry";
import { logger } from "../logger";
import { generateRuntimeTypes } from "./runtime";
import { generateEnvTypes } from ".";
import type { Entry } from "../deployment-bundle/entry";
import type { Config } from "@cloudflare/workers-utils";

export const DEFAULT_WORKERS_TYPES_FILE_NAME = "worker-configuration.d.ts";
export const DEFAULT_WORKERS_TYPES_FILE_PATH = `./${DEFAULT_WORKERS_TYPES_FILE_NAME}`;
export const ENV_HEADER_COMMENT_PREFIX = "// Generated by Wrangler by running";
export const RUNTIME_HEADER_COMMENT_PREFIX =
	"// Runtime types generated with workerd@";

/**
 * Sentinel value used to identify top-level (non-environment) bindings when collecting bindings.
 */
export const TOP_LEVEL_ENV_NAME = "$top-level";

export interface ThrowMissingBindingErrorOptions {
	/** The actual binding object for error context */
	binding: unknown;
	/** The type of binding (e.g., "kv_namespaces", "d1_databases") */
	bindingType: string;
	/** The path to the config file */
	configPath: string | undefined;
	/** The environment name where the invalid binding was found */
	envName: string;
	/** The name of the missing field (e.g., "binding", "name") */
	fieldName: string;
	/** The index of the binding in the array (0-based), or omit for non-array bindings */
	index?: number;
}

/**
 * Throws a UserError when a binding is missing its required property.
 *
 * The error format matches the existing config validation errors for consistency.
 *
 * @param options - The options for constructing the error message
 *
 * @throws {UserError} Always throws with a formatted error message
 */
export const throwMissingBindingError = ({
	binding,
	bindingType,
	configPath,
	envName,
	fieldName,
	index,
}: ThrowMissingBindingErrorOptions): never => {
	const isArrayBinding = index !== undefined;
	const bindingPath = isArrayBinding ? `${bindingType}[${index}]` : bindingType;
	const isTopLevel = envName === TOP_LEVEL_ENV_NAME;
	const field = isTopLevel ? bindingPath : `env.${envName}.${bindingPath}`;
	const bindingError = `"${field}" bindings should have a string "${fieldName}" field but got ${JSON.stringify(binding)}.`;

	const configFile = configFileName(configPath);

	if (isTopLevel) {
		throw new UserError(
			`Processing ${configFile} configuration:\n  - ${bindingError}`
		);
	}

	throw new UserError(
		`Processing ${configFile} configuration:\n  - "env.${envName}" environment configuration\n    - ${bindingError}`
	);
};

/**
 * Generates the environment header string used in the generated types file.
 *
 * @param hash - The hash representing the environment configuration.
 * @param command - The wrangler command used to generate the types.
 *
 * @returns A string containing the comment outlining the generated environment types.
 */
export const getEnvHeader = (hash: string, command?: string): string => {
	const wranglerCommand =
		command ?? ["wrangler", ...process.argv.slice(2)].join(" ");
	return `${ENV_HEADER_COMMENT_PREFIX} \`${wranglerCommand}\` (hash: ${hash})`;
};

/**
 * Generates the runtime header string used in the generated types file.
 * This header is used to detect when runtime types need to be regenerated.
 *
 * @param workerdVersion - The version of workerd to use.
 * @param compatibilityDate - The compatibility date of the runtime. Expected `YYYY-MM-DD` format.
 * @param compatibilityFlags - Any additional compatibility flags to use.
 *
 * @returns A string containing the comment outlining the generated runtime types.
 */
export const getRuntimeHeader = (
	workerdVersion: string,
	compatibilityDate: string,
	compatibilityFlags: Array<string> = []
): string => {
	return `${RUNTIME_HEADER_COMMENT_PREFIX}${workerdVersion} ${compatibilityDate} ${compatibilityFlags.sort().join(",")}`;
};

/**
 * Attempts to convert a boolean serialized as a string.
 *
 * @param value - The unknown or serialized value.
 *
 * @returns `true` or `false` depending on the contents of the string.
 *
 * @throws {ParseError} If the provided value cannot be parsed as a boolean.
 */
const unsafeParseBooleanString = (value: unknown): boolean => {
	if (typeof value !== "string") {
		throw new ParseError({
			text: `Invalid value: ${value}`,
			kind: "error",
		});
	}

	if (value.toLowerCase() === "true") {
		return true;
	}
	if (value.toLowerCase() === "false") {
		return false;
	}

	throw new ParseError({
		text: `Invalid value: ${value}`,
		kind: "error",
	});
};

/**
 * Determines whether the generated types file is stale compared to the current config.
 *
 * Checks if the generated types file at the specified path is up-to-date
 * by comparing the recorded hash and runtime header with what would be
 * generated from the current config.
 *
 * This function parses the wrangler command from the header to extract
 * the original options used for generation, ensuring accurate comparison.
 *
 * @throws {UserError} If the types file doesn't exist or wasn't generated by Wrangler
 */
export const checkTypesUpToDate = async (
	primaryConfig: Config,
	typesPath: string = DEFAULT_WORKERS_TYPES_FILE_PATH
): Promise<boolean> => {
	let typesFileLines = new Array<string>();
	try {
		typesFileLines = readFileSync(typesPath, "utf-8").split("\n");
	} catch (e) {
		if ((e as NodeJS.ErrnoException).code === "ENOENT") {
			throw new UserError(`Types file not found at ${typesPath}.`);
		}

		throw e;
	}

	const existingEnvHeader = typesFileLines.find((line) =>
		line.startsWith(ENV_HEADER_COMMENT_PREFIX)
	);
	const existingRuntimeHeader = typesFileLines.find((line) =>
		line.startsWith(RUNTIME_HEADER_COMMENT_PREFIX)
	);
	if (!existingEnvHeader && !existingRuntimeHeader) {
		throw new UserError(`No generated types found in ${typesPath}.`);
	}

	const { command: wranglerCommand = "", hash: maybeExistingHash } =
		existingEnvHeader?.match(
			/\/\/ Generated by Wrangler by running `(?<command>.*)` \(hash: (?<hash>[a-zA-Z0-9]+)\)/
		)?.groups ?? {};

	// Note: `yargs` doesn't automatically handle aliases, so we check both forms
	const rawArgs = yargs(wranglerCommand).parseSync();

	// Determine what was included based on what headers exist
	// If no env header exists, env types were not included (--include-env=false)
	// If no runtime header exists, runtime types were not included (--include-runtime=false)
	const args = {
		includeEnv: existingEnvHeader
			? unsafeParseBooleanString(rawArgs.includeEnv ?? "true")
			: false,
		includeRuntime: existingRuntimeHeader
			? unsafeParseBooleanString(rawArgs.includeRuntime ?? "true")
			: false,
		envInterface: (rawArgs.envInterface ?? "Env") as string,
		strictVars: unsafeParseBooleanString(rawArgs.strictVars ?? "true"),
	} satisfies Record<string, string | number | boolean>;

	const configContainsEntrypoint =
		primaryConfig.main !== undefined || !!primaryConfig.site?.["entry-point"];

	const entrypoint = configContainsEntrypoint
		? await getEntry({}, primaryConfig, "types").catch(() => undefined)
		: undefined;

	let envOutOfDate = false;
	let runtimeOutOfDate = false;

	// Check if env types are out of date
	if (args.includeEnv) {
		try {
			const { envHeader } = await generateEnvTypes(
				primaryConfig,
				{ strictVars: args.strictVars },
				args.envInterface,
				typesPath,
				entrypoint,
				new Map(),
				false // don't log anything
			);
			const newHash = envHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;
			envOutOfDate = maybeExistingHash !== newHash;
		} catch {
			// If we can't generate env types for comparison, consider them out of date
			envOutOfDate = true;
		}
	}

	// Check if runtime types are out of date
	if (args.includeRuntime) {
		if (!primaryConfig.compatibility_date) {
			// If no compatibility date, we can't check runtime types
			runtimeOutOfDate = true;
		} else {
			const newRuntimeHeader = getRuntimeHeader(
				version,
				primaryConfig.compatibility_date,
				primaryConfig.compatibility_flags
			);
			runtimeOutOfDate = existingRuntimeHeader !== newRuntimeHeader;
		}
	}

	return envOutOfDate || runtimeOutOfDate;
};

/**
 * Detects stale types during `wrangler dev` and optionally regenerates them.
 *
 * Checks the default location for a generated types file and compares if the
 * recorded Env hash, workerd version or compat date and flags have changed
 * compared to the current values in the config. Prompts user to re-run wrangler
 * types if so, or automatically regenerates them during `wrangler dev` if
 * `dev.generate_types` is enabled.
 *
 * This is used during `wrangler dev` to detect out-of-date types.
 */
export const checkTypesDiff = async (config: Config, entry: Entry) => {
	if (!entry.file.endsWith(".ts")) {
		return;
	}

	let maybeExistingTypesFileLines: string[];
	try {
		// Checking the default location only
		maybeExistingTypesFileLines = readFileSync(
			DEFAULT_WORKERS_TYPES_FILE_PATH,
			"utf-8"
		).split("\n");
	} catch {
		return;
	}

	const existingEnvHeader = maybeExistingTypesFileLines.find((line) =>
		line.startsWith(ENV_HEADER_COMMENT_PREFIX)
	);
	const maybeExistingHash =
		existingEnvHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;
	const previousStrictVars = existingEnvHeader?.match(
		/--strict-vars(=|\s)(?<result>true|false)/
	)?.groups?.result;
	const previousEnvInterface = existingEnvHeader?.match(
		/--env-interface(=|\s)(?<result>[a-zA-Z][a-zA-Z0-9_]*)/
	)?.groups?.result;

	let newEnvHeader: string | undefined;
	let newEnvTypes: string | undefined;
	try {
		const { envHeader, envTypes } = await generateEnvTypes(
			config,
			{ strictVars: previousStrictVars === "false" ? false : true },
			previousEnvInterface ?? "Env",
			DEFAULT_WORKERS_TYPES_FILE_NAME,
			entry,
			new Map(),
			// don't log anything
			false
		);
		newEnvHeader = envHeader;
		newEnvTypes = envTypes;
	} catch (e) {
		logger.error(e);
	}

	const newHash = newEnvHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;

	const existingRuntimeHeader = maybeExistingTypesFileLines.find((line) =>
		line.startsWith("// Runtime types generated with")
	);
	const newRuntimeHeader = getRuntimeHeader(
		version,
		config.compatibility_date ?? "",
		config.compatibility_flags ?? []
	);

	const envOutOfDate = existingEnvHeader && maybeExistingHash !== newHash;
	const runtimeOutOfDate =
		existingRuntimeHeader && existingRuntimeHeader !== newRuntimeHeader;

	// Check if the users types have changed since last generation, and if so either prompt them to
	// re-run `wrangler types` or automatically do so for them by enabling `dev.generate_types` or
	// using `wrangler dev --types`.
	const changed = envOutOfDate || runtimeOutOfDate;
	if (!changed) {
		return false;
	}

	if (!config.dev.generate_types) {
		logger.log(
			"❓ Your types might be out of date. Re-run `wrangler types` to ensure your types are correct."
		);
		return true;
	}

	const { runtimeHeader, runtimeTypes } = await generateRuntimeTypes({
		config,
		outFile: DEFAULT_WORKERS_TYPES_FILE_PATH,
	});
	const newTypesFile = [
		newEnvHeader,
		runtimeHeader,
		newEnvTypes,
		runtimeTypes,
	].join("\n");
	try {
		writeFileSync(DEFAULT_WORKERS_TYPES_FILE_PATH, newTypesFile);
		logger.log(
			`❓ Your types looked out of date. We've re-run \`wrangler types\` for you and updated ${DEFAULT_WORKERS_TYPES_FILE_PATH}`
		);
	} catch (e) {
		logger.error(e);
	}

	return true;
};

/**
 * Converts a string to PascalCase.
 *
 * @param str - The input string to convert.
 *
 * @returns The PascalCase version of the input string.
 *
 * @example
 * ```ts
 * toPascalCase("staging") // "Staging"
 * toPascalCase("my-prod-env") // "MyProdEnv"
 * toPascalCase("my_test_env") // "MyTestEnv"
 * ```
 */
export const toPascalCase = (str: string): string =>
	str
		.split(/[-_]/)
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
		.join("");

/**
 * Converts an environment name to an interface name.
 *
 * Handles the `Env` suffix deduplication.
 *
 * @example
 * ```ts
 * toEnvInterfaceName("staging") // "StagingEnv"
 * toEnvInterfaceName("my-prod-env") // "MyProdEnv"
 * toEnvInterfaceName("prod-env") // "ProdEnv"
 * toEnvInterfaceName("testing") // "TestingEnv"
 * ```
 */
export const toEnvInterfaceName = (envName: string): string => {
	const pascalCase = toPascalCase(envName);

	if (pascalCase.endsWith("Env")) {
		return pascalCase;
	}

	return `${pascalCase}Env`;
};

/**
 * Reserved interface names that cannot be used as environment names.
 * Note: Only interface names that can actually be generated by toEnvInterfaceName
 * need to be reserved (i.e., names ending in "Env").
 */
const RESERVED_INTERFACE_NAMES = new Set(["Env"]);

/**
 * Validates that environment interface names don't conflict with reserved names
 * or with each other after PascalCase conversion.
 *
 * @param envNames - Array of environment names from the config
 *
 * @throws {UserError} If a reserved name is used or if there are naming collisions
 */
export const validateEnvInterfaceNames = (envNames: Array<string>): void => {
	const interfaceNames = new Map<string, string>();

	for (const reserved of RESERVED_INTERFACE_NAMES) {
		interfaceNames.set(reserved, `(reserved)`);
	}

	for (const envName of envNames) {
		const interfaceName = toEnvInterfaceName(envName);

		const existingEnv = interfaceNames.get(interfaceName);
		if (existingEnv) {
			if (existingEnv === "(reserved)") {
				throw new UserError(
					`Environment name "${envName}" converts to reserved interface name "${interfaceName}". ` +
						`Please rename this environment to avoid conflicts.`
				);
			}

			throw new UserError(
				`Environment names "${existingEnv}" and "${envName}" both convert to interface name "${interfaceName}". ` +
					`Please rename one of these environments to avoid conflicts.`
			);
		}

		interfaceNames.set(interfaceName, envName);
	}
};
