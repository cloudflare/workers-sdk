import { readFileSync, writeFileSync } from "node:fs";
import { UserError } from "@cloudflare/workers-utils";
import { version } from "workerd";
import yargs from "yargs";
import { getEntry } from "../deployment-bundle/entry";
import { logger } from "../logger";
import { generateRuntimeTypes, getRuntimeHeader } from "./runtime";
import { generateEnvTypes } from ".";
import type { Entry } from "../deployment-bundle/entry";
import type { Config } from "@cloudflare/workers-utils";

export const DEFAULT_WORKERS_TYPES_FILE_NAME = "worker-configuration.d.ts";
export const DEFAULT_WORKERS_TYPES_FILE_PATH = `./${DEFAULT_WORKERS_TYPES_FILE_NAME}`;
export const ENV_HEADER_COMMENT_PREFIX = "// Generated by Wrangler by running";
export const RUNTIME_HEADER_COMMENT_PREFIX =
	"// Runtime types generated with workerd@";

/**
 * Checks if the generated types file at the specified path is up-to-date
 * by comparing the recorded hash and runtime header with what would be
 * generated from the current config.
 *
 * This function parses the wrangler command from the header to extract
 * the original options used for generation, ensuring accurate comparison.
 *
 * @throws {UserError} If the types file doesn't exist or wasn't generated by Wrangler
 */
export const checkTypesUpToDate = async (
	primaryConfig: Config,
	typesPath: string = DEFAULT_WORKERS_TYPES_FILE_PATH
): Promise<boolean> => {
	let typesFileLines = new Array<string>();
	try {
		typesFileLines = readFileSync(typesPath, "utf-8").split("\n");
	} catch (e) {
		if ((e as NodeJS.ErrnoException).code === "ENOENT") {
			throw new UserError(`Types file not found at ${typesPath}.`);
		}

		throw e;
	}

	const existingEnvHeader = typesFileLines.find((line) =>
		line.startsWith(ENV_HEADER_COMMENT_PREFIX)
	);
	const existingRuntimeHeader = typesFileLines.find((line) =>
		line.startsWith(RUNTIME_HEADER_COMMENT_PREFIX)
	);
	if (!existingEnvHeader && !existingRuntimeHeader) {
		throw new UserError(`No generated types found in ${typesPath}.`);
	}

	const { command: wranglerCommand = "", hash: maybeExistingHash } =
		existingEnvHeader?.match(
			/\/\/ Generated by Wrangler by running `(?<command>.*)` \(hash: (?<hash>[a-zA-Z0-9]+)\)/
		)?.groups ?? {};

	// Note: `yargs` doesn't automatically handle aliases, so we check both forms
	const rawArgs = yargs(wranglerCommand).parseSync();

	// Determine what was included based on what headers exist
	// If no env header exists, env types were not included (--include-env=false)
	// If no runtime header exists, runtime types were not included (--include-runtime=false)
	const args = {
		includeEnv: existingEnvHeader
			? Boolean(rawArgs["include-env"] ?? rawArgs.includeEnv) || true
			: false,
		includeRuntime: existingRuntimeHeader
			? Boolean(rawArgs["include-runtime"] ?? rawArgs.includeRuntime) || true
			: false,
		envInterface: (rawArgs["env-interface"] ??
			rawArgs.envInterface ??
			"Env") as string,
		strictVars: Boolean(rawArgs["strict-vars"] ?? rawArgs.strictVars) || true,
	} satisfies Record<string, string | number | boolean>;

	const configContainsEntrypoint =
		primaryConfig.main !== undefined || !!primaryConfig.site?.["entry-point"];

	let entrypoint: Entry | undefined;
	if (configContainsEntrypoint) {
		try {
			entrypoint = await getEntry({}, primaryConfig, "types");
		} catch {
			entrypoint = undefined;
		}
	}

	let envOutOfDate = false;
	let runtimeOutOfDate = false;

	// Check if env types are out of date
	if (args.includeEnv) {
		try {
			const { envHeader } = await generateEnvTypes(
				primaryConfig,
				{ strictVars: args.strictVars },
				args.envInterface,
				typesPath,
				entrypoint,
				new Map(),
				false // don't log anything
			);
			const newHash = envHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;
			envOutOfDate = maybeExistingHash !== newHash;
		} catch {
			// If we can't generate env types for comparison, consider them out of date
			envOutOfDate = true;
		}
	}

	// Check if runtime types are out of date
	if (args.includeRuntime) {
		if (!primaryConfig.compatibility_date) {
			// If no compatibility date, we can't check runtime types
			runtimeOutOfDate = true;
		} else {
			const newRuntimeHeader = getRuntimeHeader(
				version,
				primaryConfig.compatibility_date,
				primaryConfig.compatibility_flags ?? []
			);
			runtimeOutOfDate = existingRuntimeHeader !== newRuntimeHeader;
		}
	}

	return envOutOfDate || runtimeOutOfDate;
};

/**
 * Checks the default location for a generated types file and compares if the
 * recorded Env hash, workerd version or compat date and flags have changed
 * compared to the current values in the config. Prompts user to re-run wrangler
 * types if so, or automatically regenerates if `dev.generate_types` is enabled.
 *
 * This is used during `wrangler dev` to detect out-of-date types.
 */
export const checkTypesDiff = async (config: Config, entry: Entry) => {
	if (!entry.file.endsWith(".ts")) {
		return;
	}

	let maybeExistingTypesFileLines: string[];
	try {
		// Checking the default location only
		maybeExistingTypesFileLines = readFileSync(
			DEFAULT_WORKERS_TYPES_FILE_PATH,
			"utf-8"
		).split("\n");
	} catch {
		return;
	}

	const existingEnvHeader = maybeExistingTypesFileLines.find((line) =>
		line.startsWith(ENV_HEADER_COMMENT_PREFIX)
	);
	const maybeExistingHash =
		existingEnvHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;
	const previousStrictVars = existingEnvHeader?.match(
		/--strict-vars(=|\s)(?<result>true|false)/
	)?.groups?.result;
	const previousEnvInterface = existingEnvHeader?.match(
		/--env-interface(=|\s)(?<result>[a-zA-Z][a-zA-Z0-9_]*)/
	)?.groups?.result;

	let newEnvHeader: string | undefined;
	let newEnvTypes: string | undefined;
	try {
		const { envHeader, envTypes } = await generateEnvTypes(
			config,
			{ strictVars: previousStrictVars === "false" ? false : true },
			previousEnvInterface ?? "Env",
			DEFAULT_WORKERS_TYPES_FILE_NAME,
			entry,
			new Map(),
			// don't log anything
			false
		);
		newEnvHeader = envHeader;
		newEnvTypes = envTypes;
	} catch (e) {
		logger.error(e);
	}

	const newHash = newEnvHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;

	const existingRuntimeHeader = maybeExistingTypesFileLines.find((line) =>
		line.startsWith("// Runtime types generated with")
	);
	const newRuntimeHeader = getRuntimeHeader(
		version,
		config.compatibility_date ?? "",
		config.compatibility_flags ?? []
	);

	const envOutOfDate = existingEnvHeader && maybeExistingHash !== newHash;
	const runtimeOutOfDate =
		existingRuntimeHeader && existingRuntimeHeader !== newRuntimeHeader;

	// Check if the users types have changed since last generation, and if so either prompt them to
	// re-run `wrangler types` or automatically do so for them by enabling `dev.generate_types` or
	// using `wrangler dev --types`.
	const changed = envOutOfDate || runtimeOutOfDate;
	if (!changed) {
		return false;
	}

	if (!config.dev.generate_types) {
		logger.log(
			"❓ Your types might be out of date. Re-run `wrangler types` to ensure your types are correct."
		);
		return true;
	}

	const { runtimeHeader, runtimeTypes } = await generateRuntimeTypes({
		config,
		outFile: DEFAULT_WORKERS_TYPES_FILE_PATH,
	});
	const newTypesFile = [
		newEnvHeader,
		runtimeHeader,
		newEnvTypes,
		runtimeTypes,
	].join("\n");
	try {
		writeFileSync(DEFAULT_WORKERS_TYPES_FILE_PATH, newTypesFile);
		logger.log(
			`❓ Your types looked out of date. We've re-run \`wrangler types\` for you and updated ${DEFAULT_WORKERS_TYPES_FILE_PATH}`
		);
	} catch (e) {
		logger.error(e);
	}

	return true;
};
