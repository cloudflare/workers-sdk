import * as fs from "fs";
import { findUpSync } from "find-up";
import { getEntry } from "./entry";
import { logger } from "./logger";
import type { Config } from "./config";

// Currently includes bindings & rules for declaring modules

export async function generateTypes(
	configToDTS: Partial<Config>,
	config: Config
) {
	const entry = await getEntry({}, config, "types");
	const envTypeStructure: string[] = [];

	if (configToDTS.kv_namespaces) {
		for (const kvNamespace of configToDTS.kv_namespaces) {
			envTypeStructure.push(`	${kvNamespace.binding}: KVNamespace;`);
		}
	}

	if (configToDTS.vars) {
		for (const varName in configToDTS.vars) {
			const varValue = configToDTS.vars[varName];
			if (
				typeof varValue === "string" ||
				typeof varValue === "number" ||
				typeof varValue === "boolean"
			) {
				envTypeStructure.push(`	${varName}: "${varValue}";`);
			}
			if (typeof varValue === "object" && varValue !== null) {
				envTypeStructure.push(`	${varName}: ${JSON.stringify(varValue)};`);
			}
		}
	}

	if (configToDTS.durable_objects?.bindings) {
		for (const durableObject of configToDTS.durable_objects.bindings) {
			envTypeStructure.push(`	${durableObject.name}: DurableObjectNamespace;`);
		}
	}

	if (configToDTS.r2_buckets) {
		for (const R2Bucket of configToDTS.r2_buckets) {
			envTypeStructure.push(`	${R2Bucket.binding}: R2Bucket;`);
		}
	}

	if (configToDTS.d1_databases) {
		for (const d1 of configToDTS.d1_databases) {
			envTypeStructure.push(`	${d1.binding}: D1Database;`);
		}
	}

	if (configToDTS.services) {
		for (const service of configToDTS.services) {
			envTypeStructure.push(`	${service.binding}: Fetcher;`);
		}
	}

	if (configToDTS.dispatch_namespaces) {
		for (const namespace of configToDTS.dispatch_namespaces) {
			envTypeStructure.push(`	${namespace.binding}: any;`);
		}
	}

	if (configToDTS.logfwdr?.schema) {
		envTypeStructure.push(`	LOGFWDR_SCHEMA: any;`);
	}

	if (configToDTS.data_blobs) {
		for (const dataBlobs in configToDTS.data_blobs) {
			envTypeStructure.push(`	${dataBlobs}: ArrayBuffer;`);
		}
	}

	if (configToDTS.text_blobs) {
		for (const textBlobs in configToDTS.text_blobs) {
			envTypeStructure.push(`	${textBlobs}: string;`);
		}
	}

	if (configToDTS.unsafe) {
		for (const unsafe of configToDTS.unsafe.bindings) {
			envTypeStructure.push(`	${unsafe.name}: any;`);
		}
	}

	let queuesGlobal = "";
	if (configToDTS.queues) {
		queuesGlobal =
			IQueueMessage + IQueueMessageBatch + IQueueFunc + IQueueBinding;
		if (configToDTS.queues.producers) {
			for (const queue of configToDTS.queues.producers) {
				envTypeStructure.push(`${queue.binding}: Queue`);
			}
		}
	}

	const modulesTypeStructure: string[] = [];
	if (configToDTS.rules) {
		const moduleTypeMap = {
			Text: "string",
			Data: "ArrayBuffer",
			CompiledWasm: "WebAssembly.Module",
		};
		for (const ruleObject of configToDTS.rules) {
			const typeScriptType =
				moduleTypeMap[ruleObject.type as keyof typeof moduleTypeMap];
			if (typeScriptType !== undefined) {
				ruleObject.globs.forEach((glob) => {
					modulesTypeStructure.push(`declare module "*.${glob
						.split(".")
						.at(-1)}" {
	const value: ${typeScriptType};
	export default value;
}`);
				});
			}
		}
	}

	writeDTSFile({
		envTypeStructure,
		modulesTypeStructure,
		queuesGlobal,
		formatType: entry.format,
	});
}

function writeDTSFile({
	envTypeStructure,
	modulesTypeStructure,
	queuesGlobal,
	formatType,
}: {
	envTypeStructure: string[];
	modulesTypeStructure: string[];
	queuesGlobal: string;
	formatType: "modules" | "service-worker";
}) {
	const wranglerOverrideDTSPath = findUpSync("worker-configuration.d.ts");
	try {
		if (
			wranglerOverrideDTSPath !== undefined &&
			!fs
				.readFileSync(wranglerOverrideDTSPath, "utf8")
				.includes("Generated by Wrangler")
		) {
			throw new Error(
				"A non-wrangler worker-configuration.d.ts already exists, please rename and try again."
			);
		}
	} catch (error) {
		if (error instanceof Error && !error.message.includes("not found")) {
			throw error;
		}
	}

	let combinedTypeStrings = "";
	if (formatType === "modules") {
		if (queuesGlobal.length) {
			combinedTypeStrings += queuesGlobal;
		}
		combinedTypeStrings += `interface Env {\n${envTypeStructure.join(
			"\n"
		)} \n}\n${modulesTypeStructure.join("\n")}`;
	} else {
		combinedTypeStrings += `declare global {\n${envTypeStructure.join(
			"\n"
		)} \n}\n${modulesTypeStructure.join("\n")}`;
	}

	if (envTypeStructure.length || modulesTypeStructure.length) {
		fs.writeFileSync(
			"worker-configuration.d.ts",
			`// Generated by Wrangler on ${new Date()}` + "\n" + combinedTypeStrings
		);
		logger.log(combinedTypeStrings);
	}
}

const IQueueBinding = `
/**
 * A binding that allows a producer to send messages to a Queue.
 */
interface Queue<Body = any> {
	/**
	 * Sends a message to the Queue.
	 * @param message The message can be any type supported by the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types), as long as its size is less than 128 KB.
	 * @returns A promise that resolves when the message is confirmed to be written to disk.
	 */
	send(message: Body): Promise<void>;
}
`;
const IQueueMessage = `
/**
 * A message that is sent to a consumer Worker.
 */
interface Message<Body = unknown> {
	/**
	 * A unique, system-generated ID for the message.
	 */
	readonly id: string;
	/**
	 * A timestamp when the message was sent.
	 */
	readonly timestamp: Date;
	/**
	 * The body of the message.
	 */
	readonly body: Body;
}
`;
const IQueueMessageBatch = `
/**
 * A batch of messages that are sent to a consumer Worker.
 */
interface MessageBatch<Body = unknown> {
	/**
	 * The name of the Queue that belongs to this batch.
	 */
	readonly queue: string;
	/**
	 * An array of messages in the batch. Ordering of messages is not guaranteed.
	 */
	readonly messages: readonly Message<Body>[];
	/**
	 * Marks every message to be retried in the next batch.
	 */
	retryAll(): void;
}
`;

const IQueueFunc = `
interface queue<T> {
	async(
		batch: MessageBatch<T>,
		env: Env,
		context: ExecutionContext
	): Promise<void>;
}
`;
