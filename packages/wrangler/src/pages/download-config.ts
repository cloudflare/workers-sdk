import { existsSync } from "fs";
import { writeFile } from "node:fs/promises";
import TOML from "@iarna/toml";
import chalk from "chalk";
import { fetchResult } from "../cfetch";
import { getConfigCache } from "../config-cache";
import { confirm } from "../dialogs";
import { FatalError } from "../errors";
import { logger } from "../logger";
import * as metrics from "../metrics";
import { printWranglerBanner } from "../update-check";
import { requireAuth } from "../user";
import { PAGES_CONFIG_CACHE_FILENAME } from "./constants";
import type { RawEnvironment } from "../config";
import type {
	CommonYargsArgv,
	StrictYargsOptionsToInterface,
} from "../yargs-types";
import type { PagesConfigCache } from "./types";
import type { Project } from "@cloudflare/types";

// TODO: fix the Project definition
type DeploymentConfig = Project["deployment_configs"]["production"];
interface PagesDeploymentConfig extends DeploymentConfig {
	services: Record<
		string,
		{
			service: string;
			environment?: string;
		}
	>;
	queue_producers: Record<
		string,
		{
			name: string;
		}
	>;
	analytics_engine_datasets: Record<
		string,
		{
			dataset: string;
		}
	>;
	durable_object_namespaces: Record<
		string,
		{
			namespace_id: string;
			class_name: string;
			service: string;
			environment: string;
		}
	>;
	ai_bindings: Record<string, Record<string, never>>;
	wrangler_config_hash?: string;
}

export interface PagesProject extends Project {
	deployment_configs: {
		production: PagesDeploymentConfig;
		preview: PagesDeploymentConfig;
	};
}

async function toEnvironment(
	project: PagesDeploymentConfig,
	accountId: string
): Promise<RawEnvironment> {
	const configObj = {} as RawEnvironment;
	configObj.compatibility_date =
		project.compatibility_date ?? new Date().toISOString().substring(0, 10);
	if (project.compatibility_flags?.length)
		configObj.compatibility_flags = project.compatibility_flags;

	for (const [name, envVar] of Object.entries(project.env_vars ?? {})) {
		if (envVar?.value && envVar?.type == "plain_text") {
			configObj.vars ??= {};
			configObj.vars[name] = envVar?.value;
		}
	}

	for (const [name, namespace] of Object.entries(project.kv_namespaces ?? {})) {
		configObj.kv_namespaces ??= [];
		configObj.kv_namespaces.push({ id: namespace.namespace_id, binding: name });
	}

	for (const [name, ns] of Object.entries(
		project.durable_object_namespaces ?? {}
	)) {
		configObj.durable_objects ??= { bindings: [] };
		if (ns.class_name && ns.class_name !== "") {
			configObj.durable_objects.bindings.push({
				name: name,
				class_name: ns.class_name,
				script_name: ns.service,
				environment: ns.environment,
			});
		} else {
			const namespace = await fetchResult<{
				script: string;
				class: string;
				environment?: string;
			}>(
				`/accounts/${accountId}/workers/durable_objects/namespaces/${ns.namespace_id}`
			);
			configObj.durable_objects.bindings.push({
				name: name,
				class_name: namespace.class,
				script_name: namespace.script,
				environment: namespace.environment,
			});
		}
	}

	for (const [name, namespace] of Object.entries(project.d1_databases ?? {})) {
		configObj.d1_databases ??= [];
		configObj.d1_databases.push({
			database_id: namespace.id,
			binding: name,
			database_name: name,
		});
	}

	for (const [name, bucket] of Object.entries(project.r2_buckets ?? {})) {
		configObj.r2_buckets ??= [];
		configObj.r2_buckets.push({
			bucket_name: bucket.name,
			binding: name,
		});
	}

	for (const [name, { service, environment }] of Object.entries(
		project.services ?? {}
	)) {
		configObj.services ??= [];
		configObj.services.push({
			binding: name,
			service,
			environment,
		});
	}

	for (const [name, queue] of Object.entries(project.queue_producers ?? {})) {
		configObj.queues ??= { producers: [] };
		configObj.queues?.producers?.push({
			binding: name,
			queue: queue.name,
		});
	}

	for (const [name, { dataset }] of Object.entries(
		project.analytics_engine_datasets ?? {}
	)) {
		configObj.analytics_engine_datasets ??= [];
		configObj.analytics_engine_datasets.push({
			binding: name,
			dataset,
		});
	}
	for (const [name] of Object.entries(project.ai_bindings ?? {})) {
		configObj.ai = { binding: name };
	}
	return configObj;
}
async function writeWranglerToml(toml: RawEnvironment) {
	// Pages does not support custom wrangler.toml locations, so always write to ./wrangler.toml
	await writeFile(
		"wrangler.toml",
		[
			`# Generated by Wrangler on ${new Date()}`,
			TOML.stringify(toml as TOML.JsonMap),
		].join("\n")
	);
}

async function downloadProject(accountId: string, projectName: string) {
	const project = await fetchResult<PagesProject>(
		`/accounts/${accountId}/pages/projects/${projectName}`
	);
	logger.debug(JSON.stringify(project, null, 2));

	return {
		name: project.name,
		pages_build_output_dir: project.build_config.destination_dir,
		...(await toEnvironment(project.deployment_configs.preview, accountId)),
		env: {
			production: await toEnvironment(
				project.deployment_configs.production,
				accountId
			),
		},
	};
}

type DownloadConfigArgs = StrictYargsOptionsToInterface<typeof Options>;

export function Options(yargs: CommonYargsArgv) {
	return yargs
		.positional("projectName", {
			type: "string",
			description: "The Pages project to download",
		})
		.option("force", {
			describe: "Overwrite an existing `wrangler.toml` file without prompting",
			type: "boolean",
		});
}

export const Handler = async ({ projectName, force }: DownloadConfigArgs) => {
	void metrics.sendMetricsEvent("download pages config");
	await printWranglerBanner();

	const projectConfig = getConfigCache<PagesConfigCache>(
		PAGES_CONFIG_CACHE_FILENAME
	);
	const accountId = await requireAuth(projectConfig);

	projectName ??= projectConfig.project_name;

	if (!projectName) {
		throw new FatalError("Must specify a project name.", 1);
	}
	const config = await downloadProject(accountId, projectName);
	if (!force && existsSync("wrangler.toml")) {
		const overwrite = await confirm(
			"Your existing `wrangler.toml` file will be overwritten. Continue?",
			{ fallbackValue: false }
		);
		if (!overwrite) {
			throw new FatalError("Not overwriting existing `wrangler.toml` file");
		}
	}
	await writeWranglerToml(config);
	logger.info(
		chalk.green(
			"Success! Your project settings have been downloaded to wrangler.toml"
		)
	);
};
