import { writeFile } from "node:fs/promises";
import TOML from "@iarna/toml";
import chalk from "chalk";
import { fetchResult } from "../cfetch";
import { getConfigCache } from "../config-cache";
import { FatalError } from "../errors";
import { logger } from "../logger";
import * as metrics from "../metrics";
import { printWranglerBanner } from "../update-check";
import { requireAuth } from "../user";
import { PAGES_CONFIG_CACHE_FILENAME } from "./constants";
import type { RawConfig } from "../config";
import type {
	CommonYargsArgv,
	StrictYargsOptionsToInterface,
} from "../yargs-types";
import type { PagesConfigCache } from "./types";
import type { Project } from "@cloudflare/types";

export function mapBindings(
	project: Project["deployment_configs"]["production"]
): RawConfig {
	const configObj = {} as RawConfig;
	for (const [name, envVar] of Object.entries(project.env_vars ?? {}).filter(
		([_, val]) => val && val?.type == "plain_text"
	)) {
		if (envVar?.value) {
			configObj.vars ??= {};
			configObj.vars[name] = envVar?.value;
		}
	}

	for (const [name, namespace] of Object.entries(project.kv_namespaces ?? {})) {
		configObj.kv_namespaces ??= [];
		configObj.kv_namespaces.push({ id: namespace.namespace_id, binding: name });
	}

	// TODO: support Durable Objects
	// for (const [name, namespace] of Object.entries(
	// 	project.durable_object_namespaces ?? {}
	// )) {
	// 	configObj.durable_objects ??= { bindings: [] };
	// 	configObj.durable_objects.bindings.push({
	// 		name: name,
	// 		class_name: binding.class_name,
	// 		script_name: binding.script_name,
	// 		environment: binding.environment,
	// 	});
	// }

	for (const [name, namespace] of Object.entries(project.d1_databases ?? {})) {
		configObj.d1_databases ??= [];
		configObj.d1_databases.push({
			database_id: namespace.id,
			binding: name,
			database_name: name,
		});
	}

	for (const [name, bucket] of Object.entries(project.r2_buckets ?? {})) {
		configObj.r2_buckets ??= [];
		configObj.r2_buckets.push({
			bucket_name: bucket.name,
			binding: name,
		});
	}
	// @ts-expect-error Types are wrong
	for (const [name, { service, environment }] of Object.entries(
		// @ts-expect-error Types are wrong
		project.services ?? {}
	)) {
		configObj.services ??= [];
		configObj.services.push({
			binding: name,
			service,
			environment,
		});
	}

	for (const [name, queue] of Object.entries(
		// @ts-expect-error Types are wrong
		project.queue_producers ?? {}
	)) {
		configObj.queues ??= { producers: [] };
		// @ts-expect-error TS is silly
		configObj.queues.producers.push({
			binding: name,
			// @ts-expect-error Types are wrong
			queue: queue.name,
		});
	}

	// @ts-expect-error Types are wrong
	for (const [name, { dataset }] of Object.entries(
		// @ts-expect-error Types are wrong
		project.analytics_engine_datasets ?? {}
	)) {
		configObj.analytics_engine_datasets ??= [];
		configObj.analytics_engine_datasets.push({
			binding: name,
			dataset,
		});
	}
	for (const [name] of Object.entries(
		// @ts-expect-error Types are wrong
		project.ai_bindings ?? {}
	)) {
		configObj.ai = { binding: name };
	}
	return configObj;
}
async function writeWranglerToml(toml: RawConfig) {
	const wranglerCommandUsed = ["wrangler", ...process.argv.slice(2)].join(" ");

	// Pages does not support custom wrangler.toml locations, so always write to ./wrangler.toml
	await writeFile(
		"wrangler.toml",
		[
			`# Generated by Wrangler on ${new Date()}`,
			`# by running \`${wranglerCommandUsed}\``,
			TOML.stringify(toml as TOML.JsonMap),
		].join("\n")
	);
}

async function downloadProject(accountId: string, projectName: string) {
	const project = await fetchResult<Project>(
		`/accounts/${accountId}/pages/projects/${projectName}`
	);

	return {
		name: project.name,
		pages_build_output_dir: project.build_config.destination_dir,
		compatibility_date:
			project.deployment_configs.production.compatibility_date ??
			new Date().toISOString().substring(0, 10),
		compatibility_flags:
			project.deployment_configs.production.compatibility_flags,
		...mapBindings(project.deployment_configs.production),
		env: {
			production: mapBindings(project.deployment_configs.production),
			preview: mapBindings(project.deployment_configs.preview),
		},
	};
}

type DownloadConfigArgs = StrictYargsOptionsToInterface<typeof Options>;

export function Options(yargs: CommonYargsArgv) {
	return yargs.positional("projectName", {
		type: "string",
		description: "The Pages project to download",
	});
}

export const Handler = async ({ projectName }: DownloadConfigArgs) => {
	void metrics.sendMetricsEvent("pages download config");
	await printWranglerBanner();

	const projectConfig = getConfigCache<PagesConfigCache>(
		PAGES_CONFIG_CACHE_FILENAME
	);
	const accountId = await requireAuth(projectConfig);

	projectName ??= projectConfig.project_name;

	if (!projectName) {
		throw new FatalError("Must specify a project name.", 1);
	}
	const config = await downloadProject(accountId, projectName);
	await writeWranglerToml(config);
	logger.info(
		chalk.green(
			"Success! Your project settings have been downloaded to wrangler.toml"
		)
	);
};
